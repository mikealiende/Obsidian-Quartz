{"Adaptación-Hamiltoniano-genérico-VQE":{"slug":"Adaptación-Hamiltoniano-genérico-VQE","filePath":"Adaptación Hamiltoniano genérico VQE.md","title":"Adaptación Hamiltoniano genérico VQE","links":["VQE","Puerta-de-Hadamard"],"tags":[],"content":"Adaptación Hamiltoniano genérico VQE\nEl objetivo es adaptar el algoritmo  VQE de la manera que podamos calcular el valor esperado de cualquier Hamiltoniano independientemente del operador de Pauli que nos encontremos, es decir, calcular \\bra{\\phi}\\sigma_{i}\\ket{\\phi} y \\bra{\\phi}\\sigma_{i}\\sigma_{j}\\ket{\\phi} para cualquier operador de Pauli.\nOperador de Pauli \\sigma^z\nPara \\sigma^z,  ya demostramos que:\n\\bra{\\phi}\\sigma_{i}^z\\ket{\\phi} = P(\\ket{0}_{i})-P(\\ket{1}_{i} ) \nSiendo P(\\ket{0}) la probabilidad de obtener el estado \\ket{0} al medir el qubit i sobre el estado \\ket{\\phi}.\nOperador de Pauli \\sigma^x\nPara el caso de \\sigma^x usamos la propiedad \\sigma^x = H\\sigma^zH siendo H la Puerta de Hadamard. Siguiendo el razonamiento anterior:\n\\bra{\\phi}\\sigma_{i}^x\\ket{\\phi} = \\bra{\\phi}H\\sigma_{i}^zH\\ket{\\phi}  = \\bra{\\phi}H^{\\dagger}\\sigma_{i}^zH\\ket{\\phi} = \\bra{\\phi&#039;}\\sigma_{i}^z\\ket{\\phi&#039;}\nPor lo tanto para obtener el valor esperado a través de la puerta \\sigma^x, deberemos calcular P(\\ket{0}_{i})-P(\\ket{1}_{i}) sobre el estado \\ket{\\phi&#039;}\nSiendo:\n\\ket{\\phi&#039;} =&amp; H\\ket{\\phi}  \\\\\n\\bra{\\phi&#039;} =&amp;\\bra{\\phi}H^{\\dagger}  \n\\end{align}$$\n### Operador de Pauli $\\sigma^y$\n\nEl razonamiento es el mismo pero utilizando la puerta\n$$H_{y} = \\frac{1}{\\sqrt{ 2 }}\\begin{bmatrix}\n1 &amp; -i \\\\\ni &amp; -1\n\\end{bmatrix}$$\nDe esta manera $\\sigma^y = H_{y}\\sigma^zH_{y}$.\n\n## Producto tensorial de puertas Pauli\n\nTenemos que plantear lo mismo para producto tensorial de cualquier puerta de Pauli. Recordemos que para puertas $\\sigma^z$ tenemos:\n$$\\bra{\\phi}\\sigma_{i}^z\\sigma_{j}^z\\ket{\\phi} = P(\\ket{0}_{i},\\ket{0}_{j})-P(\\ket{1}_{i},\\ket{0}_{j}) -P(\\ket{0}_{i},\\ket{1}_{j}) + P(\\ket{1}_{i},\\ket{1}_{j}) $$\nSiendo por ejemplo $P(\\ket{0}_{i},\\ket{1}_{j})$ la probabilidad de encontrar en $\\ket{0}$ al qubit $i$ y en $\\ket{1}$ al qubit $j$. Para calcular $\\bra{\\phi}\\sigma_{i}^x\\sigma_{j}^x\\ket{\\phi}$ y $\\bra{\\phi}\\sigma_{i}^y\\sigma_{j}^y\\ket{\\phi}$ podemos utilizar la misma técnica que en los casos de una puerta, ejemplo:\n$$\\begin{align}\n\\bra{\\phi}\\sigma_{i}^x\\sigma_{j}^x\\ket{\\phi} = &amp; \\bra{\\phi}H\\sigma_{i}^zHH\\sigma_{j}^zH\\ket{\\phi} =\\\\\n= &amp; \\bra{\\phi}H^{\\dagger}\\sigma_{i}^zI\\sigma_{j}^zH\\ket{\\phi} = \\\\\n \\bra{\\phi}\\sigma_{i}^x\\sigma_{j}^x\\ket{\\phi}=&amp; \\bra{\\phi&#039;}\\sigma_{i}^z\\sigma_{j}^z\\ket{\\phi&#039;} \n\\end{align}$$\nTambién podemos estar en la situación de tener el producto tensorial de dos puertas distintas, ejemplo $\\sigma_{i}^z\\sigma_{j}^x$, para resolver esto recurrimos a encontrar equivalencias con única puerta de Pauli.\n\n### Simplificación de operadores de Pauli\n\nGracias las siguientes reglas siempre vamos a ser capaces de simplificar productos tensoriales de operadores de Pauli.\n#### Reglas de simplificación\n\n* El producto de dos operadores de Pauli iguales es $I$\n* El producto de dos operadores de Pauli distintas, da lugar al tercer operador de Pauli por un coeficiente\n\t* Si el orden alfabético es creciente, el coeficiente es $i$\n\t* Si el orden alfabético es decreciente, el coeficiente es -i\n\t* Ejemplo: $ZX = -iY$ \n\nEjemplo:\n![[Pasted image 20240528190025.png|400]]"},"Adaptación-exponencial-de-Hamiltoniano-genérico-QAOA-y-EVA":{"slug":"Adaptación-exponencial-de-Hamiltoniano-genérico-QAOA-y-EVA","filePath":"Adaptación exponencial de Hamiltoniano genérico QAOA y EVA.md","title":"Adaptación exponencial de Hamiltoniano genérico QAOA y EVA","links":["QAOA","EVA","Trotterización"],"tags":[],"content":"Adaptación exponencial de Hamiltoniano genérico QAOA y EVA\nVamos a plantear una manera genérica de descomponer exponenciales genérica de Hamiltonianos independientemente de sus operadores de Pauli, para usarlo en algoritmos como QAOA y EVA.\nYa vimos como construir con puertas cuánticas e^{i\\sigma_{i}^z} usando R_{z} en [[Modelo Ising#construir—expit-sigma_i-z|Construir  exp(it sigma_{i} z)]] , y e^{i\\sigma_{i}^z\\sigma_{j}^{z}} usando R_{z} y CNOT en [[Modelo Ising#construir—expit-sigma_i-z-sigma_j-z|Construir  exp(it sigma_{i} z sigma_{j} z)]]\nPodemos aplicar la mismo razonamiento y la equivalencia \\sigma^x = H\\sigma^zH, de esta manera:\ne^{it\\sigma^x}= \\cos(t)I+\\sin(t)\\sigma^x = \\cos(t)I+\\sin(t)H\\sigma^zH = HR_{z}H = R_{x}\nPara el caso de e^{i\\sigma_{i}^x\\sigma_{j}^{x}} el procedimiento es igual, colocamos una puerta H al principio y final de los qubits:\n\nDe esta misma manera podríamos construir la exponencial e^{i\\sigma_{i}^z\\sigma_{j}^x} colocando las H en el qubit j\nEl problema que tenemos es que los operadores de Pauli no conmutan entre ellos, por lo tanto no se cumple la siguiente igualdad:\ne^{\\sigma^x+\\sigma^y} \\neq e^{\\sigma^x} e^{\\sigma^y} \nPor lo tanto a priori no podemos construir la exponencial como producto de las exponenciales sus componentes, por lo que debemos recurrir a una técnica llamada Trotterización. Esta técnica nos permitirá aproximar la exponencial de un Hamiltoniano genérico del tipo H=\\sigma^x+\\sigma^z."},"Algebra":{"slug":"Algebra","filePath":"Algebra.md","title":"Algebra","links":["tags/Asignatura","Números-complejos","Geometría-números-complejos","Espacios-vectoriales","Espacio-de-Hilbert"],"tags":["Asignatura"],"content":"Algebra Asignatura\nTema 1. Números complejos\nTransclude of Números-complejos#indice\nTema 2. Geometría números complejos\nTransclude of Geometría-números-complejos#indice\nTema 4. Espacios vectoriales\nTransclude of Espacios-vectoriales#indice\nTema 5. Espacio de Hilbert"},"Algoritmo-de-Bernstein-Verizani":{"slug":"Algoritmo-de-Bernstein-Verizani","filePath":"Algoritmo de Bernstein-Verizani.md","title":"Algoritmo de Bernstein-Verizani","links":["Algoritmo-de-Deutsch‐Jozsa"],"tags":[],"content":"Algoritmo de Bernstein-Verizani\nSe trata de una versión restringida del algoritmo de Algoritmo de Deutsch‐Jozsa, en vez de distinguir entre dos tipo de funciones, intenta encontrar un valor s codificado en una función.\nProblema que resuelve\nDado un oráculo que implementa la función f:\\{0,1\\}^n \\to \\{0,1\\}, donde f(x) es el producto interno binario entre x y un valor secreto s \\in \\{0,1\\}^n . Es decir f(x)= x \\cdot s \\quad\\text{(mod2)} = x_{1}\\cdot s_{1} \\oplus x_{2} \\cdot s_{2}\\oplus\\cdots\\oplus x_{n}\\cdot s_{n}\nEl algoritmo trata de obtener el valor s.\nCon un algoritmo clásico, necesitaremos evaluar la función n veces para encontrar s. En cambio, con este algoritmo lo conseguimos con una única consulta.\nCircuito algoritmo de Bernstein-Verizani\n\nTenemos un registro principal con n qubits inicializados a \\ket{0} y un segundo registro auxiliar inicializado a \\ket{1}.\nInicialización\nComenzamos con \\ket{\\psi_{0}} = \\ket{0}^{\\otimes n}\\otimes \\ket{1}\nAplicamos la puertas Hadamard\n\\ket{\\psi_{1}} = H^{\\otimes n} \\otimes H \\otimes \\ket{\\psi_{0}} = H^{\\otimes n}\\ket{0}^{\\otimes n}\\otimes H\\ket{1}   \nSi continuamos operando:\n\\ket{\\psi_{1}} &amp;= \\left(\\frac{1}{\\sqrt{ 2 }} \\ket{0}+\\frac{1}{\\sqrt{ 2 }}\\ket{1}  \\right)^{\\otimes n}\\otimes \\left(\\frac{1}{\\sqrt{ 2 }} \\ket{0}+\\frac{1}{\\sqrt{ 2 }}\\ket{1}  \\right) = \\\\ \\\\  \n&amp;= \\frac{1}{\\sqrt{ 2^n }}\\sum_{x \\in\\{0,1\\}^n} \\ket{x} \\otimes \\frac{1}{\\sqrt{ 2 }}\\left(\\ket{0} -\\ket{1} \\right) \n\\end{align}$$\n\nSiendo $\\sum_{x \\in\\{0,1\\}^n}\\ket{x}$ todos los valores que puede tomar la base computacional para $n$ qubits. \n\n**Aplicamos el oráculo**\n\nVamos a aplicar $U_{f}$ siendo su definición unitaria: $U_{f} =\\ket{x}\\ket{y} = \\ket{x}\\ket{f(x)\\otimes y}$, entonces:\n\n$$\\begin{align}\n\\ket{\\psi_{2}} = U_{f}\\ket{\\psi_{1}} &amp;= U_{f}\\frac{1}{\\sqrt{ 2^n }}\\left( \\sum_{x \\in\\{0,1\\}^n}\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{0} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{1}   \\right) \\\\  \\\\\n&amp;=\\frac{1}{\\sqrt{ 2^n }}\\left( \\sum_{x \\in\\{0,1\\}^n}\\frac{1}{\\sqrt{ 2 }}U_{f}\\ket{x}\\ket{0} -\\frac{1}{\\sqrt{ 2 }}U_{f}\\ket{x}\\ket{1}   \\right) \\\\ \\\\\n&amp;=\\frac{1}{\\sqrt{ 2^n }}\\left( \\sum_{x \\in\\{0,1\\}^n}\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{f(x)} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{!f(x)}   \\right) \\\\  \\\\\n\\ket{\\psi_{2}} &amp;= \\frac{1}{\\sqrt{ 2^n }}\\left( \\sum_{x \\in\\{0,1\\}^n}\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{f(x)} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{!f(x)}   \\right) \n\\end{align}$$\n\nSi nos centramos en $\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{f(x)} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{!f(x)}$:\n\n$$\\begin{equation}\n\\begin{cases}\n \\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{0} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{1} \\quad \\text{si} \\quad f(x)=0 \\\\ \\\\\n \\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{1} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{0}\\quad \\text{si} \\quad f(x)=1\n\\end{cases}\n\\end{equation}$$\nque es lo mismo que:\n$$\\begin{equation}\n\\begin{cases}\n\\ket{x}\\ket{-}  \\quad \\text{si} \\quad f(x)=0 \\\\ \\\\\n-\\ket{x}\\ket{-}  \\quad \\text{si} \\quad f(x)=1\n\\end{cases}\n\\end{equation}$$\n\nEs decir:\n$$\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{f(x)} -\\frac{1}{\\sqrt{ 2 }}\\ket{x}\\ket{!f(x)} = (-1)^{f(x)}\\ket{x}\\otimes \\ket{-}  $$\nVolviendo a nuestro estado, lo podemos reescribir como:\n$$\\ket{\\psi_{2}} = \\frac{1}{\\sqrt{ 2^n }} \\sum_{x \\in\\{0,1\\}^n}(-1)^{f(x)}\\ket{x}\\otimes \\ket{-}  $$\nObservamos que $\\ket{-}$ no se ha modificado, pero hemos codificado la información de $f(x)$ de este registro auxiliar en nuestro registro principal gracias al fenómeno de [[Phase Kickback]].\n\n**Aplicar Hadamards al registro principal**\n\nPara volver a aplicar las puertas $H^{\\otimes n}$ vamos a utilizar la transformada de Hadamard:\n$$H^{\\otimes n}\\ket{x} =  \\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x \\cdot z}\\ket{z} $$\n\nEn nuestro sistema:\n$$\\begin{align}\n\\ket{\\psi_{3}}&amp;= H^{\\otimes n}\\ket{\\psi_{2}}= \\frac{1}{\\sqrt{ 2^n }} \\sum_{x \\in\\{0,1\\}^n} (-1)^{f(x)}\\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x \\cdot z}\\ket{z}=\\\\ \\\\\n&amp;=\\frac{1}{2^n}\\sum_{x,z \\in\\{0,1\\}^n}(-1)^{f(x)}\\cdot (-1)^{x \\cdot z}\\ket{z}\\\\ \\\\\n\\ket{\\psi_{3}} &amp;=  \\frac{1}{2^n}\\sum_{x,z \\in\\{0,1\\}^n}(-1)^{f(x)+x \\cdot z}\n\\end{align}$$\nComo hemos dicho al plantear el problema, $f(x)= x \\cdot s \\quad\\text{(mod2)}$ \n$$\\ket{\\psi_{3}} =  \\frac{1}{2^n}\\sum_{x,z \\in\\{0,1\\}^n}(-1)^{x\\cdot s+x \\cdot z}\\ket{z} \\to \\frac{1}{2^n}\\sum_{x,z \\in\\{0,1\\}^n}(-1)^{x\\cdot(s\\oplus z)}\\ket{z} $$\n\nFinalmente si medimos $\\ket{\\psi_{3}}$, podemos demostrar que obtenemos el estado $\\ket{s}$, siendo $s$ la cadena buscada.\n\nEl término clave de $\\ket{\\psi_{3}}$ en la medición es:\n$$\\sum_{x \\in\\{0,1\\}^n}(-1)^{x\\cdot(s\\oplus z)}$$\n* si $s\\oplus z=0$ , es decir, $z=s$ entonces $(-1)^{x\\cdot(s\\oplus z)}=1$ para todo $x$. Y el resultado del los dos sumatorios es $2^n$.\n* si $s\\oplus z \\neq 0$, la suma alterna entre $-1$ y $1$ cancelándose, interferencia cuántica destructiva.\n\nDe este modo, nunca mediremos los estados en los que $s \\neq z$. Gracias a que la segunda aplicación $H ^{\\otimes n}$ interfiere constructivamente en las amplitudes de probabilidad en las que $\\ket{z} = \\ket{s}$ y destruye todos los estados $\\ket{z} \\neq \\ket{s}$. Sustituyendo entonces $\\sum_{x,z \\in\\{0,1\\}^n}(-1)^{x\\cdot(s\\oplus z)}=2^n$ cuando $z=s$, tenemos:\n$$\\ket{\\psi_{3}} = \\frac{1}{2^n}\\cdot 2^n \\ket{s} = \\ket{s}  $$\n\nSiendo $s$ la cadena buscada."},"Algoritmo-de-Deutsch":{"slug":"Algoritmo-de-Deutsch","filePath":"Algoritmo de Deutsch.md","title":"Algoritmo de Deutsch","links":[],"tags":[],"content":"Algoritmo de Deutsch\nEl algoritmo de Deutsch fue el primero en demostrar la ventaja cuántica en un problema, en concreto es capaz de dado un oráculo cuántico f(x), donde x puede ser 0 o 1, determina con una única evaluación si f(x) es:\n\nConstante: f(0)=f(1)\nBalanceada: f(0) \\neq f(1)\n\nUn algoritmo clásico para resolver este problema necesitará dos iteraciones.\nOráculo\nPara implementar la función binaria vamos a utilizar el oráculo U_{f}. Si lo expresamos como un operador unitario: \\begin{equation}\nU_{f} \\ket{x}\\ket{y} = \\ket{x}\\ket{y \\oplus f(x)}     \n\\end{equation}\nDescripción del algoritmo\n\nInicialización\nEl algoritmo empieza en el estado \\ket{\\psi_{0}}=\\ket{0}_{A}\\otimes \\ket{1}_{B} =\\ket{0_{A}1_{B}}.\nSuperposición\nPara conseguir superposición vamos a aplicar una puerta Hadamard en ambos qubits.\\begin{equation}\n\\ket{\\psi_{1}}=H\\ket{0}\\otimes H\\ket{1} = \\left[ \\frac{1}{\\sqrt{ 2 }}(\\ket{0}_{A}+\\ket{1}_{A})   \\right]\\left[ \\frac{1}{\\sqrt{ 2 }}(\\ket{0}_{B}-\\ket{1}_{B})   \\right] = \\ket{+ -}    \n\\end{equation}\nDesarrollamos el producto: \\ket{\\psi_{1}}=\\frac{1}{2}(\\ket{0}_{A}\\ket{0}_{B}-\\ket{0}_{A}\\ket{1}_{B}+\\ket{1}_{A}\\ket{0}_{B}-\\ket{1}_{A}\\ket{1}_{B}        )\nAplicamos el oráculo\nUtilizando la expresión del oráculo y aplicando a nuestro circuito, tenemos:\n\\ket{\\psi_{2}}=\\frac{1}{2}(\\ket{0}_{A}\\ket{0\\oplus f(0)}_{B}-\\ket{0}_{A}\\ket{1\\oplus f(0)}_{B}+\\ket{1}_{A}\\ket{0\\oplus f(1)}_{B}-\\ket{1}_{A}\\ket{1\\oplus f(1)}_{B}        ) \\\\ \\\\\n\\frac{1}{2}(\\ket{0}_{A}(\\ket{0\\oplus f(0)}_{B}-\\ket{1\\oplus f(0)}_{B})+\\ket{1}_{A}(\\ket{0\\oplus f(1)}_{B}-\\ket{1\\oplus f(1)}_{B} ))\n\\end{align}\nAplicamos: \\ket{0\\oplus a}- \\ket{1\\oplus a} = (-1)^a(\\ket{0}-\\ket{1}) y tenemos:\n&amp;\\frac{1}{\\sqrt{ 2 }}(\\ket{0}_{A}(-1)^{f(0)}(\\ket{0}_{B}-\\ket{1}_{B}))+ \\frac{1}{\\sqrt{ 2 }}(\\ket{1}_{A}(-1)^{f(1)}(\\ket{0}_{B}-\\ket{1}_{B}  ) )= \\\\ \\\\\n&amp;\\frac{1}{2}((-1)^{f(0)}\\ket{0}_{A}+(-1)^{f(1)}\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})\n\n\\end{align}$$\nVemos que mediante el fenómeno [[Phase Kickback]] hemos transferido la información del qubit $B$ que hemos usando como ancilla al qubit $A$.\n\nSacamos $(-1)^{f(0)}$ factor común como fase global: \n$$\\ket{\\psi_{2}}=\\frac{1}{2}(-1)^{f(0)}(\\ket{0}_{A}+(-1)^{f(1)\\oplus f(0)}\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})$$\n### Análisis en función de $U_f$ y medición\n\n* Si $U_f$ es constante $\\to f(0)\\oplus f(1) = 0$. \n$$\\begin{align}\\ket{\\psi_{2}}=&amp;\\frac{1}{2}(-1)^{f(0)}(\\ket{0}_{A}+(-1)^{0}\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})= \\\\\n&amp;\\frac{1}{2}(-1)^{f(0)}(\\ket{0}_{A}+\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})= \\\\ \\\\\n&amp;(-1)^{f(0)}\\ket{+}\\ket{-}  \n\\end{align}$$\nAplicamos $H$ al primer qubit y tenemos:\n$$\\ket{\\psi_{4}} = (-1)^{f(0)}H\\ket{+}\\ket{-} = (-1)^{f(0)}\\ket{0}\\ket{-}$$\nSi medimos el primer qubit (ignoramos fase global y qubit ancilla) obtenemos $\\ket{0}$ con una probabilidad del $100\\%$ si $U_{f}$ es constante.\n\n\n* Si $U_f$ es balanceada $\\to f(0)\\oplus f(1) = 1$. \n$$\\begin{align}\\ket{\\psi_{2}}=&amp;\\frac{1}{2}(-1)^{f(0)}(\\ket{0}_{A}+(-1)^{1}\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})= \\\\\n&amp;\\frac{1}{2}(-1)^{f(0)}(\\ket{0}_{A}-\\ket{1}_{A})(\\ket{0}_{B}-\\ket{1}_{B})= \\\\ \\\\\n&amp;(-1)^{f(0)}\\ket{-}\\ket{-}  \n\\end{align}$$\nAplicamos $H$ al primer qubit y tenemos:\n$$\\ket{\\psi_{4}} = (-1)^{f(0)}H\\ket{-}\\ket{-} = (-1)^{f(0)}\\ket{1}\\ket{-}$$\n\nComo antes, si medimos obtenemos $\\ket{1}$ con un $100\\%$ de probabilidad cuando es constante. En resumen, hemos demostrado que con el Algoritmo de Deutsch medimos:\n\n* $\\ket{0}$ si $U_{f}$ es constante.\n* $\\ket{1}$ si $U_{f}$ es balanceada."},"Algoritmo-de-Deutsch‐Jozsa":{"slug":"Algoritmo-de-Deutsch‐Jozsa","filePath":"Algoritmo de Deutsch‐Jozsa.md","title":"Algoritmo de Deutsch‐Jozsa","links":["Algoritmo-de-Deutsch","Phase-Kickback"],"tags":[],"content":"Algoritmo de Deutsch‐Jozsa\nSe trata de una generalización del Algoritmo de Deutsch para n qubits. Determina si una función f:\\{0,1\\}^n \\to\\{0,1\\} es constante o balanceada en una única evaluación. Un algoritmo clásico necesitaría 2^{n-1}+1 evaluaciones.\n\nSi f es constante: Devuelve todo 0s o todo 1s para cualquier entrada\nSi f es balanceada: Devuelve la 0s para la mitad de las entradas y 1s para la otra mitad.\n\nCualquier otra combinación, como que para una entrada de un 0 y el resto de entradas 1, no está contemplada en el contexto del algoritmo de Deutsch‐Jozsa.\nDesarrollo del Algoritmo\n\nPartimos de \\ket{\\psi_{0}}= \\ket{0}^{\\oplus n}\\ket{1}.\nAplicamos las n+1 puertas H:\n\\ket{\\psi_{1}}= H^{\\oplus n}\\ket{\\psi_{0}} = \\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{\\sqrt{ 2^n }}\\ket{x} \\frac{\\ket{0}-\\ket{1} }{\\sqrt{ 2 }}     \nDonde \\ket{x} toma cualquier valor posible de la base computacional de n qubits. Ejemplo para n=2: \\ket{x} = \\{00,01,10,11\\}. Si continuamos operando:\n\\ket{\\psi_{1}}= \\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{\\sqrt{ 2^n }}\\frac{\\ket{x} \\ket{0}-\\ket{x} \\ket{1} }{\\sqrt{ 2 }}     \nAplicamos el oráculo U_{f}, que en su forma de operador unitario es U_{f} \\to U_{f}\\ket{x}\\ket{y} = \\ket{x}\\ket{f(x)\\oplus y}. Si lo aplicamos a \\ket{\\psi_{1}}:\n\\ket{\\psi_{2}} = U_{f}\\ket{\\psi_{1}}  = \\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{ 2^n }\\ket{x} \\ket{f(x)}-\\ket{x} \\ket{!f(x)}\nEn el segundo termino tenemos !f(x), ya que a f(x) se le suma 1 en módulo 2. f(x)\\oplus 1= !f(x).\nSacando factor común \\ket{x}:\n\\ket{\\psi_{2}}= \\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{\\sqrt{ 2^n }}\\ket{x} \\cdot\\frac{\\ket{f(x)}-\\ket{!f(x)} }{\\sqrt{ 2 }}    \nPodemos reformular la expresión \\ket{f(x)}-\\ket{!f(x)}= (-1)^{f(x)}(\\ket{0}-\\ket{1}). Bastaría con evaluar f(x) =0 y f(x)=1 para comprobar que se cumple. Entonces:\n\\ket{\\psi_{2}}= \\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{\\sqrt{ 2^n }}(-1)^{f(x)}\\ket{x} \\cdot\\frac{\\ket{0}-\\ket{1} }{\\sqrt{ 2 }}\nAntes de aplicar las H^{\\oplus n}, vamos a dar la siguiente igualdad:\nH\\ket{x}= \\sum_{z \\in\\{0,1\\}}\\frac{(-1)^{x\\cdot z}\\ket{z}}{\\sqrt{2}}  \nGeneralizamos para H^{\\oplus n}:\nH^{\\oplus n}\\ket{x} = \\sum_{z_{1},\\dots,z_{n}\\in\\{0,1\\}} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x_{1}\\cdot z_{1}+\\dots+x_{n}\\cdot z_{n}}\\ket{z_{1},\\dots,z_{n}}=   \\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x\\cdot z}\\ket{z} \nAplicando esto a nuestro estado \\ket{\\psi_{2}}, tenemos:\n\\ket{\\psi_{3}} = H^{\\oplus n}\\ket{\\psi_{2}} = \\sum_{x \\in\\{0,1\\}^{n}} \\frac{(-1)^{f(x)}}{\\sqrt{ 2^n }}\\sum_{z \\in\\{0,1\\}^n} \\frac{(-1)^{x\\cdot z}}{\\sqrt{ 2^n }}\\ket{z} \\cdot\\frac{\\ket{0}-\\ket{1} }{\\sqrt{ 2 }}\nVemos que la información del qubit ancilla ha pasado al resto de qubits gracias al fenómeno de Phase Kickback.\n\\ket{\\psi_{3}} =\\sum_{x \\in\\{0,1\\}^{n}}\\sum_{z \\in\\{0,1\\}^n}  \\frac{(-1)^{f(x)}}{\\sqrt{ 2^n }}\\frac{(-1)^{x\\cdot z}}{\\sqrt{ 2^n }}\\ket{z} \\cdot\\frac{\\ket{0}-\\ket{1} }{\\sqrt{ 2 }}\nPor último, si simplificamos nos queda:\n\\ket{\\psi_{3}}  = \\sum_{x,z \\in\\{0,1\\}^{n}}\\frac{(-1)^{f(x)+x\\cdot z}\\ket{z} }{2^n}\\cdot \\frac{\\ket{0}-\\ket{1}  }{\\sqrt{ 2 }} \nMedición\nVamos a analizar las amplitudes de probabilidad para el estado \\ket{0}^{\\oplus n}, es decir, medir \\ket{0} en todos los qubits. La amplitud es:\n\\sum_{x \\in\\{0,1\\}^{n}} \\frac{1}{2^n}(-1)^{f(x)}\n\nSi f es constante, el valor de la amplitud es +1 o -1, en función del valor constante que tome f(x). Como la amplitud nos indica la probabilidad, en caso de ser constante mediremos \\ket{0} en todos los qubits.\nSi f es balanceada, las contribuciones positivas y negativas de f(x) a la amplitud de probabilidad del estado \\ket{0} se cancelan, dando lugar a una amplitud de probabilidad de 0 al estado \\ket{0}^{\\oplus n}. Por lo tanto, si es balanceada es imposible medir \\ket{0} en todos los qubits, mediríamos con total seguridad algún \\ket{1}.\n"},"Algoritmo-de-Grover":{"slug":"Algoritmo-de-Grover","filePath":"Algoritmo de Grover.md","title":"Algoritmo de Grover","links":[],"tags":[],"content":"Algoritmo de Grover\nEl algoritmo de Grover es una algoritmo de búsqueda en una base de datos no estructurada. Para encontrar un elemento marcado en una lista de N elementos, de forma clásica se necesitará una media de N/2 consultas. El algoritmo de Grover permite encontrar el valor en \\sqrt{ N } consultas. Lo que supone una ventaja cuadrática.\nEl planteamiento del problema es: Dada una función f:\\{0,1\\}^n \\to\\{0,1\\}. Siendo:\n\\begin{cases}\nf(x) =1 \\quad \\text{si }x=w  \\\\\nf(x) =0 \\quad \\text{si }x\\neq w\n\\end{cases}\n\\end{equation}$$\n## Elementos del algoritmo\n\nPara comprender bien el algoritmo, vamos a detallar primero los elementos que intervienen en este algoritmo: superposición, oráculo $U_{w}$ y operador de difusión o de Grover $U_{D}$.\n\n### Superposición equiprobable\n\nComenzamos poniendo  $n$ qubits inicializados a $\\ket{0^{\\otimes n}}$ en superposición aplicando $H^{\\otimes n}$.\n$$H^{\\otimes n}\\ket{0^{\\otimes n}}= \\frac{1}{\\sqrt{ N }}\\sum_{x \\in\\{0,1\\}^{n}}\\ket{x}=\\ket{s}  $$\nSiendo $N=2^n$. Hemos llamado a este estado de superposición $\\ket{s}$ para simplificar. Lo que hemos hecho ha sido poner los $N$ elementos de la lista en superposición.\n\n### Oráculo $U_{w}$\n\nAunque sería posible implantar el algoritmo de Grover con el oráculo estándar $U_{f}$. El oráculo $U_{w}$ lo que hace es &quot;marcar&quot; el estado objetivo $\\ket{w}$ cambiando su signo (invirtiendo su fase) y dejando los demos inalterados. Es decir:\n$$\\begin{equation}\nU_{w}\\ket{x} = \\begin{cases}\n-\\ket{x} \\quad &amp;\\text{si } x=w \\\\\n\\ket{x} \\quad &amp;\\text{si } x \\neq w \n\\end{cases} \n\\end{equation}$$\n\nUtilizando la función $f(x)$ que hemos usado para plantear el problema, podemos escribir el oráculo como:\n$$U_{w}\\ket{k} = (-1)^{f(x)}\\ket{x}$$\n\nCon la [[Demostración geométrica algoritmo de Grover]] veremos que este oráculo lo que hace es una reflexión sobre el hiperplano ortogonal a $\\ket{w}$, utilizando la reflexión Householder podemos definir $U_{w}$ como:\n$$U_{w}=I-2\\ket{w}\\bra{w}$$\nPodemos observar  que $\\ket{w}\\bra{w}$ es el operador proyector sobre el estado $\\ket{w}$.Vamos a demostrar que esta expresión invierte únicamente la fase de $\\ket{w}$.\n\n* Si $\\ket{x}=\\ket{w}$\n\t$$U_{w}\\ket{w} = (I-2\\ket{w}\\bra{w})\\ket{w} = \\ket{w}-2\\ket{w}\\braket{w|w}= \\ket{w} -2\\ket{w}=-\\ket{w}         $$\n\n\tComo todos los estados en superposición del estado $\\ket{s}$ forman una base ortonormal, sabemos que $\\braket{w|w}=1$ y $\\braket{x|w}=0$.\n\n* Si $\\ket{x} \\neq \\ket{w}$\n   $$U_{w}\\ket{x} = (I-2\\ket{w}\\bra{w})\\ket{x} = \\ket{x}-2\\ket{w}\\braket{w|x}= \\ket{x}       $$\n\nEn resumen: $U_{w} = I-2\\ket{w}\\bra{w}$ y su implementación dependerá del problema concreto que queramos solucionar.\n\n### Operador de Difusión o de Grover\n\nDe forma geométrica el operador de difusión $U_{D}$ es una reflexión sobre el estado de superposición $\\ket{s}$. De forma similar a como hemos hecho con el oráculo $U_{w}$, podemos utilizar la reflexión de Householder para definirlo como:\n$$U_{D} = 2\\ket{s}\\bra{s} - I  $$\n\nLa diferencia es que $U_{w} = I-2\\ket{w}\\bra{w}$ refleja un vector sobre el hiperplano ortogonal a $\\ket{w}$, mientras que $U_{D}=2\\ket{s}\\bra{s}_{I}$ es una reflexión sobre $\\ket{s}$.\n\n#### Implementación $U_{D}$ en un circuito cuántico\n\nComo $\\ket{s}=H^{\\otimes n}\\ket{0^{\\otimes n}}$, sustituimos y tenemos:\n$$U_{D} =2H^{\\otimes n}\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}H^{\\otimes n} -I$$\nAl ser $H^{\\otimes n}$ unitario podemos escribir $I$ como $I = H^{\\otimes n}\\otimes H^{\\otimes n}$.  Sustituyendo:\n$$U_{D} =2H^{\\otimes n}\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}H^{\\otimes n} -H^{\\otimes n}\\otimes H^{\\otimes n}$$\nSi sacamos factor común $H^{\\otimes n}$ por la izquierda y $H^{\\otimes n}$ por la derecha, tenemos:\n$$U_{D} =H^{\\otimes n} \\otimes (2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}} -I)\\otimes H^{\\otimes n}$$\nVamos a estudiar como se comporta $2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I$. \n\n* Vamos a empezar aplicándolo a un estado básico cualquiera $\\ket{\\psi}$ distinto a $\\ket{0^{\\otimes n}}$\n\n$$(2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I)\\ket{\\psi} = 2\\ket{0^{\\otimes n}}\\braket {0^{\\otimes n}|\\psi} - \\ket{\\psi} $$\n\tComo $\\ket{\\psi}$ y $\\ket{0}^{\\otimes n}$ son ortogonales $\\braket {0^{\\otimes n}|\\psi}=0$. Tenemos:\n$$(2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I)\\ket{\\psi} = - \\ket{\\psi} $$\n* Ahora vamos a aplicar al estado $\\ket{0^{\\otimes n}}$\n$$(2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I)\\ket{0^{\\otimes n}} = 2\\ket{0^{\\otimes n}}\\braket {0^{\\otimes n}|0^{\\otimes n}} - \\ket{0^{\\otimes n}} = \\ket{0^{\\otimes n}}  $$\n\nEs decir, $2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I$ cambia el signo a todos los estado excepto a $\\ket{0^{\\otimes n}}$, o visto de otro modo equivalente, deja inalterados todos los estados excepto a $\\ket{0^{\\otimes n}}$, que lo cambia de signo. Verlo de una forma u de otra no tiene ningún impacto en la medición. Podemos entonces representar $2\\ket{0^{\\otimes n}}\\bra{0^{\\otimes n}}-I$ como el siguiente circuito cuántico:\n\n![[Pasted image 20250216194639.png|200]]\n\nY por lo tanto el operador de difusión $U_{D}$ lo podemos construir como:\n\n![[Pasted image 20250216194758.png|300]]\n\nEl operador de difusión siempre es el mismo y no depende del problema.\n\nComo ya hemos presentado todos los elementos del algoritmo de Grover lo podemos representar como:\n\n![[Pasted image 20250216195034.png]]\n\nPara entenderlo vamos a ver 3 alternativas de interpretación/demostración:\n\n* [[Interpretación intuitiva Algoritmo de Grover]]\n* [[Demostración geométrica algoritmo de Grover]]\n* [[Demostración matemática del algoritmo de Grover]]"},"Algoritmo-de-Shor":{"slug":"Algoritmo-de-Shor","filePath":"Algoritmo de Shor.md","title":"Algoritmo de Shor","links":[],"tags":[],"content":"Algoritmo de Shor\nEl algoritmo de Shor es uno de los más importantes en la computación cuántica. Este problema resuelve de forma eficiente el problema de factorizar números enteros. Su importancia se debe a que los sistemas criptográficos que utilizan sistemas como RSA se verían comprometidos por este algoritmo ejecutado en un computador cuántico con los qubits suficientes (además de fiables).\nShor logra factorizar el número N en los factores primos p y q en un tiempo polinómico. La clave de el algoritmo es que podemos transformar el problema de factorización de N en el el problema de encontrar el período de la función f(x) = a^{x} (\\text{mod }N) (Este periodo debe cumplir ciertas condiciones). Y el algoritmo de Shor aprovecha que con cierto circuito cuántico que luego veremos podemos calcular estos periodos de forma eficiente.\nEquivalencia entre Factorizar N y encontrar el periodo de f(x) = a^{x} (\\text{mod }N)\nPara empezar vamos a presentar las raíces no triviales módulo N.\nX^2 \\equiv 1\\ \\mod(N) \\quad \\text{con }X \\in (2,N-2) $$\nSi seguimos operando:\n$$\\begin{align}\nX^2 &amp;\\equiv 1 \\ \\mod(N) \\\\\nX^2 -1 &amp;\\equiv 0 \\ \\mod(N) \\\\\n(X-1)(X+1) &amp;\\equiv 0 \\mod(N)\n\\end{align}$$\n\n Esto significa que $(X-1)(X+1)$ es múltiplo de $N$, es decir:\n $$(X-1)(X+1) = k\\cdot N$$\n Vamos a descomponer a $X-1$ y $X+1$ en factores más pequeños de la siguiente manera:\n $$\\begin{equation}\n\\begin{cases}\nX+1 = x_{1}\\cdot x_{2}\\cdot x_{3}\\cdot \\dots \\cdot x_{n} \\\\\nX-1 = y_{1}\\cdot y_{2}\\cdot y_{3}\\cdot \\dots \\cdot y_{m}\n\\end{cases}\n\\end{equation}$$\n\nGracias a la condición de que $X \\in (2,N-2)$, podemos asegurar que $N$ no estará enteramente contenido ni en $X+1$ ni en $X-1$. En otras palabras:\n$$\\begin{equation}\n\\begin{cases}\nX+1 = x_{1}\\cdot x_{2}\\cdot x_{3}\\cdot \\dots \\cdot x_{n}  &lt;N\\\\\nX-1 = y_{1}\\cdot y_{2}\\cdot y_{3}\\cdot \\dots \\cdot y_{m} &lt; N\n\\end{cases}\n\\end{equation}$$\nY como $N = p\\cdot q$, significa que $p$ está en $X+1$ o en $X-1$ y $q$ en factor en el que no esté $p$. Por ejemplo, si $p$ está en $X+1$ y $q$ en $X-1$:\n$$\\begin{equation}\n\\begin{cases}\nX+1 = x_{1}\\cdot x_{2}\\cdot p \\cdot x_{4}\\cdot \\dots \\cdot x_{n} \\\\\nX-1 = y_{1}\\cdot q\\cdot y_{3}\\cdot \\cdot y_{4}\\dots \\cdot y_{m}\n\\end{cases}\n\\end{equation}$$\nSi sustituimos en la ecuación de antes tenemos:\n$$(x_{1}\\cdot x_{2}\\cdot p \\cdot x_{4}\\cdot \\dots \\cdot x_{n})(y_{1}\\cdot q\\cdot y_{3}\\cdot \\cdot y_{4}\\dots \\cdot y_{m}) = k \\cdot N$$\nResulta intuitivo ver que como $p \\cdot q=N$, los factores $x_{i} \\neq p$ y $y_{i} \\neq q$ solo aportan al factor $k$, por lo que podemos obtener $p$ y $q$ con el máximo común divisor así:\n$$\\begin{align}\nMCD(X+1,N) =p \\\\\nMCD(X-1,N) = q\n\\end{align}$$\n\n==De momento hemos demostrado que factorizar un número es equivalente a encontrar sus raíces no triviales modulo $N$. Ahora veremos que la búsqueda de estas raíces es equivalente a encontrar el período de un función.==\n\nVamos a definir el orden $r$ como el número positivo más pequeño que cumple:\n$$a^r \\equiv 1 \\mod(N)$$\nSiendo a un entero positivo coprimo con $N$, tal que: $MDC(a,N)=1$.\n\nSi definimos la función $f(x)=a^x \\mod(N)$ es fácil ver que el orden $r$ coincide con el periodo de la función, ya que $f(0) = a^0 \\mod(N) \\equiv 1 \\mod(N)$, y como $r$ es el primer entero siguiente a $0$ que cumple $a^r \\equiv 1 \\mod(N)$ vemos que es el periodo tal que $f(x) = f(x+k)$.\n\nCon esto podemos asegurar que calcular el orden $r \\mod(N)$   es equivalente a encontrar el periodo de $f(x)= a^x \\mod(N)$. \n\nSi este orden $r$ es par, podemos escribirlo como:\n$$\\begin{align}\n(a^{r/2})^2 \\equiv 1 \\mod(N) \\\\\n(a^{r/2})^2 -1\\equiv 0 \\mod(N) \\\\\n(a^{r/2}-1)(a^{r/2}+1)\\equiv 0 \\mod(N)\n\\end{align}$$\n\nVemos que tiene la misma forma que la demostración de antes de que encontrar las raíces no triviales de modulo $N$ equivale a facotorizar, por lo tanto, usando lo que hemos demostrado antes:\n\n$$\\begin{align}\nMDC(a^{r/2}-1,N) = p \\\\\nMDC(a^{r/2}+1,N) =que \n\\end{align}$$\n\nPor lo tanto hemos demostrado que factorizar $N$ es equivalente a encontrar un periodo par de la función $f(x) = a^x \\mod(N)$, siendo a un entero aleatorio coprimo de $N$. [[Ejemplo equivalencia entre encontrar el periodo y factorizar]]\n\n## Descripción detallada del algoritmo de Shor.\n\nEl algoritmo de Shor completo de trata de un algoritmo mixto, ya que aparte de la parte cuántica que utilizamos para calcular el periodo en tiempo polinomial, también requiere de un pre y post procesado clásico.\n\n* **Pre-procesado clásico**: Básicamente comprueba que $N$ se puede factorizar de forma no trivial y escoge el valor aleatorio $a$.\n* **Parte cuántica**: A partir del valor $a$ calcularemos con un algoritmo cuántico el periodo $r$ de la función $f(x) =a^x \\mod(N)$.\n* **Post-procesado clásico**: Veremos que del algoritmo cuántico no obtenemos directamente $r$ si no que tenemos que utilizar algoritmos como el de fracciones continuas para terminar de calcular $r$, también comprueba si $r$ es par y calcula $p$ y $q$.\n\n### Encontrar el periodo $r$ con circuitos cuánticos.          \n\nTenemos dos registros cuánticos:\n* Registro 1 con $t$ qubits\n* Registro 2 con $n$ qubits\n\nTodos los qubits están inicializados a $\\ket{0}$, entonces partimos de $\\ket{\\psi_{0}}=\\ket{0^{\\otimes t}}\\otimes\\ket{0^{\\otimes n}}$\n\n**Superposición.**\n\nAplicamos la puerta $H^{\\otimes t}$ al registro 1 para ponerlo en superposición:\n$$\\begin{align}\n\\ket{\\psi_{1}}&amp;=  H^{\\otimes t}\\otimes I^{\\otimes n}\\ket{\\psi_{0}} =  \\\\\n&amp;=H^{\\otimes t}\\ket{0^{\\otimes t}}\\otimes\\ket{0^{\\otimes n}} = \\\\\n\\ket{\\psi_{1}} &amp;= \\frac{1}{\\sqrt{ Q }}\\sum_{k=0}^{Q}\\ket{x}\\otimes \\ket{0^{\\otimes n}}    \\\\\n\\end{align}$$\nSiendo $Q=2^t$.\n\n**Exponenciación modular**\n\nPara implementar la función $f(x) =a^x \\mod(N)$ vamos a usar el oráculo $U_{f(x)}$ , que se puede implementar con el algoritmo de exponenciación modular cuántica. De forma unitaria:\n$$U_{f(x)}\\ket{x}\\ket{y} = \\ket{x}\\ket{y \\oplus a^x \\mod(N)}    $$\nAplicándolo a nuestro estado:\n$$\\ket{\\psi_{2}}=U_{f(x)}\\ket{\\psi_{1}} =  \\frac{1}{\\sqrt{ Q }}\\sum_{k=0}^{Q}\\ket{x}\\otimes \\ket{a^x \\mod(N)}    $$\n**Medición registro 2**\n\nAl medir el registro 2, vamos a hacer colapsar a $\\ket{a^x \\mod(N)}$ a un valor específico $z=a^{x_{0}} \\mod(N)$. Esta medición provoca que el estado en superposición del registro 1 se proyecte (colapse) en el subespacio generado por los autoestados $\\ket{x}$ consistentes en el valor medido $z=a^{x_{0}} \\mod(N)$. Es decir, en el registro 1 sólo nos quedamos con los valores de $x$ que sean resultado del $f(x) =z$ medido. Por lo tanto después de medir el registro 1 tenemos:\n$$\\ket{\\psi_{3}} = \\frac{1}{\\sqrt{ \\frac{Q}{r} }}\\sum_{k=0}^{Q /r} \\ket{x_{0}+k\\cdot r } = \\sqrt{ \\frac{r}{Q } }\\cdot \\sum_{k=0}^{Q /r} \\ket{x_{0}+k\\cdot r }$$\nDonde $x_{0}$ es el primer entero que da como resultado $z$. Este valor $x_{0}$, nos esta complicando el cálculo de $r$. Vamos a utilizar la [[Transformada cuántica de Fourier QFT]] para eliminar este valor.\n\n**QFT registro 1**\n\nAntes de empezar tenemos que tener en cuanta lo siguiente:\n\n* $Q$ es multiplo de r\n* $QFT\\ket{x} = \\frac{1}{\\sqrt{ Q }}\\sum_{y=0}^{Q}e^{2\\pi i {x\\cdot y}/Q}\\ket{y}$\n\nAplicamos $QFT$ a $\\ket{\\psi_{3}} =$\n\n$$\\begin{align}\n\\ket{\\psi_{4}}=QFT\\ket{\\psi_{3}}=  \\sqrt{ \\frac{r}{Q } }\\cdot \\sum_{k=0}^{Q /r} \\frac{1}{Q}\\cdot \\sum_{y=0} ^{Q}e^{2\\pi i(x_{0}+k\\cdot r)y/Q}\\ket{y} \\\\ \\\\\n\\ket{\\psi_{4}} =\\frac{\\sqrt{ r }}{Q }\\sum_{k=0}^{Q /r} \\sum_{y=0} ^{Q}e^{2\\pi ix_{0}y/Q}\\cdot e^{2\\pi i+k\\cdot r\\cdot y/Q} \\ket{y} \n\\end{align}$$\n\nVamos a analizar el factor $e^{2\\pi i+k\\cdot r\\cdot y/Q}$ de la expresión de arriba, si se da el caso que $y$ es múltiplo de $\\frac{Q}{r}$ entonces $e^{2\\pi i+k\\cdot r\\cdot y/Q}=1$, y entonces, el coeficiente del estado que cumple este caso sería:\n$$\\frac{\\sqrt{ r }}{Q} \\cdot \\frac{Q}{r}e^{2\\pi i x_{o}\\cdot y /Q} \\cdot 1 = \\frac{1}{\\sqrt{ r }}\\phi_{y}$$\nSiendo $^{2\\pi i x_{o}\\cdot y /Q} =\\phi_{y}$, pero al ser una fase global no afecta en el resultado de la medición. Entonces el coeficiente de los estados $\\ket{y}$ cuando $y$ es múltiplo de $\\frac{Q}{r}$ es $\\frac{1}{\\sqrt{ r }}$.\n\nTeniendo en cuenta que en $Q$ hay $r$ múltiplos de $\\frac{Q}{r}$, cuando $y$ recorra todos los valores se dará el caso de que $y$ es múltiplo de $\\frac{Q}{r}$ un total de $r$ veces, lo que nos permite calcular la probabilidad de que $y$ sea múltiplo de $\\frac{Q}{r}$.\n\n$$P\\left( y=k \\cdot\\frac{Q}{r} \\right) = |\\frac{{1}}{\\sqrt{r  }}|^2+ \\dots \\text{ n veces } \\cdot |\\frac{{1}}{\\sqrt{r  }}|^2 = \\sum^r |\\frac{{1}}{\\sqrt{r  }}|^2 =1$$\n\nQue la probabilidad de que $y$ sea múltiplo de $\\frac{Q}{r}$ sea 1, significa entonces que la probabilidad de que no lo sea es entonces 0. Es decir, siempre que midamos un $\\ket{y}$, este será múltiplo de $\\frac{Q}{r}$. Asi que podemos decir:\n$$\\sqrt{ \\frac{r}{Q } }\\cdot \\sum_{k=0}^{Q /r} \\ket{x_{0}+k\\cdot r }\\rightarrow^{QFT}\\rightarrow \\frac{1}{\\sqrt{ r }}\\sum_{k=0}^{r}\\ket{k \\cdot \\frac{Q}{r}} $$\nPor lo que al medir en el registro 1 mediremos siempre $k \\cdot \\frac{Q}{r}$ \n\nCon una etapa final de post-procesado clásico en el que podemos usar el algoritmo de fracciones continuas para obtener $r$ a partir de $k \\cdot \\frac{Q}{r}$. Y después calcularíamos $p$ y $q$ así:\n$$\\begin{align}\nMCD(a^{r/2}+1,N) = p \\\\\nMCD(a^{r/2}-1,N) = q\n\\end{align}$$\n\nEste post-procesado cuántico también comprueba que $r$ es par, si no empezamos el ciclo desde el principio con otro valor de $a$."},"Algoritmo-de-Simon":{"slug":"Algoritmo-de-Simon","filePath":"Algoritmo de Simon.md","title":"Algoritmo de Simon","links":[],"tags":[],"content":"Algoritmo de Simon\nEl algoritmo de Simon es el primero que logra una mejora exponencial respecto a un algoritmo clásico.Utiliza un número lineal de consultas, mientras que un algoritmo clásico necesitamos un número exponencial de consultas.\nDescripción del problema.\nDada una función f implementada en un oráculo, tal que: f:\\{0,1\\}^n . El algoritmo consiste en distinguir si:\n\nLa función es 1a1 (inyectiva), donde cada entrada distinta genera una una salida distinta.\nLa función es 2a1 (no inyectiva), la función asigna dos entradas distintas a la misma salida.\n\nEl algoritmo de Simon impone también una condición al problema:\n\nSi la función es 2a1, para dos entradas distintas x_{1} y x_{2} con la misma salida, es decir, f(x_{1})=f(x_{2}). Existe un valor s tal que x_{1}\\oplus x_{2} =s, con s \\in\\{0,1\\}^n\n\nSi s = 0^n \\to La función es 1a1 (inyectiva).\nSi s \\neq 0^n \\to La función es 2a1.\n\n\n\nCircuito del algoritmo de Simon\n\nTenemos dos registros de n qubits. Al registro principal le llamaremos A, y al auxiliar B.\n\nEstado inicial\n\nPartimos de \\ket{\\psi_{0}}= \\ket{0}^{\\otimes n}\\otimes \\ket{0}^{\\otimes n}\n\nAplicamos puertas Hadamard al registro A\n\n\\ket{\\psi_{1}}&amp;= H^{\\otimes n}\\otimes I^{\\otimes n}\\ket{\\psi_{0}} = H^{\\otimes n}\\ket{0}^{\\otimes n}\\otimes \\ket{0}^{\\otimes n} \\\\ \\\\\n\\ket{\\psi_{1}}&amp;= \\sum_{x \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}\\ket{x}\\otimes \\ket{0}^{\\otimes n}\n\\end{align}   $$\n* **Aplicamos oráculo $U_{f}$**\n\nLa expresión unitaria del oráculo aplicada a un sistema de dos qubits es: $U_{f}\\ket{x}\\ket{y} = \\ket{x}\\ket{y \\oplus f(x)}$. En el caso de nuestro circuito, el registro $B$ es $\\ket{0}^{\\otimes n}$, tenemos que $\\ket{0\\oplus f(x)} = \\ket{f(x)}$. Por lo tanto:\n$$\\ket{\\psi_{2}} = U_{f}\\ket{\\psi_{1}} = \\sum_{x \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}\\ket{x}\\otimes \\ket{f(x)}$$\n\n* **Medición del registro $B$**\n\nAl medir el registro $B$, es decir, $f(x)$. Vamos a hacer colapsar al sistema completo al subespacio asociado al valor $f(x)$ medido. Debido a la naturaleza cuántica de la medición de un sistema entrelazado, al medir el registro $B$ provocamos un colapso del registro a un autoestado, o combinación de autoestados compatibles con el resultado de la medición.\n\nEl caso más interesante en nuestro problema es el caso de que la función sea 2a1, el estado del sistema será una superposición equiprobable de los valores compatibles con la medición, llamémosles $x_{1}$ y $x_{2}$. Quiere decir entonces que $f(x_{1})=f(x_{2})$, y podemos describir el estado del sistema completo después de la medición como:\n\n$$\\ket{\\psi_{3}}= \\frac{1}{\\sqrt{ 2 }}(\\ket{x_{1}}+\\ket{x_{2}})$$\n* Volvemos a aplicar puertas Hadamard al registro $A$**\n\nPara volver a aplicar las puertas $H^{\\otimes n}$ vamos a aprovecharnos de la **transformada de Hadamard**:\n$$H^{\\otimes n}\\ket{x} =  \\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x \\cdot z}\\ket{z} $$\nAplicando en nuestro estado:\n\n$$\\begin{align}\n\\ket{\\psi_{4}} &amp;= H^{\\otimes n}\\ket{\\psi_{3}} = \\frac{1}{\\sqrt{ 2 }}(H^{\\otimes n}\\ket{x_{1}} +H^{\\otimes n}\\ket{x_{2}} ) = \\\\ \\\\\n&amp;= \\frac{1}{\\sqrt{2 }}\\left( \\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x_{1} \\cdot z}\\ket{z} + \\sum_{z \\in\\{0,1\\}^n} \\frac{1}{\\sqrt{ 2^n }}(-1)^{x_{2} \\cdot z}\\ket{z}  \\right) =\\\\ \\\\\n&amp;= \\frac{1}{\\sqrt{ 2 }}\\left( \\frac{1}{\\sqrt{ 2^n }} \\sum_{z \\in\\{0,1\\}^n}(-1)^{x_{1} \\cdot z}+(-1)^{x_{2} \\cdot z}\\ket{z} \\right) = \\\\ \\\\\n\\ket{\\psi_{4}}&amp;=  \\frac{1}{\\sqrt{ 2^{n+1} }}\\sum_{z \\in\\{0,1\\}^n}(-1)^{x_{1} \\cdot z}+(-1)^{x_{2} \\cdot z}\\ket{z}\n\\end{align} $$\n\nSi medimos ahora, vamos a obtener un estado $\\ket{z}$, por ejemplo, $\\ket{z_{1}}$ en función de sus amplitudes de probabilidad. El hecho de haber medido $\\ket{z_{1}}$ significa que que para este autoestado se cumple: $$(-1)^{x_{1} \\cdot z_{1}}=(-1)^{x_{2}\\cdot z_{1}} $$\nYa que, en caso contrario estos valores se hubieran anulado y nunca hubiéramos medido $\\ket{z_{1}}$, por lo tanto, el mero hecho de haberlo medido justifica la igualdad de arriba. Entonces:\n$$\\begin{align}\n(-1)^{x_{1} \\cdot z_{1}}&amp;=(-1)^{x_{2}\\cdot z_{1}}  \\\\\nx_{1}\\cdot z_{1} &amp;= x_{2}\\cdot z_{1}\n\\end{align}$$\n\nAhora vamos a hacer uso de la condición que hemos impuesto al problema para funciones 2a1, donde $f(x_{1})=f(x_{2})$ (precisamente lo que hemos conseguido) se debe cumplir: $x_{1}\\oplus x_{2} =s \\to x_{2} = x_{1}\\oplus s$. \nSi sustituimos:\n\n$$\\begin{align}\nx_{1}\\cdot z_{1} &amp;= (x_{1}\\oplus s)\\cdot z_{1}  =  \\\\\nx_{1}\\cdot z_{1} &amp;= (x_{1}\\cdot z_{1} \\oplus s\\cdot z_{1})  =   \\\\\ns \\cdot z_{1} &amp;=0\n\\end{align}$$\nHemos obtenido un vector $z_{1}$ tal que $s \\cdot z_{1} = 0$ (mod2). Vamos a repetir este paso $O(n)$ veces hasta conseguir un conjunto de vectores $\\{z_{1},z_{2},\\dots,z_{n}\\}$ que formen un sistema de ecuaciones linealmente independientes del tipo:\n$$\\begin{align} \nz_{1}\\cdot s &amp;= 0 \\quad \\text{mod 2} \\\\\nz_{2}\\cdot s &amp;= 0 \\quad \\text{mod 2} \\\\ \\\\\n\\vdots \\\\\nz_{n}\\cdot s &amp;= 0 \\quad \\text{mod 2} \\\\\n\\end{align}$$\n\n==Resolviendo el sistema de forma clásica para encontrar $s \\neq0$ que satisfaga $z_{n}\\cdot s = 0 \\quad \\text{mod 2} \\quad\\forall i$ . Si la única solución es $s =0$, entonces la función es 1a1 o inyectiva, en cambio si hemo encontrado ese valor $s \\neq 0$, entonces la función es 2a1.=="},"Algoritmos-cuánticos":{"slug":"Algoritmos-cuánticos","filePath":"Algoritmos cuánticos.md","title":"Algoritmos cuánticos","links":["tags/Asignatura","Problemas-QUBO","Quantum-Annealing","VQE","QAOA","EVA","Optimización-en-Hamiltonianos-genéricos","Quantum-machine-learning","Redes-neuronales-cuánticas","Quantum-Support-Vector-Machine"],"tags":["Asignatura"],"content":"Algoritmos cuánticos Asignatura\nTema 1 Problemas QUBO y Quantum Annealing\nTema 2 VQE\nTema 3 QAOA\nTema 4 EVA\nTema 5 Optimización en Hamiltonianos genéricos\nTema 6 Quantum machine learning\nTema 7 Redes neuronales cuánticas\nTema 8 Quantum Support Vector Machine"},"Algoritmos-cuánticos-avanzados":{"slug":"Algoritmos-cuánticos-avanzados","filePath":"Algoritmos cuánticos avanzados.md","title":"Algoritmos cuánticos avanzados","links":["Transformada-cuántica-de-Fourier-QFT","Quantum-Phase-Estimation","Algoritmo-de-Grover","Algoritmo-de-Shor"],"tags":[],"content":"Algoritmos cuánticos avanzados\n\nTransformada cuántica de Fourier QFT\nQuantum Phase Estimation\nAlgoritmo de Grover\nAlgoritmo de Shor\n"},"Algoritmos-cuánticos-básicos":{"slug":"Algoritmos-cuánticos-básicos","filePath":"Algoritmos cuánticos básicos.md","title":"Algoritmos cuánticos básicos","links":["tags/Tema","Algoritmo-de-Deutsch","Algoritmo-de-Deutsch‐Jozsa","Algoritmo-de-Simon","Algoritmo-de-Bernstein-Verizani"],"tags":["Tema"],"content":"Algoritmos cuánticos básicos Tema\nAlgoritmo de Deutsch\nAlgoritmo de Deutsch‐Jozsa\nAlgoritmo de Simon\nAlgoritmo de Bernstein-Verizani"},"Argumento":{"slug":"Argumento","filePath":"Argumento.md","title":"Argumento","links":[],"tags":[],"content":"Argumento\n"},"Aritmética-de-números-complejos":{"slug":"Aritmética-de-números-complejos","filePath":"Aritmética de números complejos.md","title":"Aritmética de números complejos","links":["Módulo","Conjugado","Argumento","Distancia","forma-polar"],"tags":[],"content":"Aritmética de números complejos\nVeremos todas las operaciones de los números complejos\n\nHaremos varias definiciones:\n\nMódulo\nConjugado\nArgumento\nDistancia\nforma polar\n"},"Autómatas-celulares":{"slug":"Autómatas-celulares","filePath":"Autómatas celulares.md","title":"Autómatas celulares","links":[],"tags":[],"content":"Autómatas celulares\nModelo de computación discreto.\nEsta compuesto por una cuadricula regular de celdas, cada una de ellas en un estado “on” o “off”. Los estados son finitos. Para cada celda se define un conjunto de celdas, llamado vecindario, en relación con la celda especificada.\n\nLa evolución del autómata celular es:\n\nUn estado inicial (tiempo t = 0) se selecciona asignando un estado para cada celda.\nSe crea una nueva generación (t=1) de acuerdo con una regla fija (función matemática), que determina el nuevo estado de la celda en términos del estado actual de la celda y los estados de las celdas de su vecindario.\n\nEvolución de un autómata celular con diferentes reglas\n\nClasificación de autómatas celulares\n\n\nClase 1: casi todos los patrones iniciales evolucionan rápidamente a un estado estable y homogéneo.\n\n\nClase 2: casi todos los patrones iniciales evolucionan rápidamente a estructuras estables o periódicas.\n\n\nClase 3: casi todos los patrones iniciales evolucionan de manera pseudoaleatoria o caótica. Cualquier estructura estable que aparezca es rápidamente destruida por el ruido circundante.\n\n\nClase 4: casi todos los patrones iniciales evolucionan hacia estructuras que interactúan de manera compleja. Se ha sugerido que los autómatas celulares de clase 4 pueden constituir un modelo de computación universal\n\n\nTienen multitud de aplicaciones en campos como la simulación de sistemas biológicos, químicos, etc…"},"Autómatas-de-pila":{"slug":"Autómatas-de-pila","filePath":"Autómatas de pila.md","title":"Autómatas de pila","links":[],"tags":[],"content":"Autómatas de pila\nLos autómatas de pila reciben una cadena constituida por símbolos de un alfabeto, y determinan si esa cadena pertenece al lenguaje que el autómata reconoce.\nAdemás de una cinta de entrada y un control de estados como una autómata de estados finitos, cuenta con una pila (stack) como memoria adicional. Esto le permite almacenar y recuperar información.\nPara describir con una séptupla M=(S,\\Sigma, \\Gamma, \\delta,s,Z,F), donde:\n\nS: Conjunto finito de estados\n\\Gamma y \\Sigma: Son alfabetos. Símbolos de la pila y símbolos de entrada respectivamente.\n\\delta: S\\times(\\Sigma \\cup\\{\\epsilon\\})\\times  \\Gamma\\rightarrow P(S\\times \\Gamma *)\ns \\in S: Estado inicial\nZ \\in \\Gamma: Estado inicial de la pila\nF \\subseteq S: Conjunto de estados finales\n\nLas transiciones pueden describirse de la siguiente manera:\n\nEl autómata de pila comienza en su estado inicial, apuntando al primer símbolo de la cinta y la pila inicialmente vacía.\nEl autómata lee el símbolo actual de la cinta.\nTransición. En base al estado actual, el símbolo leído y el símbolo en la cima de la pila. El autómata:\n\nCambia a un nuevo estado\nMueve el cabezal de lectura a la siguiente posición de la cinta\nRealiza una operación en la pila:\n\nApilar (push): Introduce un nuevo símbolo en la cima de la pila.\nDesapilar(pop): Extrae el símbolo de la cima de la cima de la pila.\nNada\n\n\n\n\nRepetición de los pasos 2 y 3\nAceptación o rechazo. El autómata acepta la cadena de entrada si termina un estado de aceptación y si no, la rechaza.\n\n"},"Barren-Plateaus":{"slug":"Barren-Plateaus","filePath":"Barren Plateaus.md","title":"Barren Plateaus","links":[],"tags":[],"content":"Barren Plateaus\nSe trata de unos de los mayores inconvenientes de los circuitos cuánticos de redes neuronales. El problema es que al aumentar el número de qubits de un circuito la varianza del valor esperado tiende a 0, por lo tanto es mucho más difícil encontrar el mínimo de la función.\n"},"Base-C":{"slug":"Base-C","filePath":"Base C.md","title":"Base C","links":["Notación-de-Dirac"],"tags":[],"content":"Base C\nVamos estudiar las bases estándar en Notación de Dirac.\nDefinición\n\nRepresentación estado arbitrario\nDecimos que el estado |φ⟩ es una superposición de los estados base. Además |φ⟩ re- presenta la partícula que esta simultaneamente en todos los {0, 1, … , n − 1} . A los escalares c0, c1, … , cn−1 se le conocen como amplitudes complejas. Y justamente es- tos escalares no dicen en que superposición se encuentra nuestra partícula. Ahora la probabilidad de que la partícula se encuentre en algún punto i después de observar la partícula es\n\nEjemplo\n"},"Base-Fourier":{"slug":"Base-Fourier","filePath":"Base Fourier.md","title":"Base Fourier","links":[],"tags":[],"content":"Base Fourier\nEn la base de Fourier la información se almacena en rotaciones alrededor del eje Z. El número que se desea almacenar determina el ángulo de la fase en la que el qubit deberá rotar alrededor del eje Z. ejemplo para representar el número 5 con 4 qubits:\n\nEl qubit de menos peso deberá rotar \\frac{5}{2^n}2\\pi=\\frac{5}{16}2\\pi radianes.\nEl siguiente rotará el doble: \\frac{10}{16}2\\pi radianes.\nEl siguiente el doble que el anterior: \\frac{20}{16}2\\pi radianes.\nEl más significativo, el doble que el anterior: \\frac{40}{16}2\\pi radianes.\n\nSe puede observar que los qubits correspondientes al dígito menos significativo tiene la frecuencia de rotación más baja."},"Base-computacional":{"slug":"Base-computacional","filePath":"Base computacional.md","title":"Base computacional","links":[],"tags":[],"content":"Base computacional\nEs la base estándar \\{\\ket{0},\\ket{1}\\} en la que se representan números en computación cuántica. De forma similar al sistema binaria en computación clásica podemos representar números enteros de la siguiente manera:\n\n5\\rightarrow \\ket{0}\\otimes \\ket{1}\\otimes \\ket{0}\\otimes \\ket{1} = \\ket{0101}\n7\\rightarrow \\ket{0}\\otimes \\ket{1}\\otimes \\ket{1}\\otimes \\ket{1} = \\ket{0111}\n\nDe forma general:x=\\sum_{k=0}^{n-1}x_{k}2^k\nSe puede observar que la frecuencia en la que cambian los estados es distinta, por ejemplo, si recorremos los valores del 0 al 15. Vemos que el qubit menos significativo cambia cada vez que incrementemos en 1 en valor, el siguiente cambia cada dos incrementos, el siguiente cada 4 y el más significativo cada 8. De forma general, el dígito n cambia cada 2^n incrementos."},"Bases":{"slug":"Bases","filePath":"Bases.md","title":"Bases","links":["combinación-lineal","independencia-lineal"],"tags":[],"content":"Bases\nDefinición\n\n\nPara cada v ∈ V se puede representar como combinación linealde los vectores de β.\nβ es linealmente independiente. independencia lineal\n\nGenerador\n\\\nNote que en la definición de base es equivalente a afirmar que gen (β) = V."},"Bloqueo-de-Rydberg":{"slug":"Bloqueo-de-Rydberg","filePath":"Bloqueo de Rydberg.md","title":"Bloqueo de Rydberg","links":["átomos-de-Rydberg"],"tags":[],"content":"Bloqueo de Rydberg\nPara hacer una puerta cuántica de dos qubits necesitamos hacer que estos dos interactúen entre ellos. Las interacciones entre átomos neutros son más débiles, lo que dificulta su interconexión. Aunque las interacciones dipolares entre átomos en estados excitado pueden ser hasta tres veces mayores que en su estado fundamental.\nEn el caso de que un estado excitado tenga un número principal muy alto (átomos de Rydberg), puede darse el bloque de Rydberg, en la que la interacción dipolar de dos átomos lo suficientemente próximos puede impedir que un átomo pase a su estado excitado si el otro ya se encuentra en él, porque la energía necesaria sería mucho mayor que si se tratara de átomos aislados.\n\nDe una manera intuitiva, tenemos dos átomos los suficientemente cerca, si uno de ellos pasa a un estado de Rydberg (electrón muy alejado del núcleo) va a provocar que para el otro átomo se más difícil alcanzar un estado de Rydberg, como se ve en la foto debido a interacciones dipolares."},"Cambio-de-base":{"slug":"Cambio-de-base","filePath":"Cambio de base.md","title":"Cambio de base","links":[],"tags":[],"content":"Cambio de base\nTenemos dos observables A y B incompatibles, es decir, que no conmutan. Los autovectores del observable A forman la base {ai} y los del observable B la base {bi}. El espacio de estados del sistema se puede hacer con cualquiera de las dos bases, y es posible de pasar de una base a otra.\nLo primero que hay que comprobar es que los conjuntos de autovectores de ambos operadores forman una base. Deben cumplir estas dos condiciones:\n1. Completitud\n![[Pasted image 20240217182546.png]]\n\n2. Ortogonalidad\n![[Pasted image 20240217182641.png]]\n\nOperador cambio de base\nPor lo tanto tenemos dos bases {ai} y {bi}, por definición completas y ortogonales, existe un operador de cambio de base U que permite:\n\n"},"Canal-de-comunicación-cuántico":{"slug":"Canal-de-comunicación-cuántico","filePath":"Canal de comunicación cuántico.md","title":"Canal de comunicación cuántico","links":["limite-de-Holevo"],"tags":[],"content":"Canal de comunicación cuántico\nCanal para transmitir información cuántica\nCaracterización canal cuántico\n\nFidelidad de un canal cuántico\n\nInformación accesible\nPara saber la máxima información accesible en dos sistemas de distribución, usamos el limite de Holevo\nCapacidad de un canal cuántico con ruido\n"},"Canales-de-comunicación":{"slug":"Canales-de-comunicación","filePath":"Canales de comunicación.md","title":"Canales de comunicación","links":[],"tags":[],"content":"Canales de comunicación y capacidad de compresión\n\nMedida de sorpresa\nSea X una variable aleatoria con la distribución que hemos utilizado antes, una medida de sorpresa del símbolo X es:\n\nLa medida de sorpresa tiene la propiedad deseable de que es mayor para los sucesos de menor probabilidad y menor para los eventos de mayor probabilidad.\nEs aditiva, si una fuente de información emite los símbolos x1 y x2 ⇒ i(x1,x2) = i(x1) + i(x2)\nEntropia de fuente de información\n\nRatio de compresión\n\nEs igual a la entropía 𝐻(𝑋) dado que el número de bits transmitidos por el canal es igual a 𝑛𝐻(𝑋). El ratio de compresión que indicamos es el considerado como óptimo, si bien se pueden conseguir ratios de compresión superior. Calificarlo de óptimo significa, en el fondo, minimizar la probabilidad de pérdida de información."},"Candidatos-a-qubits":{"slug":"Candidatos-a-qubits","filePath":"Candidatos a qubits.md","title":"Candidatos a qubits","links":[],"tags":[],"content":""},"Capacidad-del-canal":{"slug":"Capacidad-del-canal","filePath":"Capacidad del canal.md","title":"Capacidad del canal","links":[],"tags":[],"content":"Capacidad del canal\nVeremos la transmisión de información a través de un canal con ruido.\nCanales con ruido\n\n\nInformación mutua\n\n\nRepresentación gráfica información mutua\n\nPropiedades información mutua\n\nCodificación canales con ruido (segundo teorema de Shannon)\n"},"Caracterización-y-escalabilidad":{"slug":"Caracterización-y-escalabilidad","filePath":"Caracterización y escalabilidad.md","title":"Caracterización y escalabilidad","links":[],"tags":[],"content":"Caracterización y escalabilidad\nCaracterización\nPara definir un qubit asociamos dos estados físicos a la base computacional \\{\\ket{0}, \\ket{1}\\}. El estado general de qubit será la superposición de ambos : \\ket{\\Psi} = \\alpha \\ket{0}+\\beta \\ket{1}\nPara que esto sea posible, los estados físicos deben estar bien caracterizado, por ejemplo, debemos conocer su Hamiltoniano interno ya que determina le energía de sus estados.\nSi el sistema tiene más de dos niveles, es necesario conocer también las interacciones y ligaduras de los estados elegidos con el resto de estados, ademas de que la probabilidad de que el sistema evolucione a alguno de los estados no elegidos sea nula.\nConocer la interacciones del sistemas y sus estados con los campos externos, ya sea para manipular el qubit de manera voluntaria o conocer la influencia negativa.\nEscalabilidad\nDebemos ser capaces de crear una colección de qubits bien caracterizados individualmente que sigan comportándose como tal al hacer crecer el sistema.\nDe esta manera el estado generar de dos qubits tendría la forma:\n\\ket{\\Psi} = a \\ket{00}+ b\\ket{01} +c\\ket{10} + d\\ket{11}    \nLa condición de entrelazamiento implica que estos qubits no pueden ser descritos como dos qubits individuales. Hacer crecer el sistema n qubits, resultaria en un vector de 2ndimensiones"},"Carga-e-inicialización-registro-átomos-neutros":{"slug":"Carga-e-inicialización-registro-átomos-neutros","filePath":"Carga e inicialización registro átomos neutros.md","title":"Carga e inicialización registro átomos neutros","links":["Trampas-de-átomos","átomos-de-Rydberg"],"tags":[],"content":"Carga e inicialización registro átomos neutros\nUna vez tenemos la Trampas de átomos, debemos cargarla con átomo neutros e inicializarlos para poder operar con ellos como qubits. Para ello, se hace pasar un gas por la trampa y parte de sus átomos serán atrapados en el potencial óptico.\nAl observar la fluorescencia de los átomos es posible saber que partes de la trampa se han ocupado con átomos y cuales han quedado vacías.\nMediante esta técnica, la probabilidad de que un punto de la trampa esté ocupada por un átomo es del 50% aprox. Por esto, es necesario definir un subconjunto de punto como el registro cuántico que vamos a utilizar. Para esto, cambiamos parámetros de la trampa así podemos desplazar los átomos a esta zona de interés:\n\nSistema a dos niveles\nLos átomos así cargados estarán en su estado fundamental o decaerán rápidamente a este. Para las operaciones cuánticas podemos utilizar:\n\nDos estados electrónicos del átomo \\rightarrow Accedemos a ellos mediante transiciones ópticas.\nEstados del espín de la estructura hiperfina \\rightarrow Accedemos a ellos mediante pulsos de microondas.\n\nReutilización de los registros\nEn los ordenadores de átomos atrapados, a diferencia de otras tecnologías, los registros no pueden ser reutilizados, cada vez que se inicializa un registro se carga con átomos nuevos.\nLa ventaja de esto es que podemos realizar el mismo algoritmo en la misma trampa varias veces, pero cada vez con átomos nuevos. Lo que permite garantizar la ausencia de ciertos errores relacionados con la implementación física del qubit.\nÁtomos de Rydberg\nEn muchos ordenadores cuánticos se utilizan átomos de Rydberg. Debido a su momento dipolar relativamente grande, su respuesta a campos eléctricos y magnéticos es exagerada. Lo que facilita su integración en las trampas ópticas."},"Cifrado-y-seguridad-cuántica":{"slug":"Cifrado-y-seguridad-cuántica","filePath":"Cifrado y seguridad cuántica.md","title":"Cifrado y seguridad cuántica","links":["Distribución-de-clave-cuántica","Criptografía-cuántica"],"tags":[],"content":"Cifrado y seguridad cuántica\nIndice\nDistribución de clave cuántica\nCriptografía cuántica"},"Codificación-y-corrección-de-errores-clásicos":{"slug":"Codificación-y-corrección-de-errores-clásicos","filePath":"Codificación y corrección de errores clásicos.md","title":"Codificación y corrección de errores clásicos","links":["tags/Tema","Códigos-lineales","Códigos-polinomiales","Códigos-convolucionales"],"tags":["Tema"],"content":"Codificación y corrección de errores clásicos Tema\nIndice\nCódigos lineales\nTransclude of Códigos-lineales#tipos-de-códigos\nCódigos polinomiales\nCódigos cíclicos\nCódigos Reed-Solomon\nCódigos convolucionales"},"Complejidad-asintótica":{"slug":"Complejidad-asintótica","filePath":"Complejidad asintótica.md","title":"Complejidad asintótica","links":[],"tags":[],"content":"Complejidad asintótica\nDado que el tiempo de ejecución exacto de un algoritmo es una expresión compleja por lo general, lo que vamos a hacer es aproximarlo con un método de análisis asintótico.\nEl análisis asintótico busca busca obtener un orden de magnitud de tiempo de ejecución de un algoritmo cuando este se ejecuta con entradas de gran tamaño. Para ello, consideramos solo el término de orden más alto de la expresión sin tener el cuenta el coeficiente del termino. Para entradas de gran tamaño el termino de orden superior domina sobre el resto de términos.\nDefinición\nSean f y g dos funciones tales que f,g:\\mathbb{N}\\to \\mathbb{R^{+}} . Decimos que f(n) = O(g(n)) si existen dos números enteros positivos c y n_{0} tales que para cada número entero n\\geq n_{0} entonces f(n\\leq c \\cdot g(n))\nCuando f(n) = O(g(n)) decimos que g(n) es un límite asintótico superior para f(n).\nEjemplos\nEjemplo 1\nConsideramos la función f(n) =7n^4+4n^3+n^2+10n+36.\nVemos que el termino de mayor orden es 7n^4, si despreciamos el coeficiente, decimos que f es asintótica como máximo en n^4. En notación asintóticas decimos f_{n} = O(n^4)\nEjemplo 2\nConsideramos la función f(n)= 3n^3+n^2+5n+6. Calcula el límite asintótico superior para f(n) y comprobar el resultado con la definición.\nVemos que f(n) = O(n^3). Para comprobar el resultado consideramos c=4 y n_{0}=20.\nVemos que 3n^3+n^2+5n+6 \\leq 4n^3 para todo n\\geq 20.\nEjemplo 3 - Logaritmos\nLos logaritmos son un caso interesante en notación asintótica. Cuando usamos logaritmos, debemos expresar la base, en realidad lo que estamos diciendo es:x=\\log_{2}n \\equiv 2^x = n\nAl cambiar la base de un logaritmo, lo que estamos haciendo es cambiar el valor de ese logaritmo por un factor constante. De ahí podemos escribir:\\log_{b}n = \\frac{\\log_{2}n}{\\log_{2}b}\nPor lo tanto, cuando escribimos f(n)=O(\\log n), en realidad no necesitamos expresar la base del logaritmo, dado que no estamos considerando factores que no sean contantes."},"Complejidad-computacional":{"slug":"Complejidad-computacional","filePath":"Complejidad computacional.md","title":"Complejidad computacional","links":["La-máquina-de-Turing","Complejidad-en-función-del-tamaño-de-las-entradas","Complejidad-asintótica"],"tags":[],"content":"Complejidad computacional\nLa complejidad computacional se centra en los recursos que se necesitan para resolver una tarea dada. Podemos distinguir dos usos:\n\nReferido al Algoritmo para resolver instancias de un problema. La complejidad computacional de un algoritmo es una medida de cuantos pasos requerirá el algoritmo (en el peor de los casos) para una instancia de un tamaño dado.\nReferido al Problema en sí. Clasificar los problemas de acuerdo a su con su trazabilidad o intratabilidad  inherente (si son fáciles de resolver o no).\n\nMedir la complejidad computacional\nSea M una La máquina de Turing determinista que se para en todas sus entradas, el tiempo de ejecución o complejidad de tiempo de M es la función f:\\mathbb{N} \\to \\mathbb{N},\n\nSi f(n) es el número máximo de pasos que M usa en cada entrada de longitud n.\nSi f(n) es el tiempo de ejecución de M, decimos que M ejecuta en tiempo f(n).\n\nTécnicas para medir complejidad computacional\n\nComplejidad en función del tamaño de las entradas\nComplejidad asintótica\n"},"Complejidad-en-función-del-tamaño-de-las-entradas":{"slug":"Complejidad-en-función-del-tamaño-de-las-entradas","filePath":"Complejidad en función del tamaño de las entradas.md","title":"Complejidad en función del tamaño de las entradas","links":[],"tags":[],"content":"Complejidad en función del tamaño de las entradas\nPara decir que un algoritmo funciona mejor que otro, necesitamos cuantificar los recursos necesarios para computar.\n\nTiempo\nMemoria (Espacio)\nEntradas/salidas\nOtros: circuitos, energía, etc…\n\nEl tiempo no puede ser simplemente ciclos de reloj de CPU. Para poder estudiar los algoritmos necesitamos contar con una referencia objetiva. Podemos definir el tiempo como ==“Número de operaciones como función del tamaño de la entrada de un algoritmo”==. Tenemos que caracterizar caracterizar el tamaño de entrada que llamaremos n. En función de la naturaleza del algoritmo, n será:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipo de algortimoTamaño de entradaClasificaciónNúmero de elementos a clasificarGrafosNúmero de vertices y aristasNuméricosNúmero de bits necesarios para representar un número\nOrdenes de crecimiento\nEs interesante conocer el rendimiento de un algoritmo cuando el tamaño de entrada tiende a infinito. Ya que para entradas pequeñas la mayoría de algoritmos funcionan bien.\nIntratabilidad\nLos problema que solo podemos resolver con algoritmos de tiempo exponencial o superexponencial se consideran intratables. Significa que para tamaños de entrada grandes no pueden ejecutarse de manera eficiente, necesitan millones de años. Para resolver este tipo de problemas podemos optar por algoritmos de aproximación o randomización.\nPor otro lado, los algoritmos tratables son aquellos que podemos resolver de forma eficiente, es decir, algoritmos con tiempo de ejecución polinomial."},"Componentes-de-la-máquina-de-Turing":{"slug":"Componentes-de-la-máquina-de-Turing","filePath":"Componentes de la máquina de Turing.md","title":"Componentes de la máquina de Turing","links":[],"tags":[],"content":"Componentes de la máquina de Turing\nLos componentes de una máquina de Turing son:\n\nControlador de estados finitos.\nUna cinta infinita dividida en celdas, cada celda contiene un símbolo.\nUn cabezal de lectura/escritura que:\n\nEsta posicionado en una celda específica\nPuede leer un símbolo de esa celda y suministrarlo al controlador como entrada.\nPuede aceptar un símbolo del controlador y lo inserta en esa celda.\nPuede aceptar una instrucción del controlador para mover la celda a la derecha o izquierda de la posición actual.\n\n\n\nEl movimiento de una maquina de Turing depende de el estado actual del controlador y el símbolo debajo del cabezal de lectura/escritura\nEn respuesta a las entradas, la maquina de Turing puede:\n\nCambiar el estado del controlador.\nEscribir un símbolo en la celda actual de la cinta (reemplazando lo que había).\nMover el cabeza a izquierda o derecha.\nDejar el estado sin cambios\n"},"Computación-cuántica-con-fotones":{"slug":"Computación-cuántica-con-fotones","filePath":"Computación cuántica con fotones.md","title":"Computación cuántica con fotones","links":["tags/Tema","Modos-fotónicos-como-qubits","Elementos-de-óptica-cuántica-lineal","Puertas-de-cuánticas-fotónicas-un-qubit","Puertas-de-cuánticas-fotónicas-dos-qubit","Fuentes-de-fotones-individuales","Detectores-de-fotones-individuales"],"tags":["Tema"],"content":"Computación cuántica con fotones\nTema\nEn este tema trataremos las ventajas y desventajas de los elementos ópticos lineales en la computación cuántica.\n\nPara poder tener un qubit lo primero que necesitamos es una base computacional: Modos fotónicos como qubits\nHablaremos también de los Elementos de óptica cuántica lineal.\nPuertas de cuánticas fotónicas un qubit y Puertas de cuánticas fotónicas dos qubit\nPor último hablaremos de las Fuentes de fotones individuales y Detectores de fotones individuales\n\n"},"Computación-cuántica":{"slug":"Computación-cuántica","filePath":"Computación cuántica.md","title":"Computación cuántica","links":["tags/Asignatura","Qubit","Espacio-de-estados-Qubit","Espacio-de-estados-n-Qubits","Medición-qubits-Proyección","Algoritmos-cuánticos-básicos","Algoritmos-cuánticos-avanzados"],"tags":["Asignatura"],"content":"Computación cuántica Asignatura\nQubit\nEspacio de estados Qubit\nEspacio de estados n Qubits\nMedición qubits-Proyección\nAlgoritmos cuánticos básicos\nAlgoritmos cuánticos avanzados"},"Confinamiento-cuántico":{"slug":"Confinamiento-cuántico","filePath":"Confinamiento cuántico.md","title":"Confinamiento cuántico","links":["Energía-de-Fermi","Energía-cinética-electrones-libres","Estado-excitado","Estado-fundamental"],"tags":[],"content":"Confinamiento cuántico\nEn un material conductor, los portadores de carga son libres de moverse en 3 dimensiones del espacio y sus propiedades se pueden aproximar con modelos de electrones libres.\nDensidad de estados\nEsta densidad de estados representa el número de estados electrónicos disponibles por unidad de volumen. Los podemos calcular de la siguiente manera\nPara los metales utilizamos al Energía de Fermi como la energía cinética del estado ocupado de mayor energía a 0K. También necesitamos calcular la Energía cinética electrones libres. A partir de estas dos energías, podemos calcular la densidad de estados de un gas de electrones libres a una energía dada de esta forma:\ng(E)_{3D} = \\frac{m_{e}}{\\pi^2\\hbar^3}\\sqrt{ 2m_{e}E} = \\frac{3n}{2E_{F}}\\sqrt{ \\frac{E}{E_{F}} }\nSiendo E_{F} la Energía de Fermi y E la Energía cinética electrones libres. También podemos expresar esta densidad de estados en función del fondo de la banda de conducción, E_{c}, de un semiconductor:\ng(E)_{3D} = \\frac{m_{e}}{\\pi^2\\hbar^3}\\sqrt{ 2m_{e}(E-E_{c}) }\nEn los materiales de 3 dimensiones, con tamaños mucho mayores a la longitud de onda de los electrones, la relación entre densidad de estados y energía presenta relación cuadrática.\nPozo cuántico\nSi reducimos las dimensiones espaciales del material a tamaños comparables a longitudes de onda del electrón, los portadores de carga pierden un grado de libertad al no poder escapar del material en esa dirección. Esto implica que los niveles de energía están cuantizados en la dirección de la dimensión reducida, pero conservan su libertad de movimiento en el plano perpendicular.\nEsta estructura es el pozo cuántico, y su densidad de estados no depende la energía:\ng(E)_{2D}= \\frac{m}{\\pi \\hbar^2}\nHilo cuántico\nSi en vez de reducir una dimensión, reducimos dos de ellas, los portadores estarán forzados a moverse en una estructura unidimensional, lo que llamamos hilo cuántico, y su densidad de estados viene dada por:\ng(E)_{1D}= \\frac{1}{\\pi \\hbar }\\sqrt{ \\frac{m}{2(E-E_{c})} }\nPunto cuántico\nSi reducimos otra dimensión más, los electrones no tiene ningun grado de libertad de movimiento, y su energía queda totalmente cuantizada a los niveles discreto dados por su geometría. Esta estructura es el punto cuántico, y su densidad de estados viene dada por:\ng(E)_{0D} = 2\\delta (E-E_{c})\nDe esta manera como los electrones se encuentran confinados en un lugar del espacio presentan un espectro de energía discreto, muy similares a los espectros de un átomo, por lo que a veces se les llama “átomos artificiales”. Como podemos localizar los electrones en una región muy pequeña y sus energías están limitadas a a una cantidad de estados discretos. de esta manera, las transiciones entre estados seguirán dinámicas similares a los átomos: absorber energía electromagnética para promocionarse a Estado excitado, emitir energía y decaer al Estado fundamental, lo que nos permite manipular sus estados electrónicos.\n"},"Conjugado":{"slug":"Conjugado","filePath":"Conjugado.md","title":"Conjugado","links":[],"tags":[],"content":"Conjugado\n\nPropiedades conjugado\n"},"Conjunto-de-puertas-cuánticas-universales":{"slug":"Conjunto-de-puertas-cuánticas-universales","filePath":"Conjunto de puertas cuánticas universales.md","title":"Conjunto de puertas cuánticas universales","links":[],"tags":[],"content":"Conjunto de puertas cuánticas universales\nPara poder ejecutar algoritmos con qubits debemos ser capaces de actuar sobre ellos y guiar su evolución para resolver un problema concreto. Las puertas cuánticas, por analogía a las puertas lógicas, son un conjunto de impulsos físicos que modifican el estado del qubit.\nDe esta manera, un procesador cuántico es una concatenación de impulsos físicos, espaciados entre sí por tiempo más cortos que el tiempo de decoherencia característico del qubit.\nLas operaciones pueden reducirse a una serie de rotación sobre un qubit y entre pares de qubits como la puerta CNOT."},"Conmutación-momento-angular":{"slug":"Conmutación-momento-angular","filePath":"Conmutación momento angular.md","title":"Conmutación momento angular","links":["conmutador"],"tags":[],"content":"Conmutación momento angular\nPodemos definir las relaciones de conmutador del momento angular.\nConmutación momento angular con posición\n\nConmutación momento angular con momento angular ^2. [L,L^{2}]\n\nConmutación entre componentes del momento angular\nConmutación entre momento angular y momento lineal"},"Cota-al-error-en-la-estimación-EVA":{"slug":"Cota-al-error-en-la-estimación-EVA","filePath":"Cota al error en la estimación EVA.md","title":"Cota al error en la estimación EVA","links":["EVA","Modelo-Ising"],"tags":[],"content":"Cota al error en la estimación EVA\nTrataremos calcular la cota de del error en la estimación del algoritmo EVA, la cual se puede aproximar por \\frac{{\\left\\|H\\right\\|^3}}{3!k^3} como vamos a demostrar a continuación:\nEmpezamos con dos suposiciones del Hamiltoniano:\n\nLa norma de H es menor de 1,  es decir \\left\\|H\\right\\|:=max_{\\phi}|\\braket{ \\phi}H\\ket{\\phi}\\leq 1\nH es un Hamiltoniano tipo Ising Definir función objetivo con Hamiltoniano.\n\nPartiremos de la expansión de la parte imaginaria de e^{{iH}/{k}}  :\n\\Im\\braket{ \\phi}e^{{iH}/{k}}\\ket{\\phi} = \\frac{\\bra{\\phi}H\\ket{\\phi}}{k}- \\frac{\\bra{\\phi}H^3\\ket{\\phi}}{3!k^3} +\\dots   \nDespejamos la ecuación:\n| \\Im\\braket{ \\phi}e^{{iH}/{k}}\\ket{\\phi} - \\frac{\\bra{\\phi}H\\ket{\\phi}}{k} |  = |\\frac{\\braket{ \\phi}H^3\\ket{\\phi}}{3!k^3} - \\frac{\\bra{\\phi}H^5\\ket{\\phi}}{5!k^5} +\\dots |  \nComo H es un Hamiltoniano tipo Ising, tendrá una forma diagonal, por lo que podemos garantizar: \\bra{\\phi}H^m \\ket{\\phi} = \\bra{\\phi}H\\ket{\\phi}^m\nPor lo tanto, podemos expresar la parte derecha de la ecuación anterior como una serie de potencias y obtener:\n|\\frac{\\braket{ \\phi}H^3\\ket{\\phi}}{3!k^3} - \\frac{\\bra{\\phi}H^5\\ket{\\phi}}{5!k^5} +\\dots | \\leq |\\frac{\\bra{\\phi}H\\ket{\\phi}}{k} - \\sin\\frac{\\bra{\\phi}H\\ket{\\phi}}{k} |\nComo la función f(x) = x-\\sin x para x \\in(0,1) es siempre creciente y positiva, podemos acotar la expresión anterior por la norma:\n|\\frac{\\bra{\\phi}H\\ket{\\phi}}{k} - \\sin\\frac{\\bra{\\phi}H\\ket{\\phi}}{k} | \\leq\\frac{{\\left\\|H\\right\\|}}{k}- \\sin\\frac{{\\left\\|H\\right\\|}}{k} \nHaciendo el desarrollo en serie de Taylor del seno:\n|\\frac{\\braket{ \\phi}H^3\\ket{\\phi}}{3!k^3} - \\frac{\\bra{\\phi}H^5\\ket{\\phi}}{5!k^5} +\\dots | \\leq \\frac{{\\left\\|H\\right\\|^3}}{3!k^3} - \\frac{{\\left\\|H\\right\\|^5}}{5!k^5} + \\dots\nSi nos damos cuenta podemos comprobar:\n\\frac{{\\left\\|H\\right\\|^5}}{5!k^5}- \\frac{{\\left\\|H\\right\\|^7}}{7!k^7}+\\dots \\geq 0\nEsto es fácil de comprobar cogiendo los términos de la sucesión dos a dos y dándose cuenta de que la suma es siempre positiva. De esta manera, podemos suponer como cota \\frac{{\\left\\|H\\right\\|^3}}{3!k^3} al valor buscado, llegando a que:\n\\mid \\Im \\bra{\\phi}e^{iH/k}\\ket{\\phi}-\\frac{\\bra{\\phi}H\\ket{\\phi}}{k}     |\\leq\\frac{{\\left\\|H\\right\\|^3}}{3!k^3}\nModulando k podemos hacer el error tan pequeño como queramos."},"Código-Reed-Muller":{"slug":"Código-Reed-Muller","filePath":"Código Reed-Muller.md","title":"Código Reed-Muller","links":[],"tags":[],"content":"Código Reed-Muller"},"Código-de-Hamming":{"slug":"Código-de-Hamming","filePath":"Código de Hamming.md","title":"Código de Hamming","links":[],"tags":[],"content":"Código de Hamming\nLa clave de todos sus sistemas es intercalar entre los bits de datos los de paridad.\nDistancia de Hamming: Numero de bits que hay que cambiar en una cadena para obtener otra.\nEjemplo\n\nHamming (7,4)\nEn teoría de códigos, Hamming (7,4) es el nombre de un código lineal de corrección de errores que codifica cuatro bits de datos en siete bits agregando tres bits de paridad."},"Códigos-convolucionales":{"slug":"Códigos-convolucionales","filePath":"Códigos convolucionales.md","title":"Códigos convolucionales","links":[],"tags":[],"content":"Códigos convolucionales\nLas palabras de un código convolucional se generan no solo a partir de los dígitos de información actuales, sino también con la información anterior en el tiempo. Es decir, un codificador convolucional es un sistema con memoria y, en consecuencia, sus 𝑛𝑛 salidas en cualquier unidad de tiempo dada no dependen únicamente de sus 𝑘𝑘\n"},"Códigos-lineales":{"slug":"Códigos-lineales","filePath":"Códigos lineales.md","title":"Códigos lineales","links":["Código-de-Hamming","Código-Reed-Muller"],"tags":[],"content":"Códigos lineales\nUn código lineal es un código de corrección de errores para los que cualquier combinación lineal de palabras de código es también una palabra de código. Los códigos lineales se utilizan en la corrección de errores hacia adelante (los códigos de corrección hacia adelante son aquellos que permiten la corrección del mensaje en el receptor sin necesitar que el emisor vuelva a transmitir el mensaje)\nTipos de códigos\nCódigo de Hamming\nCódigo Reed-Muller"},"Códigos-polinomiales":{"slug":"Códigos-polinomiales","filePath":"Códigos polinomiales.md","title":"Códigos polinomiales","links":[],"tags":[],"content":"Códigos polinomiales\nTipos de código\nCódigos cíclicos\nEstos códigos utilizan la aritmética modular para detectar una mayor cantidad de errores, se usan operaciones en módulo 2.\nLa finalidad de este método es crear una parte de redundancia que se añade al final del código a transmitir (como en los métodos de paridad) y que, siendo la más pequeña posible, detecte el mayor número de errores posible. En ejemplo es el código de redundancia cíclica.\nCódigo Reed-Solomon\nEste tipo de códigos se denominan códigos de borrado y se utilizan, por ejemplo, en\nsalvaguardar los datos disponibles en unidades de almacenamiento como discos."},"Criptografía-cuántica":{"slug":"Criptografía-cuántica","filePath":"Criptografía cuántica.md","title":"Criptografía cuántica","links":[],"tags":[],"content":"Criptografía cuántica\nAlgoritmo de Shor\n\nAlgoritmo de Grover\n"},"Criterios-de-DiVicenzo":{"slug":"Criterios-de-DiVicenzo","filePath":"Criterios de DiVicenzo.md","title":"Criterios de DiVicenzo","links":["Caracterización-y-escalabilidad","Inicialización-a-un-estado-fundamental","Tiempo-de-decoherencia","Conjunto-de-puertas-cuánticas-universales","Medida-del-estado-final"],"tags":[],"content":"Criterios de DiVicenzo\nDavid P. DiVicenzo propuso una serie de criterios que debería cumplir un ordenador cuántico:\n\nCaracterización y escalabilidad\nInicialización a un estado fundamental\nTiempo de decoherencia\nConjunto de puertas cuánticas universales\nMedida del estado final\n"},"Cálculo-Lambda":{"slug":"Cálculo-Lambda","filePath":"Cálculo Lambda.md","title":"Cálculo Lambda","links":[],"tags":[],"content":"Cálculo Lambda\nEl cálculo lambda es un lenguaje de programación muy sencillo. Consta de una única regla de transformación(transformación de variables) y un esquema de definición de función única. El concepto centra de este cálculo consiste en construir términos lambda y realizar operaciones de reducción de ellos.\nSe basa en que sólo podemos hacer dos acciones: abstracción y aplicación:\n\nAbstraer: Definir una función. Por ejemplo, una función para doblar la variable x sería \\lambda x. 2 * x. \\lambda x\nAplicar: Usar la función en un valor específico. Si nuestra función es \\lambda x. 2*x y le damos el valor 3, tenemos (\\lambda x. 2*x)3 = 6.\n\nEn esencia manipulamos funciones como si fueran datos. Se pueden pasar funciones a otras funciones, crear funciones que devuelven nuevas funciones, etc…\nEjemplo\nUna función que suma dos números \\lambda x. \\lambda y. x+y. Primero abstraemos sobre x y luego sobre y. Si por ejemplo queremos calcular 2+3:\n\nAplicamos dos veces: ((\\lambda x. \\lambda y. x+y)2)3\nEsto se reduce a: (\\lambda y. 2+y)3\n2+3 = 5\n"},"Definición-formal-de-la-máquina-de-Turing":{"slug":"Definición-formal-de-la-máquina-de-Turing","filePath":"Definición formal de la máquina de Turing.md","title":"Definición formal de la máquina de Turing","links":[],"tags":[],"content":"Definición formal de la máquina de Turing\nPodemos definir una máquina Turing como una séptupla M =\\{Q,\\Sigma,T,\\delta,q_{0},B,F\\} , donde:\n\nQ es el conjunto de estados finitos.\n\\Sigma Conjunto finito de símbolos de entrada.\nT Conjunto de símbolos de cinta. Son los símbolos de entra más otros posibles símbolos adicionales que se pueden escribir en la cinta.\n\\delta Es la función de transición \\delta: Q \\times T \\rightarrow Q\\times T\\times D donde D es una dirección \\{L,R\\} Izquierda o derecha.\nq_{0} es el estado inicial del contador.\nB Símbolo especial para indicar espacios en blanco. Inicialmente la cinta debe tener estados en blanco excepto en un número finito de posiciones.\nF es el conjunto de Q que denota los estados finales o de aceptación del controlador.\n"},"Demostración-geométrica-algoritmo-de-Grover":{"slug":"Demostración-geométrica-algoritmo-de-Grover","filePath":"Demostración geométrica algoritmo de Grover.md","title":"Demostración geométrica algoritmo de Grover","links":[],"tags":[],"content":"Demostración geométrica algoritmo de Grover\nAunque la representación de los estados del problema se hace en un hiperplano (Espacio de Hilbert de dimensión N). Lo podemos transfirmar en un plano 2D generado por los 2 estados que nos interesan:\n\\begin{cases}\n\\ket{w} \\to \\text{Estado objetivo} \\\\\n\\ket{s} \\to \\text{Estado de superposición uniforme}  \n\\end{cases}\n\\end{equation}$$\n\nPuesto que $\\ket{w} \\in \\ket{s}$ no van a ser ortogonales, por lo que vamos a considerar el estado $\\ket{s&#039;}$ que si es es ortogonal a $\\ket{w}$, es decir, $\\braket{w|s&#039;}=0$.\n\nEl estado $\\ket{s&#039;}$ no es otra cosa que eliminar el estado objetivo $\\ket{w}$ de la superposición $\\ket{s}$. Con esto 3 elementos vamos a representar $\\ket{s}$ en el plano ortonormal que forman $\\ket{w}$ y $\\ket{s&#039;}$:\n\n![[Pasted image 20250217195335.png|300]]\n\nSiendo $\\ket{s} = \\sin \\theta \\ket{w}+\\cos \\theta \\ket{s&#039;}$, siendo $\\sin \\theta=\\frac{1}{\\sqrt{ N }}$.\n\n\nAplicando el oráculo $U_{w}= I-2\\ket{w}\\bra{w}$ como hemos dicho en [[Algoritmo de Grover]], esto corresponde a una reflexión sobre el hiperplano ortogonal a $\\ket{w}$, es decir, una reflexión sobre $\\ket{s&#039;}$.\n\n$$\\begin{align}\nU_{w}\\ket{s} &amp;= U_{w}(\\sin \\theta \\ket{w} +\\cos \\theta \\ket{s&#039;} ) =  \\\\\nU_{w}\\ket{s} &amp;= -\\sin \\theta \\ket{w} + \\cos \\theta \\ket{s&#039;}    \n\\end{align}$$\nEn el plano:\n\n![[Pasted image 20250217195718.png|300]]\n\n\nAhora vamos a aplicar el operador de difusión $U_{D} = 2\\ket{s}\\bra{s}-I$ sobre $U_{w}\\ket{s}$.\n\nEste operador lo que hace es una reflexión sobre el estado $\\ket{s}$. Lo que hace es rotar $2\\theta$ sobre el vector que representa $\\ket{s}$, amplificando así la amplitud de $\\ket{w}$. Es decir:\n$$\\begin{align}\nU_{D}U_{w}\\ket{s} &amp;= U_{D}(-\\sin \\theta \\ket{w}+\\cos \\theta \\ket{s&#039;}  )= \\\\\\\\\n&amp;=\\sin(3\\cdot \\theta)\\ket{w} + \\cos(3\\cdot \\theta)\\ket{s&#039;}   \n\\end{align}$$\n![[Pasted image 20250217200217.png|300]]\n\nVemos gráficamente que aumentamos la amplitud de probabilidad de $\\ket{w}$. Si seguimos aplicando $U_{w}$ y $U_{D}$ consecutivamente aumentaremos aún más la probabilidad de $\\ket{w}$. Pero si nos pasamos del número de veces que aplicamos estos dos operadores, $U_{D}U_{w}\\ket{s}$, &quot;dará la vuelta&quot;y la amplitud de probabilidad de $\\ket{w}$ disminuirá.\n\n\nEl número optimo de aplicaciones de estos dos operadores es: $||\\frac{{\\pi}}{4}\\sqrt{ N }||$ veces."},"Demostración-matemática-del-algoritmo-de-Grover":{"slug":"Demostración-matemática-del-algoritmo-de-Grover","filePath":"Demostración matemática del algoritmo de Grover.md","title":"Demostración matemática del algoritmo de Grover","links":["Algoritmo-de-Grover"],"tags":[],"content":"Demostración matemática del algoritmo de Grover\nPartimos del Algoritmo de Grover:\n\nInicialización\nEmpezamos en el estado \\ket{\\psi_{0}} = \\ket{0^{\\otimes n}}\nAplicamos puertas Hadamard\n\\ket{\\psi_{1}}=H^{\\otimes n}\\ket{0^{\\otimes n}}= \\frac{1}{\\sqrt{ N }}\\sum_{x \\in\\{0,1\\}^{n}}\\ket{x}=\\ket{s}\nSiendo N=2^n la dimensión del espacio de Hilbert donde representamos los n qubits.\nAplicamos el oráculo U_{D}\nComo hemos demostrado, U_{D}=I-2\\ket{w}\\bra{w}, siendo \\ket{w} el estado buscado.\n\\ket{\\psi_{2}}&amp;=U_{w}\\ket{\\psi_{1}} = (I-2\\ket{w}\\bra{w})\\ket{s}    \\\\\n&amp;=\\ket{s}-2\\ket{w}\\braket{w|s}   \n\\end{align}$$\nSeparamos $\\ket{s}$ entre $\\ket{w}$ y el resto de estados $\\ket{x} \\neq \\ket{w}$, es decir:\n$$\\ket{s}= \\frac{1}{\\sqrt{ N }}\\left( \\sum_{x \\neq w}\\ket{x} +\\ket{w}   \\right) $$\nVolviendo a nuestra ecuación:\n$$\\begin{align}\n\\ket{\\psi_{2}} &amp;= \\ket{s}-\\frac{{2}}{\\sqrt{ N }}\\ket{w}\\bra{w}\\left( \\sum_{x \\neq w}\\ket{x} +\\ket{w}   \\right)\\\\ \\\\\n&amp;=\\ket{s}-\\frac{{2}}{\\sqrt{ N }}\\ket{w}\\left( \\sum_{x \\neq w}\\braket{w|x}   +\\braket{w|w}  \\right)\n\\end{align}$$\nComo $\\ket{x}$ es ortogonal a $\\ket{w} \\quad\\forall x \\neq w$, tenemos que $\\braket{w|x}=0$ y $\\braket{w|w}=1$. Por lo tanto:\n$$\\ket{\\psi_{2}} =\\ket{s}-\\frac{2}{\\sqrt{ N }}\\ket{w}  $$\n\n## Aplicamos operador de Difusión $U_{D}$\n\nEl operador de difusión es $U_{D}=2\\ket{s}\\bra{s}-I$. Volviendo a nuestro estado:\n$$\\begin{align}\n\\ket{\\psi_{3}}&amp;=U_{D}\\ket{\\psi_{2}} =  (2\\ket{s}\\bra{s}-I)\\left( \\ket{s}-\\frac{2}{\\sqrt{ N }}\\ket{w} \\right)\\\\ \\\\\n&amp;=2\\ket{s}\\braket{s|s} - \\frac{4}{\\sqrt{ N }}\\ket{s}\\braket{s|w} - \\ket{s} + \\frac{2}{\\sqrt{ N }}\\ket{w}  \\\\ \\\\\n&amp;=2\\ket{s} - \\ket{s}  -\\frac{4}{\\sqrt{ N }}\\ket{s}\\braket{s|w} + \\frac{2}{\\sqrt{ N }}\\ket{w}      \n\\end{align}$$\n\nComo antes, separamos $\\bra{s}$ entre sus componentes $\\bra{x} \\neq \\bra{w}$ y $\\bra{w}$ Tenemos:\n\n$$\\begin{align}\n\\ket{\\psi_{3}}&amp;=\\ket{s} - \\frac{4}{\\sqrt{ N }}\\ket{s} \\cdot \\frac{{1}}{\\sqrt{ N }}\\left( \\sum_{x \\neq w} \\bra{x}  + \\bra{w} \\right)\\ket{w}  +\\frac{2}{\\sqrt{ N }}\\ket{w}\\\\ \\\\\n&amp;= \\ket{s} - \\frac{4}{\\sqrt{ N }}\\cdot \\frac{{1}}{\\sqrt{ N }}\\ket{s} \\left( \\sum_{x \\neq w} \\braket{x|w} + \\braket{w|w}\\right) +\\frac{2}{\\sqrt{ N }}\\ket{w}\\\\ \\\\\n&amp;=\\ket{s}-\\frac{4}{N}\\ket{s}+  \\frac{2}{\\sqrt{ N }}\\ket{w}= \\frac{{N-4}}{N}\\ket{s}+\\frac{2}{\\sqrt{ N }}\\ket{w} \\\\ \\\\\n&amp;=\\frac{{N-4}}{N}\\cdot \\frac{1}{\\sqrt{ N }}\\left( \\sum_{x \\neq w} \\ket{x}   + \\ket{w}  \\right) + \\frac{2}{\\sqrt{ N }}\\ket{w}\\\\ \\\\\n&amp;=\\frac{{N-4}}{N\\sqrt{ N }} \\sum_{x \\neq w} \\ket{x} +\\left( \\frac{{N-4}}{N\\sqrt{ N }}+ \\frac{2}{\\sqrt{ N }} \\right)\\ket{w} \\\\ \\\\\n\\ket{\\psi_{3}} &amp;=  \\frac{{N-4}}{N\\sqrt{ N }} \\sum_{x \\neq w} \\ket{x} + \\frac{{3N-4}}{N\\sqrt{ N }}\\ket{w} \n\\end{align}$$\nDe forma más compacta nos queda:\n$$\\ket{\\psi_{3}} = \\frac{1}{N\\sqrt{ N }}\\left( \\sum_{x \\neq w}(N-4)\\ket{x} + (3N-4)\\ket{w}  \\right) $$\n\nVemos la amplitud de probabilidad del elemento encontrado $\\ket{w}$ se incrementa respecto a los demás. \n\nSi aplicamos $U_{w}$ y $U_{D}$ se va aumentado la probabilidad, aunque si nos pasamos empeorará porque es cíclico, esto lo entenderemos mejor en la [[Demostración geométrica algoritmo de Grover]]"},"Derivación-en-circuitos-cuánticos":{"slug":"Derivación-en-circuitos-cuánticos","filePath":"Derivación en circuitos cuánticos.md","title":"Derivación en circuitos cuánticos","links":["Introducción-redes-neuronales-clásicas","Shift-rule","Descenso-del-gradiente"],"tags":[],"content":"Derivación en circuitos cuánticos\nEn Introducción redes neuronales clásicas hemos visto el potencial que ofrece ser capaz de obtener la derivada de una función  a la hora de optimizar. El problema que tenemos es que no heos definido la derivada dentro de un circuito. La pregunta que nos debemos hace es como podemos modificar los parámetros de un circuito para minimizar la función. Dada la función g que depende de los parámetros \\vec{\\theta} y devuelve el valor esperado, estamos buscando un método que devuelva \\frac{{\\partial g(\\vec{\\theta})}}{\\vec{\\partial}\\theta}.\nPara conseguir esto existe un método conocido como Shift-rule. Gracias a esta regla, podemos optimizar nuestros circuitos cuánticos a través del Descenso del gradiente."},"Descenso-del-gradiente":{"slug":"Descenso-del-gradiente","filePath":"Descenso del gradiente.md","title":"Descenso del gradiente","links":[],"tags":[],"content":"Descenso del gradiente\nAlgoritmo de optimización que permite encontrar mínimos locales de funciones diferenciadles.\nLa idea básica detrás de este algoritmo consiste en que la derivada de \\vec{\\theta} en función de E evaluada en un punto \\vec{\\theta*}, nos da la dirección en la que la función decrece más rápido. De esta manera, el algoritmo empieza estableciendo un punto inicial, calcula la derivada en dicho punto, y se mueve en la dirección que más minimice la función una y otra vez hasta alcanzar el  mínimo de dicha función.\nEjemplo\nQueremos minimizar: f(x,y) = x^2+y^2 . Tomamos el punto inicial (x_{0}, y_{0}) = (-1,1), por lo tanto tenemos que:\n[\\frac{{\\partial f}}{\\partial x}, \\frac{{\\partial f}}{\\partial y}]_{(-1,1)} = (2x,2y)_{(-1,1)} = (-2,2)\nPor lo tanto la dirección en la que debemos nuestro vector será (-2,2). Ahora tenemos que decidir cuánto vamos a avanza en esa dirección, pero ello, introducimos un parámetro \\lambda al que llamaremos coeficiente de aprendizaje, que establece la longitud del paso. Si continuamos repitiendo estos pasos, conseguiremos encontrar el mínimo de la función."},"Desigualdades-de-Bell":{"slug":"Desigualdades-de-Bell","filePath":"Desigualdades de Bell.md","title":"Desigualdades de Bell","links":["Paradoja-EPR"],"tags":[],"content":"Desigualdades de Bell\nLas desigualdades de Bell son una forma matemática de poner a prueba la Paradoja EPR. Las suposiciones son:\n\nLos observables tiene realidad independientemente a si son medidos o no, es decir, existen variables ocultas.\nLa información no puede viajar mas rápido que la luz. Principio de localidad.\n\nSi las desigualdades de Bell son violadas, implica que al menos uno de los puntos de arriba, es falso. Demostrado experimentalmente por Aspect (1982)."},"Detectores-de-fotones-individuales":{"slug":"Detectores-de-fotones-individuales","filePath":"Detectores de fotones individuales.md","title":"Detectores de fotones individuales","links":["Fuentes-de-fotones-individuales"],"tags":[],"content":"Detectores de fotones individuales\nPara caracterizas las Fuentes de fotones individuales y realizar medidas necesitamos ser capaces de detectar un solo fotón. Deben tener la suficiente sensibilidad para convertir el evento de llegada de un fotón en un pulso de corriente.\nFotodetectores clásicos amplificados\nEn algunos casos se pueden utilizar fotodetectores normales que son amplificados hasta su punto de saturación. Los detectores de fotones individuales más modernos están diseñados específicamente para cumplir esta función. Podemos encontrar los tubos fotomultiplicadores y los fotodiodos de avalancha\nTubos fotomultiplicadores\nSon dispositivos basados en el efecto fotoeléctrico, consisten en una serie de electrodos en cascada en una ampolla de vacío con un fotocátodo expuesto al exterior. Cuando los fotones llegan al fotocátodo, arrancarán  electrones de este por efecto fotoeléctrico. Los electrones expulsados del electrodo son acelerados y conducidos al siguiente electrodo mediante diferencia de potencial.\nCada uno de estos electrones arranca por emisión secundaria un número variable de electrones que son conducidos al siguiente electrodo, serán conducidos al siguiente electrodo arrancando más electrones. Si se ponen varios electrodos en cascada, se consiguen ganancias de 16dB.\n\nFotodiodos de avalancha\nEn un diodo semiconductor, si se la aplica tensión en dirección inversa no se observará corriente porque este la bloquea, sin embargo, si la tensión inversa es muy elevada, cualquier electrón excitado térmicamente en el semiconductor será fuertemente acelerado por el campo eléctrico. Esto provoca que se liberan más electrones en el camino que también son acelerados lo que provoca un efecto cascada.\nEste fenómeno se llama ruptura por avalancha y suele suponer la destrucción del diodo por picos de corriente muy altos.\n\nEn la figura podemos ver como el impacto de un fotón en la región genera un par electrón-hueco que comienza la ruptura por avalancha.\n\nDiodos de avalancha: Son diodos diseñados para soportar mayores corrientes, lo que les permite trabajar en régimen de avalancha durante un tiempo.\nFotodiodos de avalancha: En estos diodos de avalancha los electrones que inician la avalancha son generados mediante la excitación por fotones.\n\nEl problema de estos sistemas es que después de cada evento tienen un tiempo muerto en el que no detectan nada.\nDetectores de nanohilos superconductores\nEsta tecnología emergente consiste en un hilo muy largo y fino que se hace funcionar a bajas temperaturas, cerca de su corriente crítica. La absorción de un fotón es suficiente para hacerle transitar localmente del estado superconductor al no superconductor, pasando de una resistencia nula a una finita. Este cambio brusco en la resistencia provoca un pulso eléctrico.\n\nLa llegada del fotón produce un calentamiento local del hilo lo que provoca el aumento de resistencia al perder las propiedades de superconductividad."},"Diagonalización":{"slug":"Diagonalización","filePath":"Diagonalización.md","title":"Diagonalización","links":[],"tags":[],"content":"Diagonalización\n"},"Diagramas-de-estados-de-la-máquina-de-Turing":{"slug":"Diagramas-de-estados-de-la-máquina-de-Turing","filePath":"Diagramas de estados de la máquina de Turing.md","title":"Diagramas de estados de la máquina de Turing","links":[],"tags":[],"content":"Diagramas de estados de la máquina de Turing\nLos elementos del diagrama de estados son:\n\nLos estados están unidos mediante lineas dirigidas, encima de cada línea se representa el símbolo que lee el cabezal, el símbolo que escribirá el cabezal y el movimiento del cabezal,\nEl estado inicial solo tiene líneas de salida.\nEl estado final solo tiene líneas de entrada.\n\n"},"Dimensión":{"slug":"Dimensión","filePath":"Dimensión.md","title":"Dimensión","links":[],"tags":[],"content":"Dimensión\n"},"Distancia":{"slug":"Distancia","filePath":"Distancia.md","title":"Distancia","links":["Espacios-Prehilbert","producto-interno"],"tags":[],"content":"Se V un Espacios Prehilbert con producto interno, definimos la distancia como:\n\nProposiciones\n\nDistancia para números complejos\n"},"Distribución-de-clave-cuántica":{"slug":"Distribución-de-clave-cuántica","filePath":"Distribución de clave cuántica.md","title":"Distribución de clave cuántica","links":["QKD.canvas"],"tags":[],"content":"Distribución de clave cuántica (QKD)\nTransclude of QKD.canvas\nTrabajo completo sobre QKD\n"},"Divisores-de-haz":{"slug":"Divisores-de-haz","filePath":"Divisores de haz.md","title":"Divisores de haz","links":[],"tags":[],"content":"Divisores de haz\nUn divisor de haz es un elemento óptico que permite el paso de parte de la luz a través suyo y el resto de la luz es reflejado en otra dirección.\nHabitualmente están fabricados como un espejo parcialmente metalizado, situado en el camino óptico del haz formando un ángulo de 45 grados, de manera que los haces transmitidos y reflejados sean perpendiculares. La relación de intensidad entre ambos haces depende de la construcción del divisor\n"},"EVA":{"slug":"EVA","filePath":"EVA.md","title":"EVA","links":["tags/Tema","Fotos/EVA.pdf","Hadamard-Test","Cota-al-error-en-la-estimación-EVA","Limitaciones-EVA"],"tags":["Tema"],"content":"EVA Exponential Value Approximation Tema\nEn este tema veremos el algoritmos EVA (Alonso-Linaje) EVA.pdf. Que consigue aproximar el resultado con el uso único circuito. El objetivo de este algoritmo es encontrar con un único circuito el valor \\bra{\\phi}H\\ket{\\phi},\npara ello, vamos a hacer uso del Hadamard Test, que demuestra que:\n\\mathrm{Re}(\\bra{\\phi}U\\ket{\\phi})=P(0)-P(1)\nEl problema que tenemos que solucionar es que el H no tiene porque ser unitario, por lo tanto, tenemos que calcular e^{iH}.\nDesarrollo del Algoritmo\nComo no podemos  el Hamiltoniano no tiene porque ser unitario, vamos a recurrir al operador e^{iH}. Con esto hacemos el desarrollo en serie de Taylor de la exponencial : e^x = 1 +x +\\frac{x^2}{2}+\\dots\nSustituyendo x por \\frac{iH}{k}, y tomando valores esperados, llegamos a:\\bra{\\phi}e^{iH/k}\\ket{\\phi} = \\bra{\\phi}I\\ket{\\phi}+i\\frac{{\\bra{\\phi}H\\ket{\\phi}}}{k} -  \\bra{\\phi}H^2\\ket{\\phi} - \\dots\nVamos atomar la parte imaginaria  de la expresión:\\begin{align}\n\\Im(\\bra{\\phi}e^{iH/k}\\ket{\\phi}) = &amp; \\frac{\\bra{\\phi}H\\ket{\\phi}}{k} - \\frac{\\bra{\\phi}H^3\\ket{\\phi}}{3!k^3}+\\dots  \\\\\n \\\\\n  \\bra{\\phi}H\\ket{\\phi} =  &amp;  \\Im(\\bra{\\phi}e^{iH/k}\\ket{\\phi}) +\\frac{\\bra{\\phi}H^3\\ket{\\phi}}{3!k^3}- \\dots\n\\end{align}\nSiendo k \\geq 1, si tomamos los limites podemos llegar a la ecuación fundamental del algoritmo:\\bra{\\phi}H\\ket{\\phi} = \\lim_{ k \\to \\infty } k\\Im\\bra{\\phi}e^{iH/k}\\ket{\\phi}    \nPor lo tanto, para obtener el valor esperado del estad \\ket{\\phi} a través del Hamiltoniano, únicamente será necesario construir la exponencial compleja de dicho Hamiltoniano y aplicar Hadamard test parte imaginaria para obtener la parte imaginaria:\n\nVisto de esta manera, ejecutaremos dicho circuito y calcularemos k(P(0)-P(1)) como aproximación a nuestro valor buscado.\nLa pregunta que no podemos hacer es como de bien aproxima este método, para ello, buscaremos Cota al error en la estimación EVA. Como hemos visto, aparentemente podemos tomar un valor de k tan  grande como queramos, si embargo esto no lo podemos hacer debido a Limitaciones EVA"},"Ecuación-de-Shrödinger":{"slug":"Ecuación-de-Shrödinger","filePath":"Ecuación de Shrödinger.md","title":"Ecuación de Shrödinger","links":[],"tags":[],"content":"Ecuación de Shrödinger\nEn mecánica cuántica, el estado de una partícula viene descrito por una función de onda. Esta función se denota normalmente por ψ(x, t). La evolución del estado de la partícula, es la evolución del la función de onda y esta evolución viene descrita por la ecuación de Schrödinger.\nEl comportamiento de una partícula de masa m que está sometida a la acción de un potencial V (x, t) viene descrito por la siguiente ecuación diferencial:\n\nEcuación de Shrödinger independiente del tiempo\n\n"},"Efecto-Josephson":{"slug":"Efecto-Josephson","filePath":"Efecto Josephson.md","title":"Efecto Josephson","links":["Unión-Josephson"],"tags":[],"content":"Efecto Josephson\nPara entender este efecto, debemos introducir los superconductores. Ciertos metales cuando son enfriados a temperaturas muy bajas no presentan ninguna resistencia a la corriente eléctrica. En este estado, los electrones se agrupan formando pares de Cooper.\nEl efecto Josephson es un equivalente al efecto túnel pero con pares de Copper en lugar de electrones sueltos. Es decir si ponemos dos superconductores cerca separados por un aislante, los pares de Cooper pueden superar este potencial y pasar de un superconductor a otro creando una corriente I = I_{c}\\sin(\\phi).\nLa aplicación de este efecto es la Unión Josephson"},"Ejemplo-VQE-con-PennyLane":{"slug":"Ejemplo-VQE-con-PennyLane","filePath":"Ejemplo VQE con PennyLane.md","title":"Ejemplo VQE con PennyLane","links":[],"tags":[],"content":"Ejemplo de implantación VQE en PennyLane\n"},"Ejemplo-equivalencia-entre-encontrar-el-periodo-y-factorizar":{"slug":"Ejemplo-equivalencia-entre-encontrar-el-periodo-y-factorizar","filePath":"Ejemplo equivalencia entre encontrar el periodo y factorizar.md","title":"Ejemplo equivalencia entre encontrar el periodo y factorizar","links":[],"tags":[],"content":"Ejemplo equivalencia entre encontrar el periodo y factorizar\nVamos a demostrar con un ejemplo numérico que factorizar N es equivalente a encontrar un periodo par de la función f(x) = a^x \\mod(N), siendo a un entero aleatorio coprimo de N. Factorizar N=15 con por ejemplo a=7.\ncon f(x) = a^x  \\mod(N)\\to f(x) = 7^x  \\mod(15):\nf(0) &amp;= 7^0  \\mod(15) \\equiv 1  \\mod(15) \\\\ \nf(1) &amp;= 7^1  \\mod(15) \\equiv 7  \\mod(15) \\\\ \nf(2) &amp;= 7^2  \\mod(15)  = 49 \\mod(15) \\equiv  4 \\mod(15) \\\\\nf(3) &amp;= 7^3  \\mod(15)  = 7\\cdot {7}^2 = 7 \\cdot 4 \\mod(15) \\equiv  13 \\mod(15) \\\\\nf(4) &amp;= 7^4  \\mod(15)  = 7^2\\cdot {7}^2 = 4 \\cdot 4 \\mod(15) \\equiv  1 \\mod(15) \n\\end{align}$$\nHemos encontrado que el periodo y por lo tanto el orden es $r=4$, como es par podemos calcular $p$ y $q$ así:\n\n$$\\begin{align}\nMDC(7^2+1,15) = MDC(50,15) =5 \\\\\nMDC(7^2-1,15) = MDC(48,15) =3\n\\end{align}$$"},"Elementos-cuánticos":{"slug":"Elementos-cuánticos","filePath":"Elementos cuánticos.md","title":"Elementos cuánticos","links":["tags/Tema","Qubit","Puertas-cuánticas"],"tags":["Tema"],"content":"Elementos cuánticos Tema\nIndice\nQubit\nPuertas cuánticas"},"Elementos-de-óptica-cuántica-lineal":{"slug":"Elementos-de-óptica-cuántica-lineal","filePath":"Elementos de óptica cuántica lineal.md","title":"Elementos de óptica cuántica lineal","links":["Divisores-de-haz","Láminas-de-onda","Láminas-plano-paralelas"],"tags":[],"content":"Elementos de óptica cuántica lineal\nLos constituyentes principales de la cualquier sistema óptico son:\n\nDivisores de haz\nLáminas de onda\nLáminas plano-paralelas\n\nMediante estos tres elementos es posible definir modos ópticos que se comporten como estados cuánticos en el caso de los fotones individuales \\rightarrow La dirección espacial del fotón tras atravesar un divisor de haz y el estado de polarización tras atravesar una lámina de onda. Al unir estos dos modos, la información de fase, que puede ser modificada mediante láminas plano-paralelas, tenemos la base computacional buscada."},"Energía-cinética-electrones-libres":{"slug":"Energía-cinética-electrones-libres","filePath":"Energía cinética electrones libres.md","title":"Energía cinética electrones libres","links":[],"tags":[],"content":"Energía cinética electrones libres\nLa energía cinética de los electrones moviéndose de forma libre por el espacio tiene la forma:\nE = \\frac{{\\hbar ^2k^2}}{2m_{e}} = \\frac{{\\hbar ^2}}{2m_{e}}(k_{x}^2+ k_{y}^2+k_{z}^2)"},"Energía-de-Fermi":{"slug":"Energía-de-Fermi","filePath":"Energía de Fermi.md","title":"Energía de Fermi","links":[],"tags":[],"content":"Energía de Fermi\nLa energía de Fermi es es la energía del nivel mas alto ocupado por un sistema cuántico al cero absoluto (0k):\nE_{F}= \\frac{\\hbar^{2}}{2m_{e}}\\left(\\frac{3\\pi^2N}{V}\\right)^{\\frac{2}{3}}$$\nDonde $N$ es el número de electrones, $V$ es el volumen del material y $m_{e}$ es la masa del electrón."},"Ensemble":{"slug":"Ensemble","filePath":"Ensemble.md","title":"Ensemble","links":["estado-puro","estado-mixto"],"tags":[],"content":"Ensemble o Agrupación de estos cuánticos\n\nSi tenemos un sistema cuántico que puede estar en varios estados cuánticos |yi&gt; con probabilidad pi. Tenemos 2 opciones:\n\nQue sea un estado puro y esté en una estado  |yi&gt;.\nQue sea un estado mixto y se encuentre en una combinación de estados.\n\nVarios estos puros se agrupan en un ensemble para formar un sistema mixto."},"Entropia-de-Shannon":{"slug":"Entropia-de-Shannon","filePath":"Entropia de Shannon.md","title":"Entropia de Shannon","links":[],"tags":[],"content":"Entropía de Shannon\nUna medida de la información contenida en el mensaje.\nValor informacional de un mensaje\nLa entropía también se puede considerar como la cantidad de información promedio que contienen los símbolos usados. Los símbolos con menor probabilidad son los que aportan mayor información; por ejemplo, si se considera como sistema de símbolos a las palabras en un texto, palabras frecuentes como «que», «el», «a» aportan poca información, mientras que palabras menos frecuentes como «corren», «niño», «perro» aportan más información. Si de un texto dado borramos un «que», seguramente no afectará a la comprensión y se sobreentenderá, no siendo así si borramos la palabra «niño» del mismo texto original.\nSi queremos expresar estas ideas matemáticamente podemos usar la función I que será el contenido de información de un evento E. De este modo:\nI(E) = -\\log_{2}(p(E)) \\\\ \\\\\n\nI(E) = \\log_{2}\\left( \\frac{1}{p(E)} \\right)\n\\end{align}$$\nSiendo $p(E)$ la probabilidad del evento $E$.\n\n\n## Formulación matemática de la entropía de Shannon\n\n\nDefinimos la entropía de una variable discreta aleatoria $X$ cuyos posibles valores pueden ser $x_{1},x_{2},..,x_{n}$ como\n$$H(X)= E[I(X)]$$\n\nSiendo $E$ el valor esperado y $I(X)$ el contenido de información de $X$, de esta manera:\n\n$$\\begin{align}\nI(X) &amp;= -\\log_{b}(P(X)) \\\\\nH(X) &amp;= E[-\\log_{b}(P(X))]\n\\end{align}$$\n\nSi definimos el valor esperado de una variable discreta $X$ con valores $x_{1},x_{2},..,x_{n}$ con probabilidades $p_{1},p_{2},..,p_{n}$ como $$E[X]=\\sum_{i=1}^n x_{i}p_{i}$$\nSustituyendo esta expresión en la definición de entropía de $X$ tenemos $$H(X) = -\\sum_{i=1}^{n}P(x_{i})\\log_{b}P(x_{i})$$\nPara el caso de la teoría de la información hablamos de bits y $b=2$.\n\nTambién podemos hablar de [[Entropía conjunta multivariable]] y[[Entropía condicional de dos variables]]\n\n## Propiedades de la entropía de Shannon\n\n* H debe ser continua $\\rightarrow$ Pequeños cambios en las probabilidades originan pequeños cambios en la entropía.\n* H es simétrica $\\rightarrow$ La entropía no cambia si los valores de $X$ cambian de orden.\n* H es máxima cuando todas la probabilidades son iguales y aumenta con el número de posibilidades"},"Entropía-condicional-de-dos-variables":{"slug":"Entropía-condicional-de-dos-variables","filePath":"Entropía condicional de dos variables.md","title":"Entropía condicional de dos variables","links":[],"tags":[],"content":"Entropía condicional de dos variables\nLa entropía condicional es la cantidad de información en una variable aleatoria suponiendo que conocemos la otra.\nSi X e Y son variables discretas aleatorias tales que sus posibles valores son \\begin{align}\nX&amp;:\\{x_{1},x_{2},\\dots,x_{n}\\} \\\\\nY&amp;:\\{y_{1},y_{2},\\dots,y_{n}\\}\n\\end{align}\nLa entropía condicional de X e Y se define como:\nH(X|Y)=-\\sum_{i,j}^{n,m}p(x_{i,y_{j}})\\cdot \\log_{b}\\frac{p(x_{i},y_{i})}{p(y_{j})}"},"Entropía-conjunta-multivariable":{"slug":"Entropía-conjunta-multivariable","filePath":"Entropía conjunta multivariable.md","title":"Entropía conjunta multivariable","links":[],"tags":[],"content":"Entropía conjunta multivariable\nSi X e Y son variables discretas aleatorias tales que sus posibles valores son \\begin{align}\nX&amp;:\\{x_{1},x_{2},\\dots,x_{n}\\} \\\\\nY&amp;:\\{y_{1},y_{2},\\dots,y_{n}\\}\n\\end{align}\nEntonces la entropía conjunta de estas dos variables es:\nH(X,Y) = -\\sum_{i=1}^{n}\\sum_{j=1}^{m}P(x_{i},y_{j})\\cdot\\log_{b}P(x_{i},y_{j})"},"Entropía-de-Von-Nuemann":{"slug":"Entropía-de-Von-Nuemann","filePath":"Entropía de Von Nuemann.md","title":"Entropía de Von Nuemann","links":["operador-densidad"],"tags":[],"content":"Entropia de Von Nuemann\nSe trata de la extensión del concepto de entropía para estados cuánticos. La entropía de Von Nuemann para sistemas descritos por el operador densidad es:\nSea \\rho el operador densidad de un sistema cuántica, entonces definimos como la entropía de este sistema como S :\nS(\\rho)=-tr(\\rho \\log_{2}\\rho)\nDonde tr es la traza de la matriz.\nSi escribimos \\rho en términos de autovectores y autovalores:\n\\rho=\\sum_{j}\\eta_{j}\\ket{j}\\bra{j}  \nLa expresión de la entropía queda como:\nS(\\rho) = -\\sum\\eta_{j}\\log_{2}\\eta_{j}\nPropiedades\n\nS(\\rho) es 0 sólo si \\rho representa a un estado puro.\nS(\\rho) es máxima e igual a \\log N para un estado máximamente mixto, siendo N la dimensión del estado de Hilbert.\nS(\\rho) es invariante bajo cambios de base de \\rho, es decir S(\\rho)=S(U\\rho U^{\\dagger})\n"},"Espacio-de-Hilbert":{"slug":"Espacio-de-Hilbert","filePath":"Espacio de Hilbert.md","title":"Espacio de Hilbert","links":["tags/Tema","Espacios-Prehilbert","completo","producto-interno","Norma"],"tags":["Tema"],"content":"Espacio de Hilbert Tema\nUn espacio de Hilbert, es un Espacios Prehilbert que es completo. Es decir, es un espacio vectorial con producto interno que es completo respecto a la Norma definida por ese producto interno. En concreto la Norma de estos espacios esta definida sobre el cuerpo de los complejos."},"Espacio-de-estados-Qubit":{"slug":"Espacio-de-estados-Qubit","filePath":"Espacio de estados Qubit.md","title":"Espacio de estados Qubit","links":["Fase-relativa-y-fase-Global"],"tags":[],"content":"Espacio de estados Qubit\nEl espacio de estados es el conjunto de todos los estados posibles de un sistema. En un qubit, independientemente de su implementación, el espacio de estados es el conjunto de posibles valores: \\alpha\\ket{0}+\\beta \\ket{1}, donde |\\alpha^2|+|\\beta^2|= 1 y también:\\alpha\\ket{0}+\\beta \\ket{1} \\text{ y }\\alpha&#039;\\ket{0}+\\beta&#039; \\ket{1} \nSe consideran el mismo estado si:\n\\alpha\\ket{0}+\\beta \\ket{1} = c(\\alpha&#039;\\ket{0}+\\beta&#039; \\ket{1})\nSiendo c cualquier número complejo de módulo 1. Ejemplo:\nEl estado \\frac{1}{\\sqrt{ 2 }}(\\ket{0}-\\ket{1}) y el estado \\frac{i}{\\sqrt{ 2 }}(\\ket{0}-\\ket{1}) se consideran el mismo estado.\nPara entender esta ambigüedad, introducimos: Fase relativa y fase Global"},"Espacio-de-estados-n-Qubits":{"slug":"Espacio-de-estados-n-Qubits","filePath":"Espacio de estados n Qubits.md","title":"Espacio de estados n Qubits","links":[],"tags":[],"content":"Espacio de estados n Qubits\nDos sistemas cuánticos con estados representados por vectores en los espacios V y W, los posibles estados del sistema cuántico conjuntos están representados en el espacio vectorial V\\otimes W.\nDe forma general, para 0 \\leq i\\geq n sea V_{i} el espacio vectorial correspondiente a un qubit, podemos representan un sistema de n qubits en el espacio vectorial V_{n-1}\\otimes \\cdots \\otimes V_{1}\\otimes V_{2}. La base estándar de este espacio vectorial está formada por 2^n vectores del tipo(obviando los subíndices y sin escribir \\otimes):\\{\\ket{0}\\cdots \\ket{0}\\ket{0},\\ket{0}\\cdots \\ket{0}\\ket{1},\\ket{0}\\cdots \\ket{1}\\ket{0},\\dots,\\ket{1}\\cdots \\ket{1}\\ket{1}\\}\nDe forma más compacta, un sistema de 3 qubit, la podemos escribir como:\\{\\ket{000},\\ket{001},\\ket{010},\\ket{011},\\ket{100},\\ket{101},\\ket{110},\\ket{111}\\}\nY si en vez de forma binaria lo hacemos en decimal tenemos:\\{\\ket{0},\\ket{1},\\ket{2},\\ket{3},\\cdots,\\ket{2^{n}-1}\\} "},"Espacios-Prehilbert":{"slug":"Espacios-Prehilbert","filePath":"Espacios Prehilbert.md","title":"Espacios Prehilbert","links":["producto-interno","Norma","Distancia"],"tags":[],"content":"Espacios Prehilbert\nUn espacio de prehilbert es un espacio vectorial V provisto de un producto interno.\nDefiniciones\nNorma\nDistancia"},"Espacios-vectoriales":{"slug":"Espacios-vectoriales","filePath":"Espacios vectoriales.md","title":"Espacios vectoriales","links":["combinación-lineal","independencia-lineal","Bases","Dimensión"],"tags":[],"content":"Espacios Vectoriales\nIndice\ncombinación lineal\nindependencia lineal\nBases\nDimensión"},"Estado-excitado":{"slug":"Estado-excitado","filePath":"Estado excitado.md","title":"Estado excitado","links":["Estado-fundamental"],"tags":[],"content":"Estado excitado\nCualquier estado cuántico por encima del Estado fundamental, es decir que tenga mayor energía que el mínimo. Desde un estado excitado, decae espontáneamente al estado fundamental.\nSe puede pasar de un estado fundamental a un estado excitado, cuando el átomo recibe energía, por ejemplo mediante un láser."},"Estado-fundamental":{"slug":"Estado-fundamental","filePath":"Estado fundamental.md","title":"Estado fundamental","links":[],"tags":[],"content":"Estado fundamental\nEl estado fundamental o ground state en la mecánica cuántica corresponde con el estado de mínima energía o el punto de energía cero de un sistema.\nPor lo general lo átomos tienden a decaer de manera natural a su estado fundamental."},"Estados-base-para-sistemas-de-espín-un-medio":{"slug":"Estados-base-para-sistemas-de-espín-un-medio","filePath":"Estados base para sistemas de espín un medio.md","title":"Estados base para sistemas de espín un medio","links":[],"tags":[],"content":"Estados base para sistemas de espín un medio"},"Estructura-matemática-de-la-mecánica-cuántica":{"slug":"Estructura-matemática-de-la-mecánica-cuántica","filePath":"Estructura matemática de la mecánica cuántica.md","title":"Estructura matemática de la mecánica cuántica","links":["tags/Tema","Notación-de-Dirac","Espacio-de-Hilbert","Operadores","Observables","Relaciones-de-indeterminación","Cambio-de-base","Diagonalización","Observables-equivalentes","Producto-tensorial"],"tags":["Tema"],"content":"Estructura matemática de la mecánica cuántica Tema\nIndice\nNotación de Dirac\nEspacio de Hilbert\nOperadores\nObservables\nRelaciones de indeterminación\nCambio de base\nDiagonalización\nObservables equivalentes\nProducto tensorial"},"Evolución-temporal-sistemas-spin-un-medio":{"slug":"Evolución-temporal-sistemas-spin-un-medio","filePath":"Evolución temporal sistemas spin un medio.md","title":"Evolución temporal sistemas spin un medio","links":[],"tags":[],"content":"Evolución temporal sistemas spin un medio"},"Experimento-de-Stern-Gerlach":{"slug":"Experimento-de-Stern-Gerlach","filePath":"Experimento de Stern-Gerlach.md","title":"Experimento de Stern-Gerlach","links":[],"tags":[],"content":"Experimento de Stern-Gerlach"},"Fase-relativa-y-fase-Global":{"slug":"Fase-relativa-y-fase-Global","filePath":"Fase relativa y fase Global.md","title":"Fase relativa y fase Global","links":["Espacio-de-Hilbert"],"tags":[],"content":"Fase relativa y fase global\nFase Global\nUn mismo  estado cuántico puede estar representado por más de un vector en el espacio de estados, por lo tanto existe una diferencia fundamental entre entre el Espacio de Hilbert que describe el qubit y el espacio de estados. Queda cierta ambigüedad, dos vectores unitarios equivalentes representan el mismo estado. El múltiplo por el cual dos vectores que representan en mismo estado cuántico se diferencian se conoce como fase global\n\nUsamos la relación de equivalencia \\ket{v}\\sim \\ket{v&#039;} para indicar que \\ket{v} = c\\ket{v&#039;} para cualquier fase global compleja c=e^{i\\psi}.\nLos estados de un qubit se representan en un espacio de Hilbert de dimensión 2(\\mathbb{C}^2). sin embargo, dos vectores que son múltiplos escalares representan el mismo estado cuántico. Esto implica que ==los estados físicos del qubit están en un espacio proyectivo complejo de dimensión 1 \\mathbb{CP}^1.== De esta manera todos los vectores equivalentes(múltiplos escalares) en \\mathbb{C}^2 representan al mismo estado a nivel físico en \\mathbb{CP}^1. De esta manera demostramos que la fase global no tiene un significado físico (no se detecta experimentalmente, ni influye en las probabilidades ) y puede ser obviada y que lo importante de la representación del estado un qubit como un vector de \\mathbb{C}^2 es su dirección y no su magnitud.\nFase relativa\nLa fase relativa si que tiene si que tiene un significado físico. En un sistema descrito por la superposición a\\ket{0}+b\\ket{1} es una medida del ángulo en el plano complejo entre los números complejos a y b.\nDe forma más precisa, la fase relativa es el número complejo e^{i\\psi} de módulo 1, que satisface:\\frac{a}{b}=e^{i\\psi}\\frac{|a|}{|b|}\nDos superposiciones cuyas amplitudes tienen la misma magnitud, pero distinta fase relativa, corresponden a estados diferentes. Es decir \\frac{1}{\\sqrt{ 2 }}(e^{i\\psi}\\ket{v_{1}}+\\ket{v_{2}}) \\text{ y }\\frac{1}{\\sqrt{ 2 }}(\\ket{v_{1}}+\\ket{v_{2}}) \nNo representan el mismo estado."},"Fórmula-de-Euler":{"slug":"Fórmula-de-Euler","filePath":"Fórmula de Euler.md","title":"Fórmula de Euler","links":[],"tags":[],"content":"Fórmula de Euler\n"},"Fuentes-de-fotones-individuales":{"slug":"Fuentes-de-fotones-individuales","filePath":"Fuentes de fotones individuales.md","title":"Fuentes de fotones individuales","links":["Computación-cuántica-con-fotones","Trampa-de-Paul"],"tags":[],"content":"Fuentes de fotones individuales\nPara realizar todos lo procesos descritos en Computación cuántica con fotones es necesario disponer de fotones individuales fiables.\nLaser atenuado\nLa forma más sencilla de implementación. Consiste en reducir la intensidad de un láser mediante filtro consecutivos, cada vez llegará menos a luz a la muestra, haciendo posible que en algún momento llegue un único fotón.\nEl problema es que no es una fuente de fotones individuales, si no una aproximación estadística usando luz coherente. Los fotones láser tienden a agruparse.\nIones o átomos\nLa luz emitida por átomos e iones individuales cumplirá el desagrupamiento de fotones \\rightarrow El intercalo de tiempo entre la generación de dos fotones individuales nunca puede ser menor a un valor mínimo determinado por las dinámicas de excitación y relajación del sistema cuántico que actúa como fuente.\nPara utilizar átomos o iones como fuentes de fotones individuales, podemos utilizar Trampa de Paul o pinzas ópticas.\nDispositivos de estado sólido\nPor ejemplo los centro de color en diamantes, que son defectos puntales de la estructura cristalina del diamante que tienen una estructura electrónica y un comportamiento óptico similar al de un átomo aislado."},"Funciones-Kernel":{"slug":"Funciones-Kernel","filePath":"Funciones Kernel.md","title":"Funciones Kernel","links":["SVM-Clásico"],"tags":[],"content":"Funciones Kernel\nPara solucionar el problema de que no todos los dato son linealmente separables lo que hacemos es mapear los datos a un espacio de dimensión mayor con la esperanza de que en el nuevo espacio si sean separables:\n\nDefinimos \\phi como la función que mapea cada elemento en uno de dimensión mayor. Siguiendo el ejemplo de la ilustración tendríamos \\phi : x \\rightarrow (x,x^2), si sustituimos en la ecuación final de SVM Clásico, tenemos:\nL&#039;= -\\sum_{i=1}^m\\alpha_{i}+\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m \\alpha_{i}\\alpha_{j}f(\\vec{x_{i}})f(\\vec{x_{j}})\\phi(\\vec{x_{i}}) \\cdot \\phi(\\vec{x_{j}})\nLo que hemos hecho es sustituir el producto \\vec{x_{i}} \\cdot \\vec{x_{j}} por \\phi(\\vec{x_{i}}) \\cdot \\phi(\\vec{x_{j}}). A esto le llamaremos función Kernel:\nK(\\vec{x_{i}}, \\vec{x_{j}}) = \\phi(\\vec{x_{i}}) \\cdot \\phi(\\vec{x_{j}})"},"Funciones-complejas":{"slug":"Funciones-complejas","filePath":"Funciones complejas.md","title":"Funciones complejas","links":["Función-exponencial","Seno-y-coseno","Fórmula-de-Euler","Logaritmo-complejo","Teorema-fundamental-del-álgebra"],"tags":[],"content":"Funciones complejas\n\nEjemplos de funciones complejas\n\nFunción exponencial\nSeno y coseno\nFórmula de Euler\nLogaritmo complejo\nTeorema fundamental del álgebra\n"},"Funciones-generales-recursivas":{"slug":"Funciones-generales-recursivas","filePath":"Funciones generales recursivas.md","title":"Funciones generales recursivas","links":[],"tags":[],"content":"Funciones generales recursivas\nSon funciones parciales que toman tuplas finitas de números naturales y devuelven un solo número natural. Toman su nombre del proceso de recursividad, que hace que que el valor de una función se defina mediante la aplicación de la misma función a argumentos más pequenos.\nEjemplo\nUna función factorial sería:\nfact(0)=1\nfact(x+1) = fact(x+1)*fact(x)\n\n\nRecursión en la computación\nLa recursión es muy usuda en la computación. Permite resolver problemas en los que la solución depende de soluciones a instancias más pequeñas del mismo problema. Estos problemas se suelen resolver mediante iteración, para ellos se usan funciones que se llaman a si mismas."},"Función-exponencial":{"slug":"Función-exponencial","filePath":"Función exponencial.md","title":"Función exponencial","links":[],"tags":[],"content":"Función exponencial\n"},"Geometría-números-complejos":{"slug":"Geometría-números-complejos","filePath":"Geometría números complejos.md","title":"Geometría números complejos","links":["tags/Tema","curvas-complejas","círculos-complejos","disco-complejo","rectas-complejas"],"tags":["Tema"],"content":"Geometría números complejos Tema\nIndice\ncurvas complejas\ncírculos complejos\ndisco complejo\nrectas complejas"},"Hadamard-Test":{"slug":"Hadamard-Test","filePath":"Hadamard Test.md","title":"Hadamard Test","links":["EVA"],"tags":[],"content":"Hadamard Test\nEl test de Hadamard es capaz de calcular \\Re\\bra{\\phi}U\\ket{\\phi} para cualquier operador unitario U. También en posible calcular la parte imaginaria con modificaciones en el test, por lo tanto, relacionándolo con el algoritmo EVA podríamos pensar que sustituyendo H por U podríamos llegar a la solución deseada, el problema es que H no tiene porque ser unitario.\n\nA partir de este circuito podemos asegurar que:\n\\Re(\\bra{\\phi}H\\ket{\\phi}) = P(0)-P(1)\nSiendo P(0) y P(1) la probabilidad de obtener \\ket{0} y \\ket{1} respectivamente al medir sobre el primer qubit.\nDemostración Hadamard Test\n\nEmpezamos por el estado \\ket{\\phi}\\ket{0}, tras aplicar la puerta Hadamard sobre el primer qubit tenemos:\n\\ket{\\phi}\\frac{{\\ket{0}+\\ket{1}}}{\\sqrt{ 2 }} \nTras aplicar la puerta controlada tenemos:\n\n\\frac{U\\ket{\\phi}\\ket{1}}{\\sqrt{ 2 }}+\\frac{\\ket{\\phi}\\ket{0}}{\\sqrt{ 2 }}    \n4. Volvemos a aplicar la Hadamard:\n\\frac{{U\\ket{\\phi}\\ket{0}-U\\ket{\\phi}\\ket{1}}}{2} + \\frac{{\\ket{\\phi}\\ket{0}+\\ket{\\phi}\\ket{1}}}{2}\nSi agrupamos respecto al qubit de medición tenemos:\n\\frac{{(U\\ket{\\phi}+\\ket{\\phi})\\ket{0}-(U\\ket{\\phi}-\\ket{\\phi})\\ket{1}}}{2}\nVamos a calcular primero P(0):\nP(0) &amp;=  \\left\\| \\displaystyle\\frac{(U\\ket{\\phi}+\\ket{\\phi})}{2} \\right\\|^2 = \\frac{{(\\bra{ {\\phi}}U^{\\dagger} +  \\bra{\\phi})(U\\ket{\\phi}+\\ket{\\phi})}}{4} = \\\\ \\\\\n\n&amp;= \\frac{{2+\\bra{\\phi}U^{\\dagger}\\ket{\\phi}+\\bra{\\phi}U\\ket{\\phi}}}{4} \n\\end{align}$$\nY ahora calcularemos $P(1)$:\n$$\\begin{align}\nP(1) &amp;=  \\left\\| \\displaystyle\\frac{(U\\ket{\\phi}-\\ket{\\phi})}{2} \\right\\|^2 = \\frac{{(\\bra{ {\\phi}}U^{\\dagger} - \\bra{\\phi})(U\\ket{\\phi}-\\ket{\\phi})}}{4} = \\\\ \\\\\n\n&amp;= \\frac{{2-\\bra{\\phi}U^{\\dagger}\\ket{\\phi}-\\bra{\\phi}U\\ket{\\phi}}}{4} \n\\end{align}$$\n\nSi restamos ambas probabilidades tenemos: \n$$P(0)-P(1) = \\frac{{\\bra{\\phi}U^{\\dagger}\\ket{\\phi}+\\bra{\\phi}U\\ket{\\phi}}}{2}$$\nSabiendo que la suma de un número complejo con su conjugado nos da el doble de su parte real $z^* +z = 2 \\Re(z)$, por lo tanto:\n$$P(0)-P(1) = \\Re(\\bra{\\phi}U\\ket{\\phi})$$\nQueda así demostrado.\n\n## Hadamard test parte imaginaria\n\nDe la misma manera podemos usar este circuito para obtener $P(0)-P(1) = \\Im(\\bra{\\phi}U\\ket{\\phi})$\n\n\n![[Pasted image 20240525115308.png|450]]"},"Implementación-física-de-un-procesador-cuántico":{"slug":"Implementación-física-de-un-procesador-cuántico","filePath":"Implementación física de un procesador cuántico.md","title":"Implementación física de un procesador cuántico","links":["tags/Asignatura","Qubit-físico","Qubits-Superconductores","Qubits-Trampa-de-Iones","Qubits-de-átomos-neutros","Qubits-de-puntos-cuánticos","Computación-cuántica-con-fotones"],"tags":["Asignatura"],"content":"Implementación física de un procesador cuántico Asignatura\nTema 1. Qubit físico\nTransclude of Qubit-físico#indice\nTema 3. Qubits Superconductores\nTema 4. Qubits Trampa de Iones\nTema 5. Qubits de átomos neutros\nTema 7. Qubits de puntos cuánticos\nTema 8.Computación cuántica con fotones"},"Información-cuántica":{"slug":"Información-cuántica","filePath":"Información cuántica.md","title":"Información cuántica","links":["tags/Asignatura","Teoría-de-la-información","Codificación-y-corrección-de-errores-clásicos","Elementos-cuánticos","Teoría-de-la-información-cuántica","entrelazamiento","Cifrado-y-seguridad-cuántica"],"tags":["Asignatura"],"content":"Información cuántica Asignatura\nTema 1. Teoría de la información\nTransclude of Teoría-de-la-información#indice\nTema 2. Codificación y corrección de errores clásicos\nTransclude of Codificación-y-corrección-de-errores-clásicos#indice\nTema 3. Elementos cuánticos\nTransclude of Elementos-cuánticos#indice\nTema 4. Teoría de la información cuántica\nTransclude of Teoría-de-la-información-cuántica#indice\nTema 5. entrelazamiento\nTema 6. Cifrado y seguridad cuántica"},"Inicialización-a-un-estado-fundamental":{"slug":"Inicialización-a-un-estado-fundamental","filePath":"Inicialización a un estado fundamental.md","title":"Inicialización a un estado fundamental","links":[],"tags":[],"content":"Inicialización a un estado fundamental\nEn cualquier sistema de computación los registros deben estar inicializados a un valor conocido antes de realizar cualquier cálculo. Cualquier cálculo cuántico tiene que partir de un estado inicial conocido al que podemos aplicar las diferentes operaciones. Comúnmente se inicializan en el estado \\ket{000\\cdots}.\nLa dos maneras más comunes de fijar el estado inicial de un qubit son:\n\nReducir su energía para relajarlo a su estado fundamental.\nRealizar una medida que lo proyecte al estado deseado.\n"},"Inicialización-qubits-trampa-de-iones":{"slug":"Inicialización-qubits-trampa-de-iones","filePath":"Inicialización qubits trampa de iones.md","title":"Inicialización qubits trampa de iones","links":["Estado-excitado"],"tags":[],"content":"Inicialización qubits trampa de iones\nLos iones atrapados se pueden tratar como qubits considerando dos estados de espín del estado fundamental como la base computacional. Se pueden inicializar a través de procesos ópticos de bombeo con un láser ajustado a la transición del primer Estado excitado.\nPara la inicialización se ilumina el ion con radiación láser a las frecuencias de resonancia de las transiciones \\ket{\\uparrow}\\rightarrow\\ket{e}  y \\ket{\\uparrow}\\rightarrow\\ket{e&#039;}, lo que provoca que el qubit decaiga al estado \\ket{\\downarrow}, donde no interactúa con la luz.\nParte de los estados excitados volverán al estado \\ket{\\uparrow}, pero, si se radia el tiempo suficiente, la probabilidad de que ese sea el estado final del qubit es estadísticamente despreciable. esta técnica permite preparar el qubit al estado \\ket{\\downarrow} con una fidelidad cercana al 100%.\n"},"Interpretaciones-de-la-mecánica-cuántica":{"slug":"Interpretaciones-de-la-mecánica-cuántica","filePath":"Interpretaciones de la mecánica cuántica.md","title":"Interpretaciones de la mecánica cuántica","links":[],"tags":[],"content":"Interpretaciones de la mecánica cuántica"},"Interpretación-intuitiva-Algoritmo-de-Grover":{"slug":"Interpretación-intuitiva-Algoritmo-de-Grover","filePath":"Interpretación intuitiva Algoritmo de Grover.md","title":"Interpretación intuitiva Algoritmo de Grover","links":["Algoritmo-de-Grover"],"tags":[],"content":"Interpretación intuitiva Algoritmo de Grover\nExplicaremos de una forma intuitiva como funciona el Algoritmo de Grover con un ejemplo concreto.\nSupongamos una lista de N=4 elementos que representamos con n=2 qubits. Los valores de esta tabla son \\{\\ket{00},\\ket{01},\\ket{10},\\ket{11}\\}. Suponemos que el estado que queremos buscar es \\ket{10}.\n\nLo primero que hacemos es poner todos los estados es una superposición equiprobable, si representamos sus amplitudes de probabilidad:\n\n\n\nAplicamos el oráculo U_{w} que marca el estado buscado \\ket{10} invirtiendo su signo:\n\n\n\nEl operador difusor U_{D} lo que hace es invertir respecto a al media todos los estados.\n\n\nPor lo tanto, hemos conseguido aumentar la amplitud de probabilidad del estado marcado. Para conseguir resultados más óptimos debemos repetir la aplicación de U_{w} y U_{D} ||\\frac{\\pi}{4}\\sqrt{ n }|| veces."},"Introducción-redes-neuronales-clásicas":{"slug":"Introducción-redes-neuronales-clásicas","filePath":"Introducción redes neuronales clásicas.md","title":"Introducción redes neuronales clásicas","links":["Modelo-de-clasificación","Descenso-del-gradiente"],"tags":[],"content":"Introducción redes neuronales clásicas\nLas redes neuronales son unas estructuras de datos que definirán nuestro modelo de una forma muy concreta. Las redes neuronales han ganada mucha popularidad debido a si facilidad de implementación como por la capacidad de adaptación a cualquier tipo de función.\n\nUna neurona contará con una serie de entradas distintas, en el caso de la figura, dos entradas más in bias. Cada una de las conexiones por la que llegan los inputs están influenciadas por unos pesos \\vec{\\theta}. Una vez ponderados llegamos al cuerpo de la neurona donde se suman los valores obtenidos y finalmente se aplica una función de activación. Existen diferentes funciones de activación pero una de las más utilizadas es la arcotangente, para restringir el output entre -1 y 1. El modelo de la neurona quedaría definido de la siguiente forma:\ng(\\vec{\\theta})(\\vec{x}) = \\arctan(x_{0}\\theta_{0}+x_{1}\\theta_{1}+\\theta_{2})\nSupongamos que estamos trabajando con un Modelo de clasificación. Vamos a definir el error como la suma de las distancias de g(\\vec{\\theta})(\\vec{x}) a sus etiquetas:\nE(g(\\vec{\\theta})) = \\sqrt{ \\sum_{i=1}^m \\mid g(\\vec{\\theta})(\\vec{x_{i}}) -y_{i} \\mid^2}\nLa ventaja radica en que definido de esta manera, la función de error pasa a ser un  función derivable, siendo:\nE(\\vec{\\theta}) = \\sqrt{ \\sum_{i=1}^m \\mid \\arctan(x_{0}\\theta_{0}+x_{1}\\theta_{1}+\\theta_{2}) -y_{i} \\mid^2}\nDe esta manera, podemos buscar el mínimo de una función derivable a través del Descenso del gradiente.\nRed neuronal\nUna red neuronal es un conjunto de neuronas distribuidas en distintas capas, que interactuan entre si con el objetivo de crear un modelo mucho más flexible.\n\nEn la imagen vemos una red neuronal con 2 inputs, que pasarán por la primera capa de dos neuronas, posteriormente a una de 3 y acaba con una capa de 1 neurona. La idea es concretar todas las salidas de unas neuronas con las entradas de otras en la siguiente capa. Obtenemos así una función de error que dependa de cada uno de los parámetros que aparezcan dentro de todas las neuronas.\nLa razón de utilizar esta función de activación es romper con la linealidad de la función neurona. En este caso el proceso de derivación es más complejo y se llama retropropagación y se caracteriza por el uso de la regla de la cadena para derivar funciones.\nEjemplo:Clasificación con red neuronal"},"Inversion-temporal":{"slug":"Inversion-temporal","filePath":"Inversion temporal.md","title":"Inversion temporal","links":[],"tags":[],"content":"Inversion temporal\n"},"La-máquina-de-Turing":{"slug":"La-máquina-de-Turing","filePath":"La máquina de Turing.md","title":"La máquina de Turing","links":["tags/Tema","Componentes-de-la-máquina-de-Turing","Definición-formal-de-la-máquina-de-Turing","Diagramas-de-estados-de-la-máquina-de-Turing","Máquinas-de-Turing-universales"],"tags":["Tema"],"content":"La máquina de Turing Tema\nLa máquina de Turing aparece por primera vez en el artículo de Turing «Sobre los números computables, y su aplicación al Entscheidungsproblem» (1937).\nNos vamos a centrar en la máquina de Turing determinista. Para el caso de un máquina de Turing de memoria acotada, la máquina esta formada por:\n\nCabezal\nUnidad de control\nUnidad de cinta\n\n\nEl funcionamiento a alto nivel sería:\n\nPara cada unidad de tiempo, la unidad de control acepta una entrada de la unidad de la cinta y proporciona una salida.\nLa unidad de cinta proporciona el valor de la salida en la celda bajo el cabezal. Este valor es una palabra de b-bits. La unidad de cinta acepta y escribe esta palabra de b-bits en la celda\nLa unidad de cinta también puede recibir y aceptar instrucciones para mover el cabezal a una celda a la izquierda o derecha.\nLa unidad de cinta es una matriz de celdas y tiene una capacidad de almacenamiento de S = m \\cdot b bits.\n\nDe forma más detallada, vamos a explicar los Componentes de la máquina de Turing.\nDefinición formal de la máquina de Turing\nPodemos representar el funcionamiento de estas máquina con Diagramas de estados de la máquina de Turing.\nPara terminar vamos a explicar las Máquinas de Turing universales"},"Láminas-de-onda":{"slug":"Láminas-de-onda","filePath":"Láminas de onda.md","title":"Láminas de onda","links":[],"tags":[],"content":"Láminas de onda\nLas láminas de onda son elementos ópticos que pueden cambiar la fase relativa entre las componentes del campo electromagnético de un haz de luz, alternado su polarización.\nSe suelen construir con cristales birrefringentes, que presentan anisotropía en sus propiedades ópticas.\n\nLas láminas de media onda cambian la dase de los componentes de campo eléctrico de la luz incidente por el mismo ángulo, rotando la polarización lineal de esta.\nLas láminas de cuarto de onda introducen un desfase de \\frac{\\pi}{2} entre los componentes eléctricos de la luz, lo que puede convertir a un haz polarizado linealmente en uno polarizado circularmente y viceversa.\n\n"},"Láminas-plano-paralelas":{"slug":"Láminas-plano-paralelas","filePath":"Láminas plano-paralelas.md","title":"Láminas plano-paralelas","links":[],"tags":[],"content":"Láminas plano-paralelas\nPara realizar un cambio de fase en el haz de luz incidente basta con introducir láminas plano-paralelas de materiales con un índice de refracción diferente al del medio por el que viaja el haz. Si el haz de luz es perpendicular si dirección no se verá alterada, pero su fase sufrirá un retraso al aumentar el camino óptico equivalente."},"Limitaciones-EVA":{"slug":"Limitaciones-EVA","filePath":"Limitaciones EVA.md","title":"Limitaciones EVA","links":["Cota-al-error-en-la-estimación-EVA"],"tags":[],"content":"Limitaciones EVA\nComo hemos visto en Cota al error en la estimación EVA, al elegir un valor k tan grande como queramos, pero veremos porque esto no es así.\nEl motivo es porque estamos estimando \\frac{\\bra{\\phi}H\\ket{\\phi}}{k}0, en lugar de \\bra{\\phi}H\\ket{\\phi}, y si queremos conseguir la misma precisión, el numero de shot que tenemos que realizar aumenta en un factor k^2. Por lo tanto tenemos un compromiso a la hora de elegir el factor k entre precisión y número de shots necesarios.\nEl gran inconveniente de este algoritmo es que la puerta exponencial esta formada por un gran número de puertas CNOT,. Por lo tanto al hacer el control sobre la exponencial, esas puertas se convertirán en puertas Toffoli, que tiene un error asociado muy alto. Para solucionar este problema está el algoritmo EVA reducido."},"Logaritmo-complejo":{"slug":"Logaritmo-complejo","filePath":"Logaritmo complejo.md","title":"Logaritmo complejo","links":[],"tags":[],"content":"Logaritmo complejo\n\nEjemplo\n"},"Lógica-combinatoria":{"slug":"Lógica-combinatoria","filePath":"Lógica combinatoria.md","title":"Lógica combinatoria","links":["Cálculo-Lambda"],"tags":[],"content":"Lógica combinatoria\nSe trata de un modelo simplificado de computación. Se puede ver como una variable del Cálculo Lambda, en el que las expresiones se reemplazan por un conjunto limitado de combinadores (funciones primitivas sin variables libres). La reducción mediante combinadores es más simple que la que se usa en el cálculo lambda."},"Matemáticas-de-la-información":{"slug":"Matemáticas-de-la-información","filePath":"Matemáticas de la información.md","title":"Matemáticas de la información","links":["tags/Asignatura","Teoremas-de-Shannon","Modelos-de-computación","La-máquina-de-Turing","Complejidad-computacional"],"tags":["Asignatura"],"content":"Matemáticas de la información Asignatura\nTema 1, 2 y 3. Teoremas de Shannon\nTema 4 y 5. Modelos de computación\nTema 6 La máquina de Turing\nTema 7 Complejidad computacional"},"Matrices-de-Pauli":{"slug":"Matrices-de-Pauli","filePath":"Matrices de Pauli.md","title":"Matrices de Pauli","links":[],"tags":[],"content":"Matrices de Pauli"},"Mecánica-cuántica":{"slug":"Mecánica-cuántica","filePath":"Mecánica cuántica.md","title":"Mecánica cuántica","links":["tags/Asignatura","Estructura-matemática-de-la-mecánica-cuántica","Postulados-de-la-mecánica-cuántica","Momento-angular","Simetrias-y-grupos","Sistemas-de-spin-un-medio"],"tags":["Asignatura"],"content":"Mecánica Cuántica Asignatura\nTema 1.  Estructura matemática de la mecánica cuántica\nTransclude of Estructura-matemática-de-la-mecánica-cuántica#indice\nTema 2. Postulados de la mecánica cuántica\nTransclude of Postulados-de-la-mecánica-cuántica#indice\nTema 3. Momento angular\nTransclude of Momento-angular#indice\nTema 4. Simetrias y grupos\nTransclude of Simetrias-y-grupos#indice\nTema 5.  Sistemas de spin un medio"},"Medición-Qubits-Superconductores":{"slug":"Medición-Qubits-Superconductores","filePath":"Medición Qubits Superconductores.md","title":"Medición Qubits Superconductores","links":[],"tags":[],"content":"Medición Qubits Superconductores\nLa medida de un qubit superconductor se realiza acoplando el qubit a un resonador externo y midiendo la respuesta del conjunto a un pulso de microondas.\nTodos los qubits susceptibles de ser medidos necesitan estar conectados con el resonador. Al igual que los pulsos de puertas, los de medida necesitan modulación, su lectura requiere que sean demoduladas para recuperar la información codificada en un qubit.\nDemodulación\nLa demodulación es el proceso análogo a la modulación. La señal procedente del ordenador cuántico se combina con una señal de frecuencia inferior y se obtienen las componentes de fase y cuadratura de la señal resultante a una frecuencia intermedia. La señal obtenida es procesada digitalmente donde se obtienen la amplitud y fase, que es donde está almacenada la información.\nEl proceso de medida debe ser rápido, menor que el tiempo de decoherencia del sistema. También es necesario minimiza el ruido a la hora de recibir la señal del ordenador cuántico. Para amplificar la señal sin introducir ruido, la etapa de amplificación debe estar lo mas cerca posible. Los amplificadores están dentro del propio crioestato, y están formados por elementos superconductores."},"Medición-qubits-átomos-neutros":{"slug":"Medición-qubits-átomos-neutros","filePath":"Medición qubits átomos neutros.md","title":"Medición qubits átomos neutros","links":["Multiplicación-de-electrones"],"tags":[],"content":"Medición qubits átomos neutros\nMedir este tipo de qubits es bastante sencillo, ya que implica la iluminación del registro con la luz ajustada a una transición óptica desde uno de los niveles de energía de la base computacional y observar que átomos emiten luz y cuáles no, lo que indica cuáles estaban en el estado involucrado en la transición.\nComo los registros de qubits están perfectamente ordenados en redes bidimensionales, la detección de la luz emitida no tiene que hacerse qubit a qubit. Podemos usar sensores CCD, que son similares a los que podemos encontrar en cámaras de fotos pero con un amplificador óptico integrado que mejora su sensibilidad.\nUna técnica que se suele usar es la Multiplicación de electrones. Mediante esta técnica podemos observar la luz emitida por los átomos del registro y obtener el estado final del ordenador tras el cálculo.\n"},"Medición-qubits-Proyección":{"slug":"Medición-qubits-Proyección","filePath":"Medición qubits-Proyección.md","title":"Medición qubits-Proyección","links":["producto-interno","Proyectores","Observables"],"tags":[],"content":"Medición qubits-Proyección\nOperadores proyección para la medida\nPara cualquier subespacio S \\subset V, el subespacio S^\\bot esta formado por todos los vectores que son perpendiculares a los vectores en S. Estos subespacios satisfacen que V =S \\oplus S^\\bot y por lo tanto, cualquier vector \\vec{v} \\in V se puede escrbrir como suma de los vectores \\vec{s_{1}}\\in S y \\vec{s}_{2} \\in S^\\bot. Entonces definimos el operador de proyección P_{s} como: P_{s} : V \\mapsto S que envía \\vec{v} \\mapsto \\vec{s_{1}} .\nEl operador \\ket{\\Psi}\\bra{\\Psi} es el operador proyección en el subespacio generado por \\ket{\\Psi}. De forma general, para cualquier descomposición de suma directa V = S_{1}\\oplus S_{2}\\oplus \\dots \\oplus S_{k} en subespacios ortogonales, existen k operadores de proyección relacionados:P_{i}:V\\mapsto S_{i} \\text{ , donde }P_{i}\\ket{v}= \\vec{s_{1}} \\text{ siendo } \\ket{v} = \\vec{s_{1}}+\\vec{s_{2}}+\\dots+\\vec{s_{k}} \\text{ con } s_{i} \\in S_{i} \nUsando esta terminología, un dispositivo de medición con una descomposición asociada V = S_{1}\\oplus S_{2}\\oplus \\dots \\oplus S_{k} que actúa sobre el estado \\ket{\\psi} da como resultado el estado:\\ket{\\phi} = \\frac{P_{i}\\ket{\\psi}}{|P_{i}\\ket{\\psi}| }  \ncon una probabilidad |P_{i}\\ket{\\psi}|^2 .\nEn el caso de un qubit, el proyector \\ket{0}\\bra{0} aplicado sobre un estado \\ket{\\psi}, proporciona la componente de \\ket{\\psi} en el subespacio generado por \\ket{0}. Ejemplo, si \\ket{\\psi} = a\\ket{0}+b\\ket{1}, entonces:(\\ket{0}\\bra{0})\\ket{\\psi} = a \\braket{0|0}\\ket{0} + b\\braket{0|1}\\ket{0}= a \\cdot 1 \\cdot \\ket{0} + b \\cdot 0 \\cdot \\ket{1} = a\\ket{0}\nhemos utilizado propiedades del producto interno y Proyectores. Esto se puede generalizar a n qubits.\nMedición mecánica cuántica\nSea A un Observables con un conjunto de autovalores \\{a_{i}\\} y autoestados \\{\\ket{\\phi_{i}\\}} donde: A\\ket{\\phi_{i}} = a_{i}\\ket{\\phi_{}}\nAplicando el operador proyección P_{i} = \\sum_{k}\\ket{\\phi_{k}}\\bra{\\phi_{k}} donde \\ket{\\phi_{k}} son los autoestados de A correspondientes a a_{i}. El operador P_{i}, proyecta un estado arbitrario \\ket{\\psi} sobre un subespacio asociado al autovalor a_{i} así:P_{i}\\ket{\\psi}= \\sum_{k}\\braket{\\phi_{k}|\\psi}\\ket{\\phi_{k}} \nEntonces podemos expresar el estado \\ket{\\psi} como la combinación lineal de los autoestados de A : \\ket{\\psi} = \\sum_{i} c_{i}\\ket{\\phi_{i}}\ndonde c_{i} = \\braket{\\phi_{i}|\\psi} (coeficiente de expansión, número complejo)\nCuando medimos el observable, obtendremos uno de sus autovalores a_{i} como resultado. la probabilidad de medir a_{i} es:p(a_{i}) = |P_{i}\\ket{\\psi}|^2 = |c_{i}|^2 = |\\braket{\\phi_{i}|\\psi}|^2\nDespués de la medición el sistema colapsará al subespacio generado por los autovalores correspondientes al autovalor a_{i} resultante de la medición. Este nuevo estado en el sistema se describe como:\\ket{\\psi&#039;} = \\frac{P_{i}\\ket{\\psi}}{|P_{i}\\ket{\\psi}| }  \nEjemplo medición\nVamos a suponer un observable A con tres autovalores \\{a_{1},a_{2},a_{3}\\} con autoestados \\{\\ket{\\phi_{1}},\\ket{\\phi_{2}},\\ket{\\phi_{3}}\\}. El estado inicial se puede describir como:\\ket{\\psi} = c_{1}\\ket{\\phi_{1}}+c_{2}\\ket{\\phi_{2}} +c_{3}\\ket{\\phi_{3}}   \ndonde c_{i} = \\braket{\\phi_{i}|\\psi} al medir obtenemos el valor a_{1}  con una probabilidad |c_{1}^2| y el estado colapsa a:\\ket{\\psi&#039;} = \\ket{\\phi_{1}}   Siempre y cuando a_{1} no sea degenerado."},"Medida-del-estado-final":{"slug":"Medida-del-estado-final","filePath":"Medida del estado final.md","title":"Medida del estado final","links":[],"tags":[],"content":"Medida del estado final\nPara poder obtener el resultado del cálculo cuántico es necesario tener la capacidad de medir el estado del registro cuántico a nivel de qubits individuales.\nLa matriz densidad de la probabilidad de un qubit es:\n\\rho=p\\ket{0}\\bra{0}+1(1-p)\\ket{1}\\bra{1}+\\alpha \\ket{0}\\bra{1}+\\alpha^* \\ket{1}\\bra{0}\nLa mediada del qubit debería resultar en \\ket{0} con una probabilidad p y en \\ket{1} con una probabilidad 1-p , independientemente del valor \\alpha . Esta medida deber ser independiente del resto de qubits del sistema."},"Modelo-Ising":{"slug":"Modelo-Ising","filePath":"Modelo Ising.md","title":"Modelo Ising","links":["Modelo-Ising","QAOA"],"tags":[],"content":"Modelo Ising\nModelo que utiliza variables binaras del conjunto z \\in \\{-1,1\\} en vez de variables booleanas. El 0 booleano es el 1 en Ising y el 1 booleano es el -1 Ising, la conversión es:\nx_{i} = \\frac{1-z_{i}}{2}\nDefinir función objetivo con Hamiltoniano\nPara trabajar con este tipo de problemas vamos a trabajar con el Modelo Ising por ejemplo vamos a suponer un sistema de dos variables f(x_{i},x_{j}) entonces vamos a definir el siguiente Hamiltoniano.\n\\begin{pmatrix}\n  f(1,1) &amp; 0 &amp; 0 &amp; 0 \\\\\n  0 &amp; f(1,-1) &amp; 0 &amp; 0 \\\\\n  0 &amp; 0 &amp; f(-1,1) &amp; 0 \\\\ \n  0 &amp; 0 &amp; 0 &amp; f(-1,-1)\n\\end{pmatrix}\nNos gustaría encontrar lo siguiente:\n\\bra{z_{1},z_{2}}H \\ket{z_{1},z_{2}} = f(z_{1},z_{2})  \nEn nuestro ejemplo, si queremos obtener f(-1,1) lo que haremos será \\bra{10}H \\ket{10} = f(-1,1)\nDescomponer  exponencial de Hamiltoniano tipo Ising como puertas de Pauli\nVeremos como podemos construir e^{iH} como puertas de Pauli \\sigma_{z}, para utilizarlo en algoritmos cómo QAOA.\nSiendo H:\nH = \\sum_{i=1}^{n} \\alpha_{i} \\sigma_{i}^{z} + \\sum_{i=1}^{n} \\sum_{j=1}^{n}\\beta_{i,j}\\sigma_{i}^{z}\\sigma_{j}^{z}\nDe esta manera definimos e^{iH} como:\ne^{H} = \\exp\\left( \\sum_{i=1}^{n} \\alpha_{i} \\sigma_{i}^{z} + \\sum_{i=1}^{n} \\sum_{j=1}^{n}\\beta_{i,j}\\sigma_{i}^{z}\\sigma_{j}^{z} \\right) = \\prod_{i=1}^{n}e^{i \\alpha_{i}\\sigma_{i}^z}+  \\prod_{i,j=1}^{n}e^{i \\alpha_{i}\\sigma_{i}^z \\sigma_{j}^z}\nDe esta manera para construir el Hamiltoniano, solo nos hará falta construir \\exp(it \\sigma_{i}^z) y \\exp(it \\sigma_{i}^z \\sigma_{j}^z). Sabiendo que la exponencial de una matriz diagonal es igual a la exponencial de cada uno de sus elementos tenemos:\nConstruir \\exp(it \\sigma_{i}^z)\ne^{it} &amp; 0 \\\\\n0 &amp; e^{-it}\n\\end{pmatrix} = e^{-it}\\begin{pmatrix}\n1 &amp; 0 \\\\\n0 &amp; e^{-2it}\n\\end{pmatrix}$$\nEn particular esta expresión corresponde con la puerta $R_{z}$ aplicando una rotación de $-2t$ radianes.\n\n![[Pasted image 20240512111736.png]]\n\n### Construir $\\exp(it \\sigma_{i}^z \\sigma_{j}^z)$\n\nPara este caso necesitamos conocer estas propiedades:\n\n* Si una matriz es $P$ cumple que $P^2 =I$ (lo cumplen todas las puertas de Pauli), se cumple que :\n\t* $$e^{iPt} = \\cos(t)I + \\sin (t)P$$\n* La puerta CNOT se puede expresar como:\n\t* $$CNOT = \\ket{0}\\bra{0} \\otimes I + \\ket{1}\\bra{1}\\sigma^x     $$\n\nJugando con estas propiedades obtenemos:\n$$e^{it\\sigma^z \\sigma^z} = \\cos(t)I + \\sin (t)\\sigma^z \\otimes \\sigma^z$$\n\n\nQue si lo relacionamos con la definición de CNOT obtenemos el siguiente circuito:\n\n![[Pasted image 20240512112556.png]]\n\n\nDe esta manera hemos construido la exponencial del Hamiltoniano con puertas cuánticas unitarias."},"Modelo-de-clasificación":{"slug":"Modelo-de-clasificación","filePath":"Modelo de clasificación.md","title":"Modelo de clasificación","links":[],"tags":[],"content":"Modelo de clasificación\nUn modelo de clasificación buscamos ser capaces de predecir a que clase pertenece un objeto, en otras palabras cuál es la etiqueta de un vector de características dado.\nPara este tipo de problemas partimos de que existe una función f tal que sg(f(\\vec{x})) determinará la clase de nuestro objeto. La idea principal es establecer un candidato g(\\vec{\\theta }) a función f que depende de unos parámetros \\vec{\\theta} y, decidir cuales de estos parámetros aproximan a f. Una práctica habitual suele ser suponer que g es una función lineal que depende de los parámetros \\vec{\\theta}\ng(\\vec{\\theta})(\\vec{x}) = \\theta_{0}+\\theta_{1}x_{1}+\\theta_{2}x_{2}+\\dots + \\theta_{n}x_{n}\nUna vez establecido el modelo, el siguiente paso es determinar lo bien o mal que lo estamos haciendo, a través del error, que lo definiremos como el porcentaje de puntos mal clasificados:\nE(g(\\vec{\\theta})) = \\frac{1}{m}\\sum_{i=1}^m \\frac{{1-y_{i}sg(g(\\vec{\\theta})(\\vec{x_{i}}))}}{2}\nsiendo m el número de datos de los que disponemos para ajustar nuestro modelo. Podemos ir ajustando este modelo con algoritmos de optimización.\nEjemplo clasificación clásica\nEn este ejemplo ve como somos capaces de clasificar una serie de puntos separados por un hiperplano:\ngithub.com/mikealiende/Algortimos_Quantum/blob/main/QML/Clasificación%20clásica.ipynb\nEl limite lo encontramos para clasificar modelos cuyos datos no son linealmente separables, es decir que no se pueden cortar por un hiperplano, por ejemplo:\n\nEjemplo clasificación cuántica\nPara este tipo de datos que no son linealmente separables, podemos recurrir a la clasificación cuántica. El paso será crear un circuito variacional que vaya optimizando parámetros, en vez de buscar el estado de mínima energía, buscará el ansatz que mejor clasifique nuestros datos. Un posible modelo sería:\n\nEn el circuito podemos ver como estamos codificando los datos como parámetros de la propia puerta de rotación \\rightarrow codificación de fase. Este modelo debe dar un valor real, y en función del signo clasificarlo como elemento del tipo 1 o -1, por ello calcularemos el valor esperado sobre uno de los qubits. El valor esperado toma valores entre -1 y 1, por lo tanto es un gran candidato a función. La puerta CNOT se utiliza para pasar la información de primer qubit al segundo, porque solo medimos en el segundo.\nEjemplo de clasificador cuántico: github.com/mikealiende/Algortimos_Quantum/blob/main/QML/Clasificación%20cuántica.ipynb\n"},"Modelo-de-regresión":{"slug":"Modelo-de-regresión","filePath":"Modelo de regresión.md","title":"Modelo de regresión","links":[],"tags":[],"content":"Modelo de regresión\nA diferencia que los modelos de clasificación, en este caso el número de posibles etiquetas es infinito.\nLa regresión lineal es una técnica de modela estadístico usada para describir variables continuas en funciones de unos parámetros predictores, desde un punto de vista matemático:\ng(\\vec{\\theta})(\\vec{x}) = \\theta_{{0}}+\\theta_{1}x_{1}+\\theta_{2}x_{2}+\\dots +\\theta_{n}x_{n}\nSuponemos la existencia de una función f tal que dado un \\vec{x}, envía dicho punto en su correspondiente y buscado, la diferencia es que ahora y puede tomar cualquier valor. Por lo que nuestra función g con unos parámetros \\vec{\\theta} debe aproximarse a f.\nModelo de error de regresión\nLo siguiente que debemos hacer es definir un modelo de error que nos diga que tan bien está aproximando nuestra función. Lo que haremos será comprobar que tal aproxima en cada punto, ver la distancia que se lleva con el original.\nE(g(\\vec{\\theta})) = \\frac{1}{m}\\sum_{i=1}^m \\mid y_{i} -g(\\vec{\\theta})(\\vec{x_{i}}) \\mid^2\nDisminuyendo este error conseguimos disminuir la distancia con nuestro objetivo.\nEjemplo regresión cuántica\nEn este ejemplo veremos un modelo de regresión cuántica para aproximar f(x) = 3\\sin(x^2) a partir de varios puntos de esta función: github.com/mikealiende/Algortimos_Quantum/blob/main/QML/Regresión%20cuántica.ipynb\nEn este ejemplo usamos únicamente un qubit debido a que la dimensión del vector \\vec{x} es 1. Debemos tener en cuenta que el valor esperado de un qubit es un valor entre -1 y 1, pero como hemos visto f puede tomar valores fuera de este intervalo, por lo tanto, utilizamos variables auxiliares para reescalar. Entremos el modelo con algoritmos de optimización y tenemos:\n\nLos resultados comparados con una regresión clásica cuadrática del tipo g(\\vec{\\theta})(x) = \\theta_{0}+x\\theta_{1}+x^2 \\theta_{2} son prometedores.\nEstimar \\pi con un algoritmo de regresión cuántico\nUtilizando un qubit, el valor esperado lo podemos definir como la probabilidad de medir \\ket{0} menos la probabilidad de medir \\ket{1}. Por lo tanto si tomamos esta función como nuestra función objetivo, f = P(\\ket{0}) - P(\\ket{1}), esta función tendrá un mínimo cuando la probabilidad de medir \\ket{1} sea máxima. Por lo tanto partiendo de un estado \\ket{0} en esfera de Bloch, y deseamos llegar a \\ket{1}, debemos aplicar una rotación en el eje X de exactamente \\pi radianes. Por lo tanto, nuestra nuestro circuito a optimizar será R_{x}(\\theta) y sabemos que será mínima cuando \\theta = \\pi, por lo tanto al minimizarlo obtendremos el valor de \\pi.\nRepresentando la probabilidades del qubit de manera gráfica:\n\nPor lo tanto si con un optimizar buscamos el valor de \\theta que minimice nuestra función, aproximaremos \\pi\nCódigo: github.com/mikealiende/Algortimos_Quantum/blob/main/QML/EstimarPI.ipynb"},"Modelos-concurrentes":{"slug":"Modelos-concurrentes","filePath":"Modelos concurrentes.md","title":"Modelos concurrentes","links":["Autómatas-celulares","Puertas-lógicas-y-circuitos-lógicos"],"tags":[],"content":"Modelos concurrentes\nLos modelos concurrentes describen como se comportan sistemas con múltiples tareas o procesos que se ejecutan, aparentemente, al mismo tiempo. Estos modelos gestionan la la comunicación e interacción entre las tareas incluyendo acceso compartido a recursos y la sincronización.\n\nAutómatas celulares\nPuertas lógicas y circuitos lógicos\n"},"Modelos-de-computación-deterministas":{"slug":"Modelos-de-computación-deterministas","filePath":"Modelos de computación deterministas.md","title":"Modelos de computación deterministas","links":["Modelos-secuenciales","Modelos-funcionales","Modelos-concurrentes"],"tags":[],"content":"Modelos de computación deterministas\nEn los modelos de computación deterministas, el resultado viene unívocamente determinado por la entradas y los estados internos del autómata. Vamos a distinguir los siguientes modelos deterministas:\n\nModelos secuenciales\nModelos funcionales\nModelos concurrentes\n"},"Modelos-de-computación-no-deterministas":{"slug":"Modelos-de-computación-no-deterministas","filePath":"Modelos de computación no deterministas.md","title":"Modelos de computación no deterministas","links":[],"tags":[],"content":""},"Modelos-de-computación":{"slug":"Modelos-de-computación","filePath":"Modelos de computación.md","title":"Modelos de computación","links":["tags/Tema","Modelos-de-computación-deterministas","Modelos-de-computación-no-deterministas"],"tags":["Tema"],"content":"Modelos de computación Tema\nUn modelo de computación describe como se computa la salida de una función dada una entrada. Además de como se organizan las unidades de computación y las unidades de memoria. El uso de modelos permite calcular la complejidad computacional de un algoritmo. Podemos clasificar estos modelos en:\n\nModelos de computación deterministas\nModelos de computación no deterministas\n"},"Modelos-funcionales":{"slug":"Modelos-funcionales","filePath":"Modelos funcionales.md","title":"Modelos funcionales","links":["Cálculo-Lambda","Funciones-generales-recursivas","Lógica-combinatoria"],"tags":[],"content":"Modelos funcionales\nLos modelos funcionales son una representación estructuradas de las funciones de un sistema. En el caso de computación, se caracterizan por usar variables como elementos de programación.\n\nCálculo Lambda\nFunciones generales recursivas\nLógica combinatoria\n"},"Modelos-secuenciales":{"slug":"Modelos-secuenciales","filePath":"Modelos secuenciales.md","title":"Modelos secuenciales","links":["Máquinas-de-estados-finitos","Autómatas-de-pila","Máquinas-de-acceso-aleatorio-RAM"],"tags":[],"content":"Modelos secuenciales\nSon aquellos en los que las instrucciones se ejecutan en secuencia, decir una tras otra. Puede haber ramas de programa, pero por lo general, cada instrucción sigue la anterior. Veremos:\n\nMáquinas de estados finitos\nAutómatas de pila\nMáquinas de acceso aleatorio RAM\n"},"Modos-fotónicos-como-qubits":{"slug":"Modos-fotónicos-como-qubits","filePath":"Modos fotónicos como qubits.md","title":"Modos fotónicos como qubits","links":["Computación-cuántica-con-fotones"],"tags":[],"content":"Modos fotónicos como qubits\nPara poder tener un Computación cuántica con fotones, lo primero que necesitamos es disponer de una base computacional \\{\\ket{0}, \\ket{1}\\}, sobre la cual se pueda realizar cualquier operación que pueda ser expresada como un conjunto de rotaciones parametrizadas por dos ángulos \\theta y \\phi:\n\\ket{0}&amp;\\rightarrow \\cos \\theta \\ket{0} + e^{i\\phi}\\sin \\theta \\ket{1}  \\\\\n\\ket{1}&amp;\\rightarrow e^{i\\phi}\\sin \\theta\\ket{0} + \\cos \\theta \\ket{1}   \n\\end{align}$$\n\nDel fotón no podemos expresar una función de onda, pero podemos identificar distintos modos ópticos o grados de libertad que podemos usar como qubits.\n\n## Creación y aniquilación\n\nLa absorción y emisión de fotones con un momento $k$ pueden ser descritos por las operaciones de creación y aniquilación $\\hat{a}(k)$ y $\\hat{a}^{\\dagger}(k&#039;)$  que actúan sobre el estado cuántico de un fotón $\\ket{n}$ de esta forma:\n$$\\begin{align}\n\\hat{a}\\ket{n} &amp; =\\sqrt{  n}\\ket{n-1} \\\\\n\\hat{a^{\\dagger}}\\ket{n} &amp; =\\sqrt{n+1}\\ket{n+1}  \n\\end{align}$$\nA partir de ellos se puede definir el operador $\\hat{n}(k) = \\hat{a}^{\\dagger}(k)\\hat{a}(k)$ tal que:\n$$\\hat{n}\\ket{n}= n\\ket{n}$$\nPara cualquier modo dado con momento $k$\n\n### Relaciones de conmutación operadores creación y aniquilación\nLas relaciones de conmutación de los operadores de creación y aniquilación son las canónicas de este tipo de operadores:\n$$\\begin{align}\n[\\hat{a}(k),\\hat{a}^{\\dagger}(k&#039;)] &amp;= \\delta(k-k&#039;) \\\\\n[\\hat{a}(k),\\hat{a}(k&#039;)] &amp;= [\\hat{a}^{\\dagger}(k),\\hat{a}^{\\dagger}(k&#039;)] = 0\n\\end{align}$$"},"Momento-angular-clásico":{"slug":"Momento-angular-clásico","filePath":"Momento angular clásico.md","title":"Momento angular clásico","links":["Momento-angular-cuántico"],"tags":[],"content":"Momento angular clásico\nEl momento angular o momento cinético es una magnitud física, equivalente rotacional del momento lineal. Es una cantidad vectorial que caracteriza las propiedades de inercia de un cuerpo, que gira en relación con cierto punto.\n\nPodemos intuir el Momento angular cuántico mediante los operadores cuánticos de posición y momento lineal."},"Momento-angular-cuántico":{"slug":"Momento-angular-cuántico","filePath":"Momento angular cuántico.md","title":"Momento angular cuántico","links":[],"tags":[],"content":"Momento angular cuántico\n\n"},"Momento-angular":{"slug":"Momento-angular","filePath":"Momento angular.md","title":"Momento angular","links":["tags/Tema","Momento-angular-clásico","Momento-angular-cuántico","Conmutación-momento-angular","Valores-propios-momento-angular","Representación-matricial-momento-angular"],"tags":["Tema"],"content":"Momento angular Tema\nIndice\nMomento angular clásico\nMomento angular cuántico\nConmutación momento angular\nValores propios momento angular\nRepresentación matricial momento angular"},"Módulo":{"slug":"Módulo","filePath":"Módulo.md","title":"Módulo","links":[],"tags":[],"content":"Módulo o magnitud\n"},"Multiplicación-de-electrones":{"slug":"Multiplicación-de-electrones","filePath":"Multiplicación de electrones.md","title":"Multiplicación de electrones","links":[],"tags":[],"content":"Multiplicación de electrones\nTécnica en el que los electrones generado por la luz incidente son acelerados en cada pulso de reloj de un sensor CCD, lo que provoca ionización por impacto del material de los píxeles y genera electrones secundarios que contribuyen a la señal.\n\nLa ventaja es que se provoca una multiplicación de electrones en el propio sensor, antes de la amplificación convencional, lo que previene la amplificación de ruido no deseado, estos sensores son capaces de detectar una iluminación muy tenue, tanto que debidamente aisladas y operando a baja temperatura son capaces de detectar luz de fuentes de fotones individuales."},"Máquinas-de-Turing-universales":{"slug":"Máquinas-de-Turing-universales","filePath":"Máquinas de Turing universales.md","title":"Máquinas de Turing universales","links":[],"tags":[],"content":"Máquinas de Turing universales\nUna máquina de Turing universal puede computar lo que cualquier máquina de Turing específica computa. Cualquier problema que no sea computable por la máquina de Turing universal se considera incomputable.\nEl problema principal de la máquina de Turing es que se debe construir una máquina para cada computación que se realice. Son máquina de propósito específico. Para salvar esta limitación están las máquinas de Turing universales.\nLa máquina de Turing universal, junto a la entrada en la cinta toma la descripción de una máquina M. Eso permite a la máquina de Turing universal simular M.\n\nSon máquinas abstractas capaces de ejecutar todos los algoritmos posibles.\nRelación con la computación cuántica.\nUna máquina de Turing cuántica contaría con:\n\nUn procesador finito: Unidad de control, misma funcionalidad que en el modelo clásico. Tiene P qubits.\nMemoria infinita: Misma función que la cinta en el modelo clásico.\nCursor: Componente que interactua sobre el procesador y la unidad de memoria. Su posición es escaneada por una variable compleja x tal que:x \\in \\mathbb{H}_{c}\nDonde \\mathbb{H}_{c} es el espacio de Hilbert asociado.\n\nNo está claro para que pueden servir las máquinas de Turing cuánticas."},"Máquinas-de-acceso-aleatorio-RAM":{"slug":"Máquinas-de-acceso-aleatorio-RAM","filePath":"Máquinas de acceso aleatorio RAM.md","title":"Máquinas de acceso aleatorio RAM","links":[],"tags":[],"content":"Máquinas de acceso aleatorio RAM\nSon máquinas abstractas dentro de la clase de máquinas de registros. Las RAM se pueden modelar mediante dos máquinas de estados finitos síncronas, una CPU y una memoria de acceso aleatorio.\n\nLa CPU implementa un ciclo de búsqueda y ejecución en el que alternativamente lee una instrucción de un programa almacenado en la memoria RAM. Por lo general, las instrucciones se leen y se ejecutan desde ubicaciones consecutivas en la memoria RAM. Una CPU tiene 5 tipos básicos de instrucción:\n\nInstrucciones aritméticas y lógicas.\nInstrucciones de almacenamiento y carga de memoria, mover datos entre ubicaciones de memoria y registros.\nInstrucciones de salto para romper fuera de la secuencia del programa actual.\nInstrucciones de entrada/salida.\nInstrucciones de parada.\n\nUna memoria RAM tiene una palabra de salida (out wrd) y tres palabras de entrada (dirección (addr), palabra de datos (en wrd) y comando (cmd))\nEl comando especifica una de las tres acciones:\n\nLeer desde una ubicación de memoria.\nEscribir desde una ubicación de memoria.\nNo hace nada\n"},"Máquinas-de-estados-finitos":{"slug":"Máquinas-de-estados-finitos","filePath":"Máquinas de estados finitos.md","title":"Máquinas de estados finitos","links":[],"tags":[],"content":"Máquinas de estados finitos\nUn máquina de estados finitos opera sobre una entrada para producir una salida. Este modelo se puede representar como una quíntupla M=(Q, \\Sigma,q{0},\\delta,F), esta conformado por:\n\nAlfabeto: \\Sigma\nConjunto de estados finito: Q. Se representan como vértices\nFunción de transición: \\delta:Q\\times\\Sigma \\rightarrow Q. Es una transición de un estado a otro en función del valor del símbolo. Se representa como una arista que une los vértices.\nEstado inicial: q{0}\nConjunto de estados finales: F \\in Q. Se representan mediante vértices que están encerrados por otra circunferencia.\n\nLa función de transición recibe, a partir de un estado inicial, una cadena de caracteres perteneciente al alfabeto (entrada), y va leyendo dicha cadena a medida que la máquina se desplaza de un estado a otro. Finalmente se detiene un estado final que representa la salida. Se representan usando Diagramas de estados:\n\nTablas de transiciones\nTambién se pueden representar con tablas de transiciones o matrices de estados. Una posible tabla de transición para el ejemplo de arriba sería\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSalidaSimboloLlegadaS_{1}0S_{2}S_{1}1S_{1}S_{2}0S_{1}S_{2}1S_{2}"},"Norma":{"slug":"Norma","filePath":"Norma.md","title":"Norma","links":["Espacios-Prehilbert","producto-interno"],"tags":[],"content":"Norma\nPara un Espacios Prehilbert, con producto interno definimos la norma cómo:\n\nEjemplos\nNorma Vectores\n\n\nNorma de matrices\n"},"Notación-de-Dirac":{"slug":"Notación-de-Dirac","filePath":"Notación de Dirac.md","title":"Notación de Dirac","links":["tags/Tema","Base-C"],"tags":["Tema"],"content":"Notación de Dirac Tema\nIntroducción\nNotación de Dirac o braket, usada para representar vectores en mecánica cuántica\n\nKet\n\nBra\n\nBraket\n\nBase C"},"Números-complejos":{"slug":"Números-complejos","filePath":"Números complejos.md","title":"Números complejos","links":["tags/Tema","Aritmética-de-números-complejos","Potencias-complejas","Funciones-complejas"],"tags":["Tema"],"content":"Números complejos Tema\nIndice\nAritmética de números complejos\nPotencias complejas\nFunciones complejas"},"Observables-equivalentes":{"slug":"Observables-equivalentes","filePath":"Observables equivalentes.md","title":"Observables equivalentes","links":[],"tags":[],"content":"Observables equivalentes\n"},"Observables":{"slug":"Observables","filePath":"Observables.md","title":"Observables","links":["Operadores","estado-puro","estado-mixto"],"tags":[],"content":"Observables\nUn observable es una magnitud física que puede medirse. Cada magnitud, tiene un Operadores asociado.\nDe forma que al actuar dicho operador sobre un estado puro y obtiene un valor real, y el estado no queda modificado. Si es el operador actúa sobre un estado mixto, también se obtiene un valor real, pero ahora el estado si queda modificado.\nEstado del sistema\n\n\nValor esperado\n"},"Operador-densidad-sistemas-spin-un-medio":{"slug":"Operador-densidad-sistemas-spin-un-medio","filePath":"Operador densidad sistemas spin un medio.md","title":"Operador densidad sistemas spin un medio","links":[],"tags":[],"content":"Operador densidad sistemas spin un medio"},"Operadores-Unitarios":{"slug":"Operadores-Unitarios","filePath":"Operadores Unitarios.md","title":"Operadores Unitarios","links":[],"tags":[],"content":"Operadores Unitarios\n"},"Operadores-escalera":{"slug":"Operadores-escalera","filePath":"Operadores escalera.md","title":"Operadores escalera","links":[],"tags":[],"content":"Operadores escalera"},"Operadores-normales":{"slug":"Operadores-normales","filePath":"Operadores normales.md","title":"Operadores normales","links":[],"tags":[],"content":"Operadores normales\n"},"Operadores-positivos":{"slug":"Operadores-positivos","filePath":"Operadores positivos.md","title":"Operadores positivos","links":[],"tags":[],"content":"Operadores positivos\n"},"Operadores":{"slug":"Operadores","filePath":"Operadores.md","title":"Operadores","links":["conmutador","operadores-hermíticos","Operadores-positivos","Operadores-Unitarios","Operadores-normales","operadores-hermitico-unitarios"],"tags":[],"content":"Operadores en mecánica cuántica\nEn mecánica cuántica, los operadores estás asociados a una magnitud medible.\nUn operador X que actúa sobre un ket\n\nOperador X actúa sobre un bra\n\nPropiedades\n1. Forma de Jordan\nUn operador lineal, siempre se puede expresar como la sima de un operador hermítico y uno anti hermitico --&gt; X = A(hermítico) + B(antihermítico)\n\n2. \tUna combinación lineal de operadores hermíticos, siempre es hermítica\n3. El el producto de dos operadores es anticonmutativo\n![[Pasted image 20240217132646.png]]\n\n4. El conmutador [X,Y] es antihermítico\n![[Pasted image 20240217132750.png]]\n\n5. Descomposición del producto de dos operadores\n![[Pasted image 20240217132851.png]]\n\nAutovalores y Autovectores\n\nLos autovalores correspondientes a operadores hermíticos son siempre reales.\nClasificación de operadores\n\nOperadores positivos\noperadores hermíticos\nOperadores Unitarios\nOperadores normales\noperadores hermitico-unitarios\n"},"Optimización-en-Hamiltonianos-genéricos":{"slug":"Optimización-en-Hamiltonianos-genéricos","filePath":"Optimización en Hamiltonianos genéricos.md","title":"Optimización en Hamiltonianos genéricos","links":["tags/Tema","Modelo-Ising","Adaptación-Hamiltoniano-genérico-VQE","Adaptación-exponencial-de-Hamiltoniano-genérico-QAOA-y-EVA","Trotterización"],"tags":["Tema"],"content":"Hamiltonianos Genéricos Tema\nHasta este punto hemos trabajado con Hamiltonianos de Modelo Ising que esta compuesto sólo por puertas de Pauli Z \\sigma^z el objetivo de este tema será como construir un Hamiltoniano que contenga las tres puertas de Pauli \\sigma^x, \\sigma^y y \\sigma^z . De esta manera:\nH = \\sum_{k \\in \\{x,y,z \\}}\\sum_{l \\in \\{x,y,z \\}}\\sum_{i,j}\\alpha_{ij}\\sigma_{i}^k\\sigma_{j}^l +\\sum_{k \\in \\{x,y,z \\}}\\sum_{i}\\beta_{i}\\sigma_{i}^k\nEmpezaremos por Adaptación Hamiltoniano genérico VQE y seguiremos con Adaptación exponencial de Hamiltoniano genérico QAOA y EVA que gracias a la Trotterización, seremos capaces de construir con puertas cuánticas cualquier Hamiltoniano y su exponencial."},"Oscilaciones-de-Rabi":{"slug":"Oscilaciones-de-Rabi","filePath":"Oscilaciones de Rabi.md","title":"Oscilaciones de Rabi","links":["Estado-excitado","Estado-fundamental"],"tags":[],"content":"Oscilaciones de Rabi\nSi iluminamos un átomo con una excitación periódica, como puede ser un láser:\n\nEl átomo absorbe los fotones incidentes.\nPasa al Estado excitado.\nReemite los fotones absorbidos.\nSe relaja a  su Estado fundamental.\n\nEsto se repite periódicamente con una frecuencia \\Omega , en el llamado régimen de emisión estimulada.\nSi consideramos un átomo con un estado fundamental \\ket{0} y un estado excitado \\ket{1},  e iluminado con la energía de resonancia de la transición entre ambos estados, la probabilidad de encontrar el átomo en el estado \\ket{1} pasado un tiempo t será:\nP(\\ket{1} ) \\propto (\\Omega t)\nDonde \\Omega es la frecuencia de Rabi.\n"},"Oscilador-armónico-cuántico":{"slug":"Oscilador-armónico-cuántico","filePath":"Oscilador armónico cuántico.md","title":"Oscilador armónico cuántico","links":["circuito-LC"],"tags":[],"content":"Oscilador armónico cuántico\nSi definimos los operadores cuánticos flujo (\\phi) y carga (q) podemos hacer un paralelismo entre la energía eléctrica y magnética del circuito LC:\nE_{c} &amp;= \\frac{1}{2}CV^2 = \\frac{q^2}{2C} \\\\\nE_{{L}} &amp;= \\frac{1}{2}LI^2 = \\frac{\\phi^2}{2L}\n\\end{align}$$\n\nUn candidato a ser nuestro qubit podría ser un circuito LC cuántico, entonces los niveles de energía del sistema podrían constituir nuestro sistema cuántico a dos niveles. El problema es que los niveles de energía están degenerados, es decir no podemos distinguir entre pasar del estado 0 al 1 o del 2 al 3, por lo tanto no pude constituir nuestro sistema cuántico a dos niveles. \n![[Pasted image 20240514184544.png | 300]]\n\n\nPara solucionar esto, aparece la [[Unión Josephson]]"},"Paradoja-EPR":{"slug":"Paradoja-EPR","filePath":"Paradoja EPR.md","title":"Paradoja EPR","links":["entrelazamiento","Desigualdades-de-Bell"],"tags":[],"content":"Paradoja EPR\nParadoja de Einstein Podolsky Rosen que dice que un sistema en entrelazamiento se puede modificar el estado total del sistema manipulando tan solo una de las partículas. Es decir, operando sobre una de las partículas se puede modificar el estado de la otra a distancia de manera instantánea. Esto indica una correlación entre las dos partículas que no tiene lugar en el mundo clásico.\nSegún la paradoja EPR esto ocurre porque hay variables que no se han tenido en cuenta, esto es existe un conjunto de variables ocultas que no han entrado en el cálculo.\nEl enunciado de la paradoja EPR introduce el término elemento de realidad. Hay un elemento de realidad detrás de cada variable que puede medirse sin afectar al estado del sistema.\nLa paradoja EPR se basa en dos conceptos clave:\n\nCriterio de completitud: Una teoría es completa si todo elemento de realidad tiene su contraparte en la teoría.\nPrincipio de localidad: Si no existe interacción es imposible que la medida de un sistema afecte a otro.\n\nPara desmontar la paradoja EPR, se propusieron las Desigualdades de Bell"},"Paridad":{"slug":"Paridad","filePath":"Paridad.md","title":"Paridad","links":[],"tags":[],"content":"Paridad\n"},"Phase-Kickback":{"slug":"Phase-Kickback","filePath":"Phase Kickback.md","title":"Phase Kickback","links":["Algoritmo-de-Deutsch","Quantum-Phase-Estimation","Transformada-cuántica-de-Fourier-QFT"],"tags":[],"content":"Phase Kickback\nPhase Kickback o rebote de fase, hace referencia al fenómeno por el cual las operaciones controladas, como CNOT, tienen efecto en sus qubits de control además de en los qubits objetivo.Parte de la información fase del qubit objetivo se transfiere al qubit de control y se almacena en la fase relativa. En puertas controladas, la fase del qubit objetivo esta condicionada por el estado del qubit de control, debido al entrelazamiento la fase “rebota” del qubit de objetivo al de control . Esta característica  es una ventaja de la computación cuántica y se utiliza en algoritmos como: Algoritmo de Deutsch, Quantum Phase Estimation, Transformada cuántica de Fourier QFT(completar con más algoritmos)\nVamos a ver un ejemplo de entrelazamiento en el que no se produce phase kickback y otro en el que si.\nEntrelazamiento con Phase Kickback\nRequisitos Phase kickback\nPara que se de el fenómeno de Phase kickback, se deben cumplir una serie de requisitos:\n\nLos qubits de control deben estar en superposición. Si no es así, el “rebote” de fase afectará a la fase global que no tiene significado físico.\nEl estado \\ket{\\psi} del qubit objetivo, debe ser un autovector del operador controlado U. Ya que de esta manera se cumple U\\ket{\\psi} = e^{i\\phi}\\ket{\\psi}, y entonces e^{i\\phi} se transfiere al qubit de control.\nEl operador U se debe aplicar de forma controlada\n\nEjemplo Phase Kickback Operador general U\nVamos a considerar un sistema de 2 qubits: \\ket{c} el qubit de control y \\ket{t} el qubit objetivo. Y vamos a tener el operador unitario U. Si aplicamos este operador a nuestro circuito de manera controlada tenemos:\n\\ket{1}U\\ket{t} \\text{ si } c =1    \n\\end{cases}  $$\nComo hemos dicho antes, para que se produzca phase kickback, el estado $\\ket{t}$ debe ser un autovector del operador $U$ con el autovalor asociado $e^{i\\phi}$. Es decir:$$U\\ket{t} = e^{i\\phi}\\ket{ t}  $$\nSi se cumplen estas condiciones tenemos: $$C\\text{-}U\\ket{c}\\ket{t} = e^{i\\phi c}\\ket{c}\\ket{t}    $$\n\nOtra de las condiciones es que los qubits de control estén en superposición, lo que conseguimos aplicando una puerta H y mandando a $\\ket{c}$ al estado $\\ket{+} = \\frac{1}{\\sqrt{ 2 }}\\ket{0}+\\ket{1}$. Con esto el estado que tendríamos es:$$C\\text{-}U\\ket{+}\\ket{t} = \\frac{1}{\\sqrt{ 2 }}(\\ket{0}\\ket{t} +e^{i\\phi }\\ket{1}\\ket{t}   )  $$\nSi factorizamos $\\ket{t}$ nos queda:$$C\\text{-}U\\ket{+}\\ket{t} = \\frac{1}{\\sqrt{ 2 }}(\\ket{0} +e^{i\\phi }\\ket{1})\\otimes \\ket{t} = \\ket{+\\phi}\\otimes \\ket{t}$$\nSiendo $\\ket{+\\phi}= \\frac{1}{\\sqrt{ 2 }}(\\ket{0}+e^{i\\phi}\\ket{1})$, vemos claramente que la fase $e^{i\\phi}$ ha &quot;rebotado&quot; del qubit objetivo al qubit de control. El circuito que hemos descrito sería:\n\n![[Pasted image 20250126120739.png|400]]\n\n\n\n### Ejemplo con C-NOT\n\nSi colocamos también el qubit objetivo en superposición, la puerta CNOT actuaria ahora sobre $\\ket{++}$ (superposición uniforme de los 4 estados estados de la base), esto no produciría ningún cambio, pero si aplicamos la CNOT al estado $\\ket{+ - }$ el resultado es $\\ket{--}$. Es un resultado muy interesante, dado que el qubit objetivo permanece sin cambios, pero en cambio el qubit de control tiene ahora fase negativa. De alguna manera se ha transferido la fase del qubit objetivo al qubit de control. Demostración matemática:\n\n![[Pasted image 20250119123258.png]]\n\n1. Partimos del estado $\\ket{00}$\n\n2. Aplicamos X al segundo qubit $I\\otimes X\\ket{00}\\rightarrow \\ket{01}$\n\n\n3. Aplicamos H a ambos qubits:$$\\begin{align}\n&amp;\\left[ \\frac{1}{\\sqrt{ 2 }}(\\ket{0}+\\ket{1}  ) \\right]\\left[ \\frac{1}{\\sqrt{ 2 }}(\\ket{0}-\\ket{1}  ) \\right]= \\\\ \\\\\n=&amp;\\frac{1}{2}(\\ket{00}-\\ket{01} +\\ket{10}-\\ket{11}   )= \\ket{+ -} \n\\end{align}$$\n4. Aplicamos la puerta CNOT:$$\\begin{align}\n&amp;\\frac{1}{2}(\\ket{00}-\\ket{01} +\\ket{11}-\\ket{10}   )+ \\\\ \\\\\n&amp;\\frac{1}{2} ([\\ket{0}(\\ket{0}-\\ket{1}) + \\ket{1}(\\ket{1}-\\ket{0} ))= \\\\ \\\\\n&amp;\\frac{1}{2} (\\ket{0}\\ket{-}-\\ket{1}\\ket{-}) = \\ket{-}\\ket{-} = \\ket{--}   \n\\end{align}$$\n\n\nUn aspecto clave para la aplicación es que el estado en el que se encuentra el qubit objetivo debe ser un autovector de la puerta correspondiente de la operación de control. Lo que se pretende con ello es que la aplicación de la aplicación al qubit objetivo no cambie su estado, si no que añada una fase a su estado.\n\nPor lo tanto, aplicar el operador $U$ al qubit objetivo supondría: $U\\ket{\\psi} = e^{i\\phi}\\ket{\\psi}$. Este valor $e^{i\\phi}$ que multiplica al estado es el que será propagado al qubit de control.\n\n### Entrelazamiento sin Phase Kickback\n\n\n![[Pasted image 20250119122348.png]]\n\nEn este caso no se va a producir Phase kickback porque el estado del qubit objetivo no es un autovector de C-NOT \n\n1. Empezamos en el estado $\\ket{00}$\n\n2. Aplicamos H al primer qubit $\\rightarrow \\frac{1}{\\sqrt{ 2 }}(\\ket{0}+\\ket{1})\\ket{0}=\\frac{1}{\\sqrt{ 2}}\\ket{00}+\\ket{10}$\n\n3. Aplicamos puerta CNOT $\\rightarrow \\frac{1}{\\sqrt{ 2}}\\ket{00}+\\ket{11}$"},"Postulados-de-la-mecánica-cuántica":{"slug":"Postulados-de-la-mecánica-cuántica","filePath":"Postulados de la mecánica cuántica.md","title":"Postulados de la mecánica cuántica","links":["tags/Tema","Principio-de-incertidumbre","Ecuación-de-Shrödinger","Interpretaciones-de-la-mecánica-cuántica","Paradoja-EPR","Observables","operador-densidad"],"tags":["Tema"],"content":"Postulados de la mecánica cuántica Tema\nIndice\nPrincipio de incertidumbre\nEcuación de Shrödinger\nInterpretaciones de la mecánica cuántica\nParadoja EPR\nPostulados\nPostulado 1. Estado cuántico\nEl estado de un sistema físico cerrado S se describe totalmente mediante un vector unitario |ψ⟩, que denominamos vector de estado o función de onda. Este vector forma parte de un espacio de Hilbert separable HS asociado al sistema.\nA cada sistema físico descrito en el marco de la Mecánica Cuántica le corresponde un espacio de Hilbert complejo y separable. Por tanto, cada sistema cuántico lleva aso- ciado un Espacio de Hilbert en el que se definen todos los posibles estados que puede adoptar dicho sistema. La forma en la que se definen los estados del sistema en el Espacio de Hilbert es mediante un vector complejo, es decir, cada vector complejo del Espacio de Hilbert es posible estado del sistema al que está asociado.\nEn el campo de la computación cuántica, el sistema cuántico con el que se trata es el denominado qubit (quantum bit), y por tanto, el espacio de Hilbert asociado es de dos dimensiones. Esto significa que el espacio de Hilbert está formado por dos vectores base y que cualquier estado se puede representar como una combinación lineal de estos dos vectores base. Si los vectores base se representan mediante |v1⟩ y |v2⟩, entonces, cualquier estado general |ψ⟩ del sistema se puede representar como:\n\nPostulado 2. Observables\nCualquier variable dinámica del sistema que es susceptible de ser medida, se denomina observable, y se representa mediante un operador, por ejemplo O. Si en un sistema descrito por el vector de estado |ψ⟩ se realiza una medida del observable O y se obtiene el resultado an, entonces, después de la medida, el estado del sistema viene dado por:\n\ndonde Pn es el operador proyección sobre el subespacio correspondiente a an.\nEl valor medio de una variable dinámica O (que puede representar un observable) en\nel conjunto de estados igualmente preparados representados por el operador ρ es:\n\nCuando se realiza la medida del observable, el sistema (según la interpretación de Copenhagen) se proyecta sobre uno de los autoestados posibles y proporciona el autovalor asociado a ese autoestado.\nEn Mecánica Cuántica, el valor de un observable es incierto, se cree que un estado se encuentra en un estado de superposición coherente de todos los autoestados posibles del observable.\nPostulado 3. Evolución\nCada observable A tiene asociado un operador auto-adjunto A en el espacio de Hilbert HS, y el único valor posible que se puede obtener al realizar una medida del observable A es alguno de los autovalores del operador A.\nLa evolución de un sistema cuántico cerrado viene descrita por una transformación unitaria. Esto quiere decir que, el estado |ψ⟩ del sistema en el instante t1 está relacio- nado con el estado |ψ′⟩ del sistema en el instante t2 mediante un operador U que solo depende de los instantes t1 y t2.\nUn estado del espacio de Hilbert se representa por un operador ρ, también llamado operador densidad, no negativo, autoadjunto y de traza unidad. Los observables también serán operadores autoadjuntos, y sus autovalores serán los posibles valores de las magnitudes físicas.\nLa Ecuación de Shrödinger es una ecuación diferencial que proporciona una descripción de un sistema cuántico aislado y da cuenta de su evolución temporal.\nPostulado 4. Medidas\nSi un operador 𝐴 asociado a un observable físico 𝔸 tiene una base propia 𝛼 y valores propios {ai } y el estado del sistema es Ψ 𝑥 antes de realizar una medida.\nSolo podemos predecir la probabilidad de que el valor de la medida de 𝐴 sea el valor propio ak\n\nTema 5. Descomposición espectral\n"},"Potencias-complejas":{"slug":"Potencias-complejas","filePath":"Potencias complejas.md","title":"Potencias complejas","links":[],"tags":[],"content":"Potencias complejas\nElevar a un número positivo\n\nElevar a un número negativo\n\nElevar a una fracción (raices)\n\nElevar a un número racional\n\nEjemplo\n"},"Principio-Variacional":{"slug":"Principio-Variacional","filePath":"Principio Variacional.md","title":"Principio Variacional","links":["Quantum-Support-Vector-Machine"],"tags":[],"content":"Principio Variacional\nEl principio variacional es aquel que permite resolver un problema utilizando el cálculo de variaciones, que se refiere a encontrar funciones que optimicen los valores de las cantidades que dependen de esas funciones.\nQSVM Variacional\nVamos a utilizar el principio variacional en el algoritmo Quantum Support Vector Machine para crear un circuito variacional que defina nuestro kernel. Un circuito de este tipo no es más que una serie de puertas que dependen de unos parámetros \\vec{\\theta}, los cuales se irán adaptan en función de unos resultados obtenidos con el objetivo de crear el mapa característico que mejor se adapte a nuestro problema.\nJuntando todas las piezas derivadas hasta el momento llegamos a la expresión fundamental de nuestro QSVM variacional:\nL&#039;= -\\sum_{i=1}^m\\alpha_{i}+\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m \\alpha_{i}\\alpha_{j}f(\\vec{x_{i}})f(\\vec{x_{j}})\\mathbb{R}(\\bra{0}^{\\otimes n}U^{\\dagger}_{\\vec{x_{j}},\\vec{\\theta}}U_{\\vec{x_{i}},\\vec{\\theta}}\\ket{0}^{\\otimes n})\nSiendo U_{\\vec{x_{i}},\\vec{\\theta}} nuestro nuevo mapa de características condicionado por \\vec{\\theta} . En este caso los parámetros a optimizar son \\vec{\\alpha} y \\vec{\\theta}, para minimizar L.\nFlujo del algoritmo\n\nPrimero fijamos la variable \\vec{\\theta} para buscar el valor de \\vec{\\alpha} para minimizar L, proceso que se puede hacer de manera rápida al ser esta función convexa. Tras encontrar el valor buscado, tendríamos una primera aproximación al clasificador."},"Principio-de-incertidumbre":{"slug":"Principio-de-incertidumbre","filePath":"Principio de incertidumbre.md","title":"Principio de incertidumbre","links":["Relaciones-de-indeterminación"],"tags":[],"content":"Principio de incertidumbre\nEn la descripción de un sistema cuántico, existen parejas de magnitudes, denomina- das por Bohr, magnitudes complementarias, que no pueden ser medidas de forma simultanea con precisión absoluta. Si a y b son dos de estas magnitudes físicas complementarias representadas por los operadores Aˆ y Bˆ, entonces las medidas de las magnitudes a y b sobre un sistema Ψ, satisfacen la siguiente relación:\n\nDemostración para operadores posición y momento\n\nEn Relaciones de indeterminación vemos esta demostración para operadores genéricos"},"Problemas-QUBO":{"slug":"Problemas-QUBO","filePath":"Problemas QUBO.md","title":"Problemas QUBO","links":["tags/Tema"],"tags":["Tema"],"content":"Problemas QUBO Tema\nDefinición\nLos problemas tipo QUBO: Quadratic unconstrained binary optimization\n\nQuadratic: Este tipo de problemas tendrá una estructura polinomial donde las variables serán a lo sumo de grado 2\nunconstrained: A la hora de modelizar este problema no nos impondrán ninguna restricción que se deba cumplir obligatoriamente. Nos podrán orientar sobre que está bien y que está mal, pero nunca prohibir.\nBinary : Las variables del problema son binarias, solo pueden tomar valores 0 o 1\nOptimization: Se trata de un problema de optimización, donde el objetivo es encontrar el mínimo de una función dada.\n\nPodemos representar de manera genérica cualquier problema tipo qubo de esta manera:\nf(\\vec{x}) = \\sum_{i=1}^n \\alpha_{i}x_{i}+\\sum_{i=1}^n\\sum_{j=i}^{n}\\beta_{i,j}x_{i}x_{j}\nDonde x_{i} y x_{j} son variables binarias. El objetivo será encontrar el valor de x_{i} y x_{j} que hace mínimo la función objetivo f(\\vec{x}). Un ejemplo de una función objetivo de un problema tipo QUBO sería:\nf(x_{0},x_{1},x_{2})= x_{0}=3x_{2}-\\frac{1}{2}x_{0}x_{2}+x_{1}x_{2}\nOtra manera de ver los problemas QUBO es min \\quad (x^{\\dagger}Qx), siendo:\n\nx un vector de variables binarias.\nQ es una matriz simétrica de coeficientes que define una función cuadrática.\n\nRestricciones\nComo por definición no podemos añadir restricciones, lo que hacemos es introducir a nuestra función objetivo una serie de condiciones multiplicadas por un parámetro conocido como el coeficiente de Lagrange. Por lo tanto cuando se dan estas condiciones, el coeficiente de Lagrange penalizará al función objetivo y difícilmente será el camino optimo.\nRestricciones de igualdad\nUno de los tipos de restricciones serán los de igualdad, de manera genérica los podemos plantear como:\n\\sum_{i} a_{i}x_{i} = b\nComo no podemos introducir restricciones, lo que vamos a hacer es sumarlo a nuestra función f(\\vec{x}) multiplicado por \\lambda (coeficiente de Lagrange). De forma general nuestra nueva función objetivo con restricciones será:\nf(\\vec{x})&#039; &amp;= f(x) + \\lambda \\left( \\sum_{i} a_{i}x_{i}-b \\right)^2 \\\\\nf(\\vec{x})&#039; &amp;= \\sum_{i=1}^n \\alpha_{i}x_{i}+\\sum_{i=1}^n\\sum_{j=i}^{n}\\beta_{i,j}x_{i}x_{j}+ \\lambda \\left( \\sum_{i} a_{i}x_{i}-b \\right)^2\n\\end{align}$$\nElevamos la expresión al cuadrado para que siempre sea positiva y por lo tanto perjudique a la función objetivo. \n#### Ejemplo\nRescatamos la función de antes: $f(\\vec{x})= x_{0}=3x_{2}-\\frac{1}{2}x_{0}x_{2}+x_{1}x_{2}$ y añadimos la siguiente restricción:\n$$x_{0}+2x_{1}+3x_{2} = 4$$\nLa penalización en este caso será:\n$$\\lambda(x_{0}+2x_{1}+3x_{2} - 4)^2$$\nY nuestra nueva función objetivo:\n$$f(\\vec{x})&#039;= x_{0}=3x_{2}-\\frac{1}{2}x_{0}x_{2}+x_{1}x_{2}+\\lambda(x_{0}+2x_{1}+3x_{2} - 4)^2$$\n### Restricciones de desigualdad\nDe forma general este caso sería: \n$$\\sum_{i} a_{i}x_{i} \\leq b$$\nNo podemos hacer lo mismo que en la igualdad porque estaríamos penalizando los valores menores que $b$, y ese no es el objetivo. Por lo tanto lo que vamos a hacer es añadir una variable auxiliar $y$ que haga el papel de completar los sumando menores de 3 para conseguir la igualdad. Ejemplo sencillo, si $b=3$ y $\\sum_{i}x_{1}=1$. Entonces, en el proceso de optimización, $y=2$ para terminar de completar el sumando.\n\nEl único inconveniente es que $y$ debe ser una variable binaria, por lo tanto debemos escribir $y$ con su desarrollo binario de $\\log_{2}(b)$ términos. Por lo tanto, de forma general la restricción tendrá la forma:\n\n$$\\begin{align}\nf(\\vec{x})&#039; &amp;= f(x) + \\lambda \\left( \\sum_{i} a_{i}x_{i} +\\sum_{j=0}^{\\log_{2}(b)}2^jy_{j}-b \\right)^2 \\\\\nf(\\vec{x})&#039; &amp;= \\sum_{i=1}^n \\alpha_{i}x_{i}+\\sum_{i=1}^n\\sum_{j=i}^{n}\\beta_{i,j}x_{i}x_{j}+ \\lambda \\left( \\sum_{i} a_{i}x_{i}+\\sum_{j=0}^{\\log_{2}(b)}2^jy_{j}-b \\right)^2\n\\end{align}$$\n\n#### Ejemplo restricciones de desigualdad\nUtilizando la función de antes, $f(\\vec{x})= x_{0}=3x_{2}-\\frac{1}{2}x_{0}x_{2}+x_{1}x_{2}$, vamos a añadir la siguiente restricción: \n$$x_{0}+x_{1}+x_{2}\\leq 3$$\nPor lo tanto nuestra nueva función objetivo será:\n\n$$f(\\vec{x},\\vec{y})&#039;= x_{0}=3x_{2}-\\frac{1}{2}x_{0}x_{2}+x_{1}x_{2}+\\lambda(x_{0}+x_{1}+x_{2}+y_{0}+2y_{1}-3)^2$$\n## Ejemplo\n\nEn este trabajo vemos como podemos pasar un problema conocido de combinatoria, el problema del viajero (TSP) como un problema tipo QUBO. Estos problemas se pueden resolver usando una máquina cuántica basada en [[Quantum Annealing]]\n\n![[Actividad 1. Miguel Aliende.pdf]]"},"Producto-exterior-operadores-spin":{"slug":"Producto-exterior-operadores-spin","filePath":"Producto exterior operadores spin.md","title":"Producto exterior operadores spin","links":[],"tags":[],"content":"Producto exterior operadores spin"},"Producto-tensorial":{"slug":"Producto-tensorial","filePath":"Producto tensorial.md","title":"Producto tensorial","links":[],"tags":[],"content":""},"Proyectores":{"slug":"Proyectores","filePath":"Proyectores.md","title":"Proyectores","links":[],"tags":[],"content":"Proyectores\nDefinición\n![[Pasted image 20240217133857.png]]\n\nPropiedades\n![[Pasted image 20240217133926.png]]\n\nAplicamos un proyector a un Ket:\n"},"Puerta-CZ-átomos-neutros":{"slug":"Puerta-CZ-átomos-neutros","filePath":"Puerta CZ átomos neutros.md","title":"Puerta CZ átomos neutros","links":["Bloqueo-de-Rydberg","Puertas-cuánticas-con-átomos-neutros"],"tags":[],"content":"Puerta CZ átomos neutros\nVamos a ver como utilizando el Bloqueo de Rydberg conseguimos hacer la puerta CZ con dos qubits de átomos neutros. Para ellos vamos a usar la secuencia de pulsos de Puertas de dos Qubits. Y diferenciaremos estos casos:\nEstado de origen: \\ket{\\Psi_{0}} = \\ket{0_{c}0_{o}}\n\n\nEl primer pulso manda al qubit de control al estado \\ket{r} introduciendo en este una rotación de \\pi y creando un bloqueo de Rydberg en el qubit objetivo.\nEl segundo pulso en el qubit objetivo no no provoca ningún cambio debido a el bloqueo de Rydberg provocado por la excitación del qubit de control.\nEl tercer pulso hacer decaer al átomo del estado de \\ket{r} al estado \\ket{0} añadiéndole una rotación de \\pi. Que junto con el primer pulso se traduce en desfase global de 2\\pi en el qubit de control.\nResultado:\n\\ket{\\Psi_{0}} = \\ket{0_{c}0_{o}}\\rightarrow \\ket{\\Psi} = e^{i\\pi}\\ket{0_{c}0_{o}}\n\nEstado de origen: \\ket{\\Psi_{0}} = \\ket{0_{c}1_{o}}\n\nRealmente es la misma situación que el caso anterior, aunque esta vez el bloqueo de Rydberg da igual, debido a que el como el qubit objetivo parte del estado \\ket{1} nunca va llegar al estado \\ket{r} por medio del pulso 2. Resultado:\n\\ket{\\Psi_{0}} = \\ket{0_{c}1_{o}}\\rightarrow \\ket{\\Psi} = e^{i\\pi}\\ket{0_{c}1_{o}}\nEstado de origen: \\ket{\\Psi_{0}} = \\ket{1_{c}0_{o}}\n\n\nEl primer pulso no consigue excitar el qubit de control debido a que este parte del estado \\ket{1}, por lo tanto al no estar en el estado de Rydberg no provoca el bloqueo del qubit objetivo.\nEl pulso 2 esta vez es capaz de excitar el qubit objetivo al \\ket{r} y volverlo a \\ket{0} provocando una rotación de 2\\pi en la fase.\nIgual que en el paso 1, el tercer pulso no es capaz de excitar el qubit de control y permanece en \\ket{1}\nResultado:\n\\ket{\\Psi_{0}} = \\ket{1_{c}0_{o}}\\rightarrow \\ket{\\Psi} = e^{i\\pi}\\ket{1_{c}0_{o}}\n\nEstado de origen: \\ket{\\Psi_{0}} = \\ket{1_{c}1_{o}}\n\nEn este caso ninguno de los tres pulso es capaz de excitar ningún átomo a \\ket{r}, debido a que ambos parten de \\ket{1}. Por lo tanto en este caso el estado de ambos qubits permanece inalterado. Resultado:\n\\ket{\\Psi_{0}} = \\ket{1_{c}1_{o}}\\rightarrow \\ket{\\Psi} = e^{i\\pi}\\ket{1_{c}1_{o}}\nLa matriz del operador generado por la secuencia de pulsos descrita es:\n-1 &amp; 0 &amp; 0 &amp; 0\\\\\n 0 &amp;-1 &amp; 0 &amp; 0 \\\\\n0 &amp;0 &amp; -1 &amp; 0 \\\\\n0 &amp;0 &amp; 0 &amp; 1\n\\end{bmatrix} = e^{i\\pi}\\begin{bmatrix}\n1 &amp; 0 &amp; 0 &amp; 0\\\\\n 0 &amp;1 &amp; 0 &amp; 0 \\\\\n0 &amp;0 &amp; 1 &amp; 0 \\\\\n0 &amp;0 &amp; 0 &amp; -1\n\\end{bmatrix} =e^{i\\pi}CZ$$\nQue corresponde con la transformación CZ en un factor de fase $\\pi$.\n\n![[Pasted image 20240522182455.png| 80]]"},"Puerta-de-Hadamard":{"slug":"Puerta-de-Hadamard","filePath":"Puerta de Hadamard.md","title":"Puerta de Hadamard","links":[],"tags":[],"content":"Puerta de Hadamard\nPuerta que actúa sobre un qubit y su símbolo es:\n\nSu representación es:\n1 &amp; 1 \\\\\n1 &amp; -1\n\\end{bmatrix}$$"},"Puertas-cuánticas-con-átomos-neutros":{"slug":"Puertas-cuánticas-con-átomos-neutros","filePath":"Puertas cuánticas con átomos neutros.md","title":"Puertas cuánticas con átomos neutros","links":["Oscilaciones-de-Rabi","Bloqueo-de-Rydberg","Puerta-CZ-átomos-neutros"],"tags":[],"content":"Puertas cuánticas con átomos neutros\nPuertas de un sólo qubit\nPara producir rotaciones en los qubits de átomos neutros, se utilizan las Oscilaciones de Rabi típicas de un sistema de dos niveles. De esta manera, al iluminar un átomo estaremos pasando periódicamente entre el estado fundamental y el excitado, efectuando una rotación en la esfera de Bloch en un tiempo finito.\nSi controlamos el desajuste, la duración y la fase de láser, podemos situar al qubits en el cualquier punto de la esfera de Bloch, implementando las rotaciones en X, Y y Z.\nLas características del láser se pueden controlar con esta dos técnicas:\n\nLos moduladores acusto-ópticos: Son cristales piezoeléctricos, sus propiedades mecánicas pueden ser moduladas mediante un campo eléctrico, por lo cuales se hace pasar el haz de luz. Al aplicar un campo eléctrico variable a ambos extremos del piezoeléctrico se produce una vibración acústica del cristal, lo que provoca la difracción del haz en distintas direcciones. Con el uso de uno de estos haces difractados es posible modular la amplitud de la luz con gran precisión.\nLos moduladores electro-ópticos actúan de manera similar, pero, en lugar de cristales se utilizan materiales con distintas propiedades eletro-ópticas, como cristales birrefringentes, en los que la relación de los indices de refracción de los ejes rápido y lento puede ser modulada con un campo eléctrico.\n\nAl controlar este tipo de moduladores con un generador digital de señales, podemos diseñar pulsos de luz a medida para realizar todas las rotaciones posibles sobre la esfera de Bloch.\n\nEn la figura podemos ver oscilaciones de Rabi de frecuencia \\Omega entre los estados \\ket{0} y \\ket{1}. Si añadimos el desajuste \\Delta a la frecuencia de excitación, podemos modular la respuesta para una pulsación de pulso fija.\nPor lo tanto con tenemos los siguientes parámetros:\n\nDuración de los pulsos del láser: \\tau\nDesajuste de la frecuencia del láser con respecto a la frecuencia de excitación: \\Delta\nFase: \\phi\nFrecuencia de Rabi: \\Omega\n\nPodemos realizar las siguientes rotaciones respecto a la esfera de Bloch:\n(x,y,z) \\rightarrow (\\Omega \\tau \\cos(\\phi)),(\\Omega \\tau \\cos(\\phi),\\Delta \\tau)\nPuertas de dos Qubits\nPara realizar puertas de dos qubits, vamos tomar dos átomos, uno control y otro objetivo y vamos a utilizar un tercer estado de Rydberg auxiliar \\ket{r} para realizar las operaciones, partiendo de \\ket{0} en ambos qubits, la secuencia es:\n\n\nPulso 1 \\rightarrow Pasa de \\ket{0} al estado de Rydberg \\ket{r}, lo que provoca una rotación de \\pi en el qubit de control.\nPulso 2 \\rightarrow Pasa del estado \\ket{0} a \\ket{r} y vuelve a \\ket{0}, lo que provoca una rotación de 2\\pi en el qubit objetivo.\nPulso 3 \\rightarrow Pasa del estado \\ket{r} a \\ket{0}. Añadiendo una rotación \\pi al qubit de control, sumando una rotación total de 2\\pi.\n\nPara construir estas puertas cuánticas nos vamos a aprovechar de la propiedad de Bloqueo de Rydberg. En el siguiente ejemplo vamos a ver como podemos construir la Puerta CZ átomos neutros aprovechado este mecanismo.\nComo hemos ya tenemos la puerta CZ, vamos a construir la CNOT añadiendo una puerta Hadamard antes y después del de aplicar la rotación Z en el qubit objetivo, de esta manera:\n\nCon la posibilidad de efectuar todas las rotaciones posibles sobre qubits individuales y puertas de dos qubits con entrelazamiento tenemos un conjunto de puertas universales."},"Puertas-cuánticas-con-transmones":{"slug":"Puertas-cuánticas-con-transmones","filePath":"Puertas cuánticas con transmones.md","title":"Puertas cuánticas con transmones","links":["Puertas-cuánticas","transmón","circuito-LC"],"tags":[],"content":"Puertas cuánticas con transmones\nPara que nuestro sistema pueda ser considerado un computador, necesitamos un conjunto de Puertas cuánticas que nos permitan cubrir toda la esfera de Bloch y la interacción entre qubits.\nEl esquema utilizado en la manipulación es similar a la modulación de las ondas de radio. Una portadora, en este caso, a al frecuencia característica del qubit, es modulada por otra señal más lenta que divide sus componentes en fase (I) y cuadratura (Q) , es decir, retrasada \\pi / 2.\nRotación X y Y\nEn el caso de los transmón, para un pulso de duración dada en la componente I, produce una rotación en el eje X. La misma relación se da entre el eje Y y la componente Q. De esta manera podemos aplicar una rotación de un ángulo \\theta al estado de los qubits en los ejes X e Y con un único pulso de manera simultánea.\nRotación Z\nImaginemos que aplicamos un pulso, cuyas componentes I y Q actuan sobre un qubit aplicando la rotación X_{\\theta}Y_{\\phi}. Si retrasamos la fase en \\pi / 2, I pasaría  ser Q y Q pasaría a ser -I, lo que se traduce en la rotación X_{\\phi}Y_{-\\theta}, lo que es equivalente a una rotación \\pi en el eje Z, es decir Z_{\\pi}.\nPara hacer una rotación \\phi en torno al eje Z, basta con aplicar dos veces la misma rotación en torno a X e Y con un desfase \\phi entre los pulsos. Creamos así la puerta virtual Z que nos permite efectuar la operación Z_{\\phi]}.\nDe esta manera tenemos ya definidas todas las rotaciones posibles de la esfera de Bloch.\nPuerta CR o resonancia cruzada.\nSe trata una puerta de dos qubits, a través de transmones. Para fabricar una puerta CR entre dos qubits 1 y 2, con frecuencias de resonancia w_{q_{1}} y w_{q_{2}}, se le conecta capacitivamente mediante guías de ondas a un circuito LC resonador, que hará de intermediario entre los qubits.\nSi excitamos el qubit 1 a la frecuencia de resonancia de l qubit 2, el acoplo entre ambos a través del resonador hará que el segundo qubit reciba una señal que dependa del estado del primero.  La matriz del operador CR es:\n\\cos\\left( \\frac{\\phi}{2} \\right) &amp; -i \\cdot \\sin\\left( \\frac{\\phi}{2} \\right) &amp; 0 &amp; 0  \\\\\n-i \\cdot \\sin\\left( \\frac{\\phi}{2} \\right) &amp; \\cos\\left( \\frac{\\phi}{2} \\right)&amp; 0 &amp; 0  \\\\\n 0 &amp; 0 &amp; \\cos\\left( \\frac{\\phi}{2} \\right) &amp; i \\cdot \\sin\\left( \\frac{\\phi}{2} \\right) \\\\\n 0 &amp; 0 &amp; i \\cdot \\sin\\left( \\frac{\\phi}{2} \\right) &amp; \\cos\\left( \\frac{\\phi}{2} \\right)\n\\end{bmatrix}$$\nDonde $[\\phi]$ viene determinado por las características de duración y amplitud del pulso de frecuencia $\\omega_{q2}$ aplicado al qubit 1.\n\n![[Pasted image 20240517165729.png | 300]]\n\n### Puerta CNOT\n\nLa puerta CR se puede combinar con los operadores de rotación de un solo qubit para crear la puerta CNOT:\n\n![[Pasted image 20240517165853.png|400]]"},"Puertas-cuánticas":{"slug":"Puertas-cuánticas","filePath":"Puertas cuánticas.md","title":"Puertas cuánticas","links":["Qubit"],"tags":[],"content":"Puertas cuánticas\nSon equivalentes a las puertas lógicas clásicas. Transforman los Qubit, de acuerdo a ciertas operaciones sn realizar una medida sobre el qubit.\nSe dice que un conjunto de puertas es universal para la computación cuántica si cualquier operación unitaria puede ser aproximada por un circuito cuántico que incluya solo esas puertas.\nCaracterísticas\n\nActúa de manera linealmente independiente sobre estados de superposición\nEs unitaria\nSon reversibles.\n\nTipos\nPuerta X\n\nPuerta Z\n\nPuerta Controlled NOT (CNOT)\n\nPuerta Hadamard (H)\n"},"Puertas-de-cuánticas-fotónicas-dos-qubit":{"slug":"Puertas-de-cuánticas-fotónicas-dos-qubit","filePath":"Puertas de cuánticas fotónicas dos qubit.md","title":"Puertas de cuánticas fotónicas dos qubit","links":[],"tags":[],"content":"Puertas de cuánticas fotónicas dos qubit\nUno de los mayores impedimentos de la óptica lineal en la computación cuántica es realizar puertas de más de un qubit. Para añadir interacción entre dos haces de luz diferentes, hay que introducir algún tipo de no-linealidad que permita la interacción entre fotones.\nMedios Kerr\nUna primera propuesta para realizar circuito ópticos no-lineales hacía uso de los medios Kerr. Este tipo de materiales presentan un índice de refracción n_{kerr}, el cual posee una componente no lineal que depende de la intensidad del haz incidente. Un haz que atraviese este medio sufrirá un cambio de fase proporcional a su intensidad.\nMedios Kerr cruzados\nEn estos sistemas, la fase de un haz de señal depende de la intensidad de otro haz de control que también los atraviesa. Si introducimos un medio de Kerr cruzado en interferómetro de Mach-Zehdner, como en el de la figura:\n\nLa medida a la salida del haz de control nos indicará la intensidad del haz señal. Si el cambio de fase \\tau es lo suficientemente intenso, podría indicarnos la presencia o ausencia de un fotón individual.\nUsando esto podríamos construir una puerta CZ mediante elementos ópticos lineales y un medio de Kerr cruzado:\nPuerta CZ\nLas transformaciones necesarias para una puerta CZ son:\n\\hat{a}_{H}\\hat{b}_{H} &amp;\\rightarrow \\hat{a&#039;}_{H}\\hat{b&#039;}_{H} \\\\\n\\hat{a}_{V}\\hat{b}_{H} &amp;\\rightarrow \\hat{a&#039;}_{V}\\hat{b&#039;}_{H} \\\\\n\\hat{a}_{H}\\hat{b}_{V} &amp;\\rightarrow \\hat{a&#039;}_{H}\\hat{b&#039;}_{V} \\\\\n\\hat{a}_{V}\\hat{b}_{V} &amp;\\rightarrow \\hat{a&#039;}_{V}\\hat{b&#039;}_{V}\\cdot e^{i\\tau}\n\\end{align}$$\n\nPara que esto funcione necesitamos un medio de Kerr que se cumpla que $\\tau = \\pi$. El problema que tienen es que los materiales cuya transparencia pueda ser modulada electromagnéticamente se han logrado valores de $\\tau =10^-5$, muy lejos de nuestro objetivo.\n\n## Átomos de cesio en cavidades ópticas\n\nPara forzar la interacción entre dos modos de polarización de diferente frecuencia en un único fotón. Al introducir estos modos en un a cavidad con átomos de cesio es posible observar un cambio de fase que depende  del estado estado de polarización de los modos de entrada. Un diseño adecuado de estas cavidades, es capaz de amplificar pequeñas no-linealidades hasta conseguir desfase de $\\pi$.\n\n## Protocolo KLM\n\nEn los 2000,  Knill, Laflamme y Millburn demostraron que es posible hacer ordenadores cuánticos usando óptica lineal, fotones individuales y detectores de fotones. \n\nLa base de este protocolo es el uso de medidas proyectivas con fotodetectores y las puertas de cambio de signo condicionales no deterministas, puertas $NS$. Las puertas $NS$ introducen un cambio de fase en un modo a partir de los estados de otros dos modos o qubits auxiliares. El problema de las puertas $NS$ es que al no ser deterministas, tienen una posibilidad de falla que puede llegar a ser de esta el $75\\%$.\n\nEs posible mejorar la fiabilidad de este tipo de circuitos mediante la preparación de estados entrelazados a la entrada de estos y mediante teleportación cuántica."},"Puertas-de-cuánticas-fotónicas-un-qubit":{"slug":"Puertas-de-cuánticas-fotónicas-un-qubit","filePath":"Puertas de cuánticas fotónicas un qubit.md","title":"Puertas de cuánticas fotónicas un qubit","links":["Elementos-de-óptica-cuántica-lineal","Láminas-plano-paralelas"],"tags":[],"content":"Puertas de cuánticas fotónicas un qubit\nRotaciones en la esfera de Bloch\nVeremos como los Elementos de óptica cuántica lineal somos capaces de aplicar todas las rotaciones en la esfera de Bloch.\nMediante Láminas plano-paralelas\nSi un fotón atraviesa una lámina con un índice de refracción diferente al de su entorno, se producirá un cambio en su fase mediante el operador:\n\\hat{a}^{\\dagger}_{salida} = e^{i\\phi}\\hat{a}^{\\dagger}_{entrada}\nLo que da lugar al Hamiltoniano de la interacción que es proporcional al operador número n, por lo que el número de fotones se conserva\nH_{\\phi} =  \\phi \\hat{a}^{\\dagger}_{entrada}\\hat{a}_{entrada}\nLa matriz unitaria asociada a este operador se puede escribir cómo:\n e^{i\\phi} &amp; 0 \\\\\n0 &amp; 1\n\\end{bmatrix}$$\n### Mediante [[Divisores de haz]]\n\nSi consideramos un divisor de haz con una amplitud en la transmisión parametrizada por $\\theta$ tal que $T =\\cos^2\\theta$, con unas intensidades de entrada $\\hat{a}^{\\dagger}_{e}$ y $\\hat{b}^{\\dagger}_{e}$ en las posibles direcciones y una fase relativa $\\phi$ podemos expresar las intensidades de salida a través de los siguientes operadores:\n$$\\begin{align}\n\\hat{a}^{\\dagger}_{s} &amp;= \\cos \\theta \\cdot\\hat{a}^{\\dagger}_{e} +ie^{-i\\phi}\\sin \\theta \\cdot \\hat{b}^{\\dagger}_{e} \\\\\n\\hat{b}^{\\dagger}_{s} &amp;= ie^{i\\phi}\\sin \\theta \\cdot\\hat{a}^{\\dagger}_{e} +\\cos \\theta \\cdot \\hat{b}^{\\dagger}_{e}\n\\end{align}$$\nLos coeficientes de transmisión $T$ y reflexión $R$ son:\n\\begin{align}\nR &amp;= \\sin^2\\theta \\\nT&amp;= 1-R = \\cos^2\\theta\n\\end{align}$$\nMientras que el cambio de fase relativo e^{\\pm i\\phi} mantiene la transformación como unitaria.\nEl Hamiltoniano del divisor de haz puede expresarse como:\nH_{DH} = \\theta e^{i\\phi}\\cdot\\hat{a}^{\\dagger}_{e}\\hat{b}_{e} + \\theta e^{-i\\phi}\\hat{a}_{e}\\hat{b}^{\\dagger}_{e}\nComo conmuta con el operador número n, conserva el número de fotones.\nLa matriz unitaria asociada al divisor de haz es por lo tanto:\n \\cos \\theta &amp; ie^{-i\\phi}\\cdot \\sin\\theta \\\\\nie^{i\\phi}\\cdot \\sin \\theta &amp; \\cos \\theta\n\\end{bmatrix}$$\n\n### Mediante [[Láminas de onda]]\n\nLa descripción matemática de una lámina de ondas es equivalente a la del divisor de haz, solo se cambian los dos modos espaciales por los modos de polarización:\n$$\\begin{align}\n\\hat{a}^{\\dagger}_{e} &amp;\\rightarrow \\hat{a}^{\\dagger}_{x} \\\\\n\\hat{b}^{\\dagger}_{e} &amp;\\rightarrow \\hat{b}^{\\dagger}_{y}\n\\end{align}$$\nSiendo $x$ e $y$ dos ejes de polarización ortogonales elegidos arbitrariamente, los operadores quedarían de la forma:\n$$\\begin{align}\n\\hat{a}^{\\dagger}_{x&#039;} &amp;= \\cos \\theta \\cdot\\hat{a}^{\\dagger}_{x} +ie^{-i\\phi}\\sin \\theta \\cdot \\hat{b}^{\\dagger}_{y} \\\\\n\\hat{b}^{\\dagger}_{y&#039;} &amp;= ie^{i\\phi}\\sin \\theta \\cdot\\hat{a}^{\\dagger}_{x} +\\cos \\theta \\cdot \\hat{b}^{\\dagger}_{y}\n\\end{align}$$\nEl hamiltoniano es igual al del divisor de haz pero cambiando las direcciones espaciales por los ejes de polarización.\n\n## Circuito óptico\n\nLas transformaciones vistas anteriormente son suficientes para implementar cualquier operación de un solo qubit, con lo que vamos a poder fabricar circuitos ópticos para tareas de computación.\n\nUn circuito óptico con $N$ entradas realiza una transformación unitaria sobre los $N$ modos posibles. A la salida detectamos estos modos mediante detectores ópticos, que dan lugar al estado cuántico.\n\nEl operador unitario de un circuito óptico de $N$ entradas puede ser descrito como:\n$$\\begin{align}\n\\hat{b}^{\\dagger}_{k} \\rightarrow \\sum_{j=1}^N U^{*}_{jk}\\cdot \\hat{a}^{\\dagger}_{j} \\\\\n\\hat{b}_{k} \\rightarrow \\sum_{j=1}^N U_{jk}\\cdot \\hat{a}^{\\dagger}_{j}\n\\end{align}$$\n\nTenemos dos opciones para codificar el qubit:\n* **Dirección espacial:** $$\\begin{align}\n\\ket{0}_{L} &amp;=\\ket{1}\\otimes \\ket{0} \\\\\n \\ket{1}_{L} &amp;=\\ket{0}\\otimes \\ket{1}   \n\\end{align}$$\n* **Polarización**: $$\\begin{align}\n\\ket{0}_{L} &amp;=\\ket{H} \\\\\n\\ket{1}_{L} &amp;=\\ket{V}  \n\\end{align} $$\nEstas dos representaciones del qubit son equivalentes y podemos alternar entre ellas mediante un divisor de haces polarizado."},"Puertas-lógicas-y-circuitos-lógicos":{"slug":"Puertas-lógicas-y-circuitos-lógicos","filePath":"Puertas lógicas y circuitos lógicos.md","title":"Puertas lógicas y circuitos lógicos","links":[],"tags":[],"content":"Puertas lógicas y circuitos lógicos\nUna puerta lógica es un modelo que implementa una función booleana, es decir, una operación lógica realizada en una o más entradas binarias que produce una única salida binaria.\nUn circuito lógico es un modelo de computación compuesto por una secuencia de puertas lógicas, cada una de ellas computando una función y siendo el resultado del circuito una o varias salidas binarias. Su tamaño y profundidad proporcionan unos límites inferiores de los recursos necesarios para realizar una tarea computacional. Esta es la idea central para el uso de circuitos lógicos para la clasificación de los problemas por su complejidad computacional.\nEjemplo de circuito lógico para sumar dos bits\nA partir del concepto de suma binaria podemos construir la siguiente tabla\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABSUMAACARREO0000011010101111\ndibujando como un diagrama de bloques tenemos:\n\nY en si lo construimos con puertas lógicas, el circuito que sumas dos bits sería:\n"},"Puntos-cuánticos-semiconductores":{"slug":"Puntos-cuánticos-semiconductores","filePath":"Puntos cuánticos semiconductores.md","title":"Puntos cuánticos semiconductores","links":[],"tags":[],"content":"Puntos cuánticos semiconductores\nFabricación\nLos puntos cuánticos semiconductores se fabrican mediante técnicas litográficas a partir de un diseño complejo pero reproducible.\nParten de un pozo cuántico bidimensionales, que puede ser de un material semiconductor como el silicio.\n\n\n(a): Representación esquemática de la geometría de las bandas\n(b): Pozo cuántico de potencial\n(c): Estructura de electrodos\n(d): Esquema del perfil de densidad de estado de un punto cuántico fabricado a partir de un pozo cuántico.\n\nPara pasar de un pozo cuántico a un punto, se hace mediante técnicas litográficas y una serie de electrodos de control que pueden modificar las propiedades electrónicas del material mediante la aplicación de tensión.\nComo partimos de un pozo cuántico, el confinamiento en una de las direcciones ya viene determinado por la geometría del pozo, mientras que los electrodos de control nos permiten crear barreras de potencial de manera localizada en las otras dos dimensiones espaciales, dando control sobre el lugar e intensidad del confinamiento. Gracias a esto, podemos cargar y descargar el punto cuántico, conectarlo con otros puntos o simplemente hacerlo desaparecer y devolverlo al pozo original.\nPuntos cuánticos semiconductores como qubits\n\nLos electrodos que están directamente enfrentados a la región de confinamiento carga permiten modular la profundidad del pozo \\rightarrow Alterando la posición de los niveles energéticos del electrón confinado.\nLos electrodos de puerta situados a sus lados, permiten cambiar la altura de la barrera potencial \\rightarrow Modula la intensidad de la interacción entre puntos cuánticos adyacentes.\n\nProtocolo inicialización punto cuántico en superposición\nUna de las posibilidades para inicializar un qubit en superposición es considerar el estado de carga de dos puntos cuánticos interconectados separados por una barrera potencial controlable. Es posible cargar uno de los puntos con un electrón y jugando con la modulación de la altura de la barrera, creamos un estado en superposición\n\n\na) Estado inicial con el qubit descargado\nb) Carga del qubit con un electrón e inicialización al estado con la carga en el punto cuántico izquierdo \\ket{I}\nc) Modulación de la barrera de potencial entre puntos mediante el electrodo de puerta.\nd) Estado de superposición entre los dos estados de carga: \\alpha \\ket{I}+\\beta \\ket{D}\n\nPuertas cuánticas un solo qubit\nLa intensidad de interacción entre los puntos cuánticos, también pede ser controlada mediante los electrodos de puerta., lo que permite cambiar entre un estado u otro incluso superposiciones de ambos. Mediante pulsos de corriente de una duración determinada se puede establecer la relación entre ambos, lo que permite recorrer toda la esfera de Bloch con su elección adecuada. Podemos constituir así todas la puertas cuánticas sobre un solo qubit.\n\nEsto sería un ejemplo de como podemos realizar rotaciones en un solo qubit mediante pulsos de corriente.\nMedidas de qubits de puntos cuánticos\nLa medida de el estado de un qubit de este tipo, se puede realizar con un sensor capacitivo de carga situado cerca de uno de los puntos cuánticos. Esto nos indicará si la carga está presente en él.\nMediante el mismo tipo de interacci"},"QAOA":{"slug":"QAOA","filePath":"QAOA.md","title":"QAOA","links":["tags/Tema","Modelo-Ising","puertas-de-rotación-QAOA","superposición-cuántica","Puertas-cuánticas","Adaptación-exponencial-de-Hamiltoniano-genérico-QAOA-y-EVA","Quantum-Annealing","Ecuación-de-Shrödinger","minimum--vertex-cover-con-QAOA"],"tags":["Tema"],"content":"QAOA Quantum Aproximation Optimization Algorithm Tema\nCon este algoritmo vamos a poder calcular la máxima energía de un Hamiltoniano tipo Ising. Utilizaremos la exponencial del Hamiltoniano debido a su relación con la evolución temporal en mecánica cuántica.\nIdea intuitiva\nPartiremos del Hamiltoniano del Modelo Ising. Para este ejemplo utilizaremos:\n\\begin{pmatrix}\n  1 &amp; 0 &amp; 0 &amp; 0 \\\\\n  0 &amp; 3 &amp; 0 &amp; 0 \\\\\n  0 &amp; 0 &amp; 4 &amp; 0 \\\\ \n  0 &amp; 0 &amp; 0 &amp; 0\n\\end{pmatrix}\nEl objetivo de este algoritmos es encontrar el auto estado que maximiza la energía, en nuestro ejemplo concreto es fácil ver que es \\ket{10} con valor del Hamiltoniano 4.\nNo podemos mapear este Hamiltoniano en puertas cuánticas porque no es una matriz unitaria, por lo tanto necesitamos introducir e^{iH}, que como H es una matriz diagonal tenemos:\n\\begin{pmatrix}\n  e^{i} &amp; 0 &amp; 0 &amp; 0 \\\\\n  0 &amp; e^{i3} &amp; 0 &amp; 0 \\\\\n  0 &amp; 0 &amp; e^{i4} &amp; 0 \\\\ \n  0 &amp; 0 &amp; 0 &amp; 1\n\\end{pmatrix}\nDe esta manera nuestro objetivo pasar de encontrar el mayor módulo a encontrar la mayor fase.\nPara seguir con el algoritmo tenemos que definir las puertas de rotación QAOA que son  U(C,\\gamma) y U(B,\\beta).\n\n\nUna vez tenemos definido nuestra función objetivo en forma de Hamiltoniano tipo Ising lo que hacemos es inicializar todos los estados con en un estado de superposición cuántica equiprobable, mediante puertas Hadamard Puerta Hadamard (H). Si los representamos en una esfera, todos ellos apuntan en la misma dirección:\n\n\n\nPrimero aplicamos la puerta U(C,\\gamma), que es equivalente a calcular la exponencial de Hamiltoniano que hemos definido como función objetivo. Lo que hace es rotar en el eje Z los estados en función de su fase. Los estados con mayor fase más se alejarán del origen. Esta puerta no cambia las probabilidades de cada estado, sólo la fase.\n\n\n\nPor último, vamos aplicar al puerta U(B,\\beta), que lo que va a hacer es rotar la esfera, que después de haber aplicado la puerta U(C,\\gamma) lo que va a pasar es que aquellos estados más  separados del origen van a ser más probables, aplicar esta puerta sacrifica un poco de fase.\n\n\n\nRepitiendo la aplicación de estas puertas consecutivamente conseguiremos mejorar las probabilidades de los estados con mayor energía.\n\n\n\nUna manera de mejorar los resultados es eligiendo los valores más óptimos para \\gamma y \\beta, para ello podemos utilizar algoritmos de optimización clásicos.\n\n\nResolución genérica\nLa ventaja de este algoritmo es que podemos usar Descomponer exponencial de Hamiltoniano tipo Ising como puertas de Pauli para cualquier Hamiltoniano tipo Ising, e incluso Adaptación exponencial de Hamiltoniano genérico QAOA y EVA para generalizarlo a cualquier tipo de Hamiltoniano.\nRelación con Quantum Annealing\nEste algoritmo puede considerarse el equivalente del Quantum Annealing pero en computación de puertas. Este algoritmo lo que hacia era dejar evolucionar los estados influenciados por el Hamiltoniano del sistema e intentar encontrar atajos mediante el efecto túnel.\nAl hablar de dejar evolucionar el Hamiltoniano hablamos de la  Ecuación de Shrödinger:\ni\\hbar \\frac{\\partial \\ket{\\phi(t)} }{\\partial t} = H \\ket{\\sigma(t)} \nResolviendo esta ecuación obtenemos como varia H a lo largo del tiempo. Lo que indicamos en QAOA con el parámetro \\gamma podría considerarse como el tiempo, y para simular estos saltos que pueden dar los estados podemos considerar U(B,\\beta) como una perturbación, donde \\beta sería la intensidad de esta perturbación. Por lo tanto podemos decir que estamos haciendo lo mismo que QA pero de una manera artificial.\nResolución de problemas con QAOA\nEjemplo de como resolver con PennyLane el problema minimum  vertex cover con QAOA"},"Quantum-Annealing":{"slug":"Quantum-Annealing","filePath":"Quantum Annealing.md","title":"Quantum Annealing","links":["Problemas-QUBO"],"tags":[],"content":"Quantum Annealing\nLas QPUs de quantum annealing están diseñadas específicamente para resolver problemas de optimización combinatoria, como nuestro TSP. En forma de Problemas QUBO\nEstos sistemas simulan el proceso de enfriamiento de un material para encontrar su estado de mínima energía. Para hacer estas simulaciones, las QPUs utilizan qubits super- conductores que pueden estar en un estado de superposición cuántica. Las interconexiones entre estos qubits se consiguen mediante acoplamiento electromagnético.\nEl proceso comienza inicializando los qubits en un estado aleatorio de alta energía, y la función objetivo a minimizar se introduce al sistema jugando con el acoplamiento entre los qubits. En este punto comienza el proceso de annealing, dejando que la temperatura del sistema se reduzca gradualmente y los qubits se ajusten a estados de menor energía. Cuando el sistema converge a un estado de mínima energía representa una solución óptima al problema.\nEnlace a documentación de D-Wave Systems: docs.dwavesys.com/docs/latest/c_gs_2.html"},"Quantum-Phase-Estimation":{"slug":"Quantum-Phase-Estimation","filePath":"Quantum Phase Estimation.md","title":"Quantum Phase Estimation","links":["Phase-Kickback"],"tags":[],"content":"Quantum Phase Estimation\nEste algoritmo estima la fase (\\phi) del autovalor(e^{2\\pi i\\phi}) asociado a un autovector (\\ket{u}) de un operador unitario U. Es decir U\\ket{u} = e^{2\\pi i\\phi}\\ket{u}\\text{ donde } \\phi \\in[0,1]  \nPara describir la fase que está entre 0 y 1 vamos a usar la representación decimal binaria donde \\phi=0.\\phi_{1}\\phi_{2}\\phi_{3}\\dots \\phi_{n} \\to \\phi= \\sum_{k=0}^n \\phi_{k}2^{-k}\nPara conseguir este estimación el vamos a usar dos registros cuánticos.\n\nRegistro de estimación: n qubits auxiliares en los que mediante el fenómeno de Phase Kickback almacenaremos la estimación de \\phi.\nRegistro de estado: m qubits necesarios para almacenar el estado \\ket{u}.\n\nEjemplo para 1 qubit en el registro de estimación\nEl primer primer paso del algoritmo es tratar de transferir la fase del registro de estado al registro de estimación. Para ello vamos a usar Phase Kickback. Para entenderlo vamos a ir al ejemplo más sencillo, con un único qubit de estimación y el autoestado \\ket{\\psi} es autovector del operador unitario U con un autovalor \\lambda=e^{2\\pi i0.\\phi_{1}}. Ponemos en superposición el qubit de control (condiciones para que se produzca phase kickback) y tenemos el circuito:\n\nMás adelante veremos porque usamos U^{2^0}. Como U\\ket{\\psi} = \\lambda \\ket{\\psi}, el resultado de este circuito es:     \\begin{align}\n\\frac{1}{\\sqrt{ 2 }}(\\ket{0}\\ket{\\psi}+\\ket{1}U\\ket{\\psi}) =&amp; \\frac{1}{\\sqrt{ 2 }}(\\ket{0}\\ket{\\psi}+e^{2\\pi i_{0}.\\phi_{1}}\\ket{1}\\ket{\\psi} \\\\\n=&amp; \\frac{1}{\\sqrt{ 2 }}(\\ket{0}+e^{2\\pi i_{0}.\\phi_{1}}\\ket{1})\\otimes \\ket{\\psi} \n\\end{align}\nDe este resultado podemos sacar dos conclusiones importantes:\n\nComo resultado del Phase Kickback,algo información del autovalor de \\ket{\\psi} se ha almacenado en la fase relativa del qubit de control.\nEl autoestado \\ket{\\psi} no se ha modificado al aplicar U y no lo hará por muchas veces que lo apliquemos.\n\nEn el caso de tener un qubit en el registro de estimación bastará con aplicarle otra puerta H antes de medir para poder leer esta información almacenada en la fase:\n=&amp;\\frac{1}{2}((1+e^{2\\pi i_{0}.\\phi_{1}})\\ket{0} +(1-e^{2\\pi i_{0}.\\phi_{1}})\\ket{1})\n\\end{align}$$\nAsí medimos con total certeza el estado que nos dice cual es valor de la fase y por lo tanto del autovalor de $\\ket{\\psi}$\n\n\n## Algoritmo de estimación de fase general\n\nSi sólo contamos con un qubit en el registro de estimación la precisión con la que calculamos la fase va a ser limitada, por eso la idea de este algoritmo es utilizar un registro con $n$ qubits en superposición y aplicar $C\\text{-}U^{2^k}$, ya que:$$U^{k}\\ket{\\psi} = e^{2\\pi i\\phi \\cdot k}\\ket{\\psi}$$\nEvidentemente, para que se de esto seguimos manteniendo que el autoestado $\\ket{\\psi}$ es un autovector de $U$ con autovalor $e^{2\\pi i\\phi}$. Como en el caso anterior la información de la fase de $\\ket{\\psi}$ se transferirá a la fase relativa de los qubits del registro de estimación, pero leerla no será tan sencillo como aplicar la puerta $H$, si no que tendremos que aplicar la [[Transformada cuántica de Fourier QFT]] inversa $QFT^{\\dagger}$. De esta manera, transformaremos la información almacenada en las fases de los qubits del registro de estimación a la base computacional. \n### Ejemplo para 2 qubits. \n\n![[Pasted image 20250126134257.png|200]]\n\nDespués de aplicar los dos operadores controlados, tendríamos $(\\ket{0}+e^{2\\pi i0.\\phi_{1}}\\ket{1})\\otimes(\\ket{0}+e^{2\\pi i0.\\phi_{1}\\phi_{2}}\\ket{1})\\otimes \\psi$. Si aplicamos $QFT^{\\dagger}$, tenemos(ignoramos los coeficientes):$$QFT^{\\dagger}((\\ket{0}+e^{2\\pi i0.\\phi_{1}}\\ket{1})\\otimes(\\ket{0}+e^{2\\pi i0.\\phi_{1}\\phi_{2}}\\ket{1}))\\otimes \\psi = \\ket{\\phi_{2}\\phi_{1}}\\otimes \\ket{\\psi}  $$\n\n### Ejemplo para $n$ qubits\n\nEl circuito del algoritmo de estimación de fase para $n$ qubits sería: \n\n![[Pasted image 20250126135508.png|500]]\n\nVamos a detallar cada paso de este circuito.\n\n1. Describimos el estado inicial del circuito como $\\ket\\theta_{0}=\\ket{0}^{\\otimes n}\\otimes \\ket{\\psi}$\n2. Para poner el registro de estimación en superposición aplicamos $H$ a los $n$ qubits $$\\ket{\\theta_{1}}=H^{\\otimes n}\\ket{\\theta_{0}}= \\frac{1}{\\sqrt{ 2^n }}\\sum_{k=0}^{n}\\ket{k}\\otimes \\ket{\\psi}    $$Donde $\\ket{k}$ son los estados de la base computacional de $n$ qubits. Ej para 3 qubits $\\ket{000},\\ket{001},\\ket{010}\\dots$\n\n3. Aplicamos las puertas $C\\text{-}U^{2^k}$ por cada qubit del registro de estimación y expandimos la fase en su notación binaria decimal tenemos:$$\\ket{\\theta_{2}}= C\\text{-}U\\ket{\\theta_{1}} = \\frac{1}{\\sqrt{ 2 }}(\\ket{0}+e^{2\\pi i0.\\theta_{1}\\theta_{2}\\theta_{3}\\dots\\theta_{n} }\\ket{1})\\otimes(\\ket{0}+e^{2\\pi i0.\\theta_{2}\\theta_{3}\\theta_{4}\\dots\\theta_{n} }\\ket{1})\\otimes \\dots \\otimes(\\ket{0}+e^{2\\pi i0.\\theta_{n}})$$\n4. En este punto tenemos la representación decimal binaria de la fase almacenada en la fase relativa de los qubits del registro de estimación, por eso vamos a utilizar $QFT^{\\dagger}$ para mapear estos estados de la fase a estados computacionales.$$\\ket{\\theta_{3}}=QFT^{\\dagger}\\ket{\\theta_{2}} = \\ket{\\theta_{n}}\\ket{\\theta_{n-1}\\ket{\\theta n-2}\\dots \\ket{\\theta_{1}}  }    $$\nDe esta manera conseguimos una estimación de la fase en la base computacional.\n\nEn resumen, la idea del algoritmo ha sido:\n\n* Usar [[Phase Kickback]] con los operadores controlados $C\\text{-}U^{k}$ para transferir la fase del registro de estados a la fase relativa de los qubits del registro de estimación.\n* Utilizar $QFT^{\\dagger}$ para mapear lso valores almacenados en la fase relativa de los qubits a estados computacionales."},"Quantum-Support-Vector-Machine":{"slug":"Quantum-Support-Vector-Machine","filePath":"Quantum Support Vector Machine.md","title":"Quantum Support Vector Machine","links":["tags/Tema","SVM-Clásico","Funciones-Kernel","Hadamard-Test","Principio-Variacional"],"tags":["Tema"],"content":"Quantum Support Vector Machine (QSMV)\nTema\nSe trata de un algoritmo híbrido capaz de explotar la potencia de los ordenadores cuánticos con un número no muy elevado de qubits para tareas de clasificación.\n\n\nSVM Clásico\n\n\nEstamos suponiendo la separabilidad lineal de los datos, hemos supuesto que existe un hiperplano que divide totalmente ambas clase. Esto no es siempre así, para solucionarlo vamos a usar las Funciones Kernel\nIdea intuitiva\nLa idea es utilizar los computadores como Funciones Kernel, es decir, mapear los datos al espacio de Hilbert subyacente en dichos computadores.\nComo hemos explicado, necesitamos calcular el producto \\phi(\\vec{x_{i}}) \\cdot \\phi(\\vec{x_{j}}), donde \\phi(\\vec{x_{i}}) es el nuevo vector de dimensión mayor asociado al vector \\vec{x_{i}}. En nuestro nuevo escenario el nuevo vector asociado será definido a través de una puerta U aplicada a un estado inicial, por defecto el 0.\n\\phi(\\vec{x_{i}}) = U_{x_{i}}\\ket{0}^{\\otimes n}\nSiendo n en numero de qubits. Mostraremos diferentes mapas de características que es frecuente encontrarse. En primer lugar supondremos que los datos serán transformados a través de rotaciones en los qubits individuales. Los ángulos de rotación pueden ser elegido a través de la función no lineal: \\phi:\\vec{x} \\rightarrow (0,2\\pi]\\times(0,2\\pi]\\times[0,\\pi], por lo que el mapa de características queda definido como:\n\\vec{x_{i}}\\rightarrow \\phi_{i}(\\vec{x}) = U_{\\vec{x_{i}}}\\ket{0}_{i} \\quad \\forall i\\in 1,2,\\cdots, n. \nUn ejemplo de mapa de características podría ser el caso concreto de 3 qubits, donde vamos a utilizar la puerta genérica U_{3}\n\nNo obstante, podemos encontrar mapas de características que jueguen con el entrelazamiento como:\n\nPara continuar lo que haremos es dados \\vec{x_{i}} y \\vec{x_{j}}, será buscar el valor \\bra{0}^{\\otimes n}U^{\\dagger}_{\\vec{x_{j}}}U_{\\vec{x_{i}}}\\ket{0}^{\\otimes n}, ya que este es el producto interno definido dentro del espacio de Hilbert, para generar la matriz de Gram y poder resolver nuestro problema. Este valor podría ser complejo y nos interesa quedarnos con el valor real, lo que podemos hacer con un Hadamard Test, de esta forma:\n\\mathbb{R}(\\bra{0}^{\\otimes n}U^{\\dagger}_{\\vec{x_{j}}}U_{\\vec{x_{i}}}\\ket{0}^{\\otimes n}) = P(0)-P(1)\nComo la elección del mapa de características es bastante experimental y puede depender del conjunto de datos vamos a utilizar el Principio Variacional para definir nuestro Kernel.\nTransclude of Principio-Variacional#qsvm-variacional\nLa ventaja cuántica de este algoritmo se conseguirá con aquellos kernels que no sean computables en ordenadores clásicos, por este motivo, frecuentemente nos encontramos con kernels que aprovechen la transformada cuántica de Fourier.\nEjemplo de implementación: Clasificación QSMV"},"Quantum-machine-learning":{"slug":"Quantum-machine-learning","filePath":"Quantum machine learning.md","title":"Quantum machine learning","links":["tags/Tema","Modelo-de-clasificación","Modelo-de-regresión"],"tags":["Tema"],"content":"Quantum machine learning\nTema\nEn este tema veremos los modelos de aprendizaje automático clásicos e introduciremos las versiones cuánticas.\nModelo de clasificación\nModelo de regresión"},"Qubit-físico":{"slug":"Qubit-físico","filePath":"Qubit físico.md","title":"Qubit físico","links":["tags/Tema","Sistemas-cuánticos-de-dos-niveles","Criterios-de-DiVicenzo","Candidatos-a-qubits"],"tags":["Tema"],"content":"Qubit Físico Tema\nIndice\nSistemas cuánticos de dos niveles\nCriterios de DiVicenzo\nCandidatos a qubits"},"Qubit":{"slug":"Qubit","filePath":"Qubit.md","title":"Qubit","links":["superposición-cuántica","Notación-de-Dirac","estado-puro","estado-mixto","estados-de-Bell"],"tags":[],"content":"Qubit\nEl qubit es la unidad mínima de información en el marco de la teoría de la información cuántica.\nLos qubits se encuentran en un estado de superposición cuántica. El estado de un qubit en Notación de Dirac sería:\n\nEs decir el qubit existe en cualquier estado entre |1&gt; y |0&gt;. Su representación% en la esfera de Bloch es:\n\nLos qubits pueden ser un sistema en estado puro o. estado mixto\nExisten ciertos sistemas de qubits que están entrelazados, lo que les da una serie de propiedades muy interesantes, como los estados de Bell"},"Qubits-Superconductores":{"slug":"Qubits-Superconductores","filePath":"Qubits Superconductores.md","title":"Qubits Superconductores","links":["tags/Tema","Efecto-Josephson","Qubits-de-fase","Qubits-de-flujo","Qubits-de-carga","transmón","Puertas-cuánticas-con-transmones","Medición-Qubits-Superconductores"],"tags":["Tema"],"content":"Qubits Superconductores Tema\nEl reto ahora es encontrar en la naturaleza un sistema cuántico que tenga dos estados en superposición, y que estos dos estados estados estén bien diferenciados del resto de posibles estados del sistema físico en cuestión.\nLos qubits basados en superconductores están basados en el Efecto Josephson. Tenemos estos tres tipos de qubits:\n\nQubits de fase\nQubits de flujo\nQubits de carga\n\nLas más usados actualmente por compañías como IBM y Google son los qubits de carga, en concreto el transmón.\nCon el transmón podemos implementar todas la puertas cuánticas de esta manera: Puertas cuánticas con transmones. Por último necesitamos medir el estado de estos qubits al terminar el cálculo: Medición Qubits Superconductores"},"Qubits-Trampa-de-Iones":{"slug":"Qubits-Trampa-de-Iones","filePath":"Qubits Trampa de Iones.md","title":"Qubits Trampa de Iones","links":["tags/Tema","Trampa-de-Paul","Trampa-de-Penning","enfriamiento-Doppler","Inicialización-qubits-trampa-de-iones","lectura-qubits-trampa-de-iones","puertas-cuánticas-con-trampas-de-iones","Trampas-de-Paul-planas"],"tags":["Tema"],"content":"Qubits Trampa de Iones Tema\nLos computadores formados por qubits basados en trampas de iones, se basan en atrapar iones en una región del espacio. Una de sus principales ventajas es el tiempo de decoherencia, debido a la estabilidad de los estados vibracionales de los iones en su potencial de confinamiento.\nSu principal desventaja es la escalabilidad, debido a que es difícil mantener mucho iones confinados en una región pequeña del espacio. Aunque se han propuesto ciertas soluciones para resolver este problema, como hacer interactuar grupos de iones de distintas trampas mediante fotones.\nTrampa de Iones\nSon dispositivos que mediante la aplicación de campos eléctricos y magnéticos, son capaces de confinar iones en el espacio. Las trampas más famosas son Trampa de Paul y Trampa de Penning. Para generar los iones, se introduce un gas de átomos neutros que se ionizan cuando están el volumen de la trampa. Estos iones son enfriados por técnicas de enfriamiento láser para reducir su energía al nivel fundamental de la trampa. La combinación entre el potencial eléctrico de la trampa y la repulsión de los iones atrapados forman un cristal lineal de iones que pueden ser utilizados como qubits.\nUna de las ventajas de estos sistemas es que no requiere crioestatos, ya que como los iones no están en contacto con el material, si no que están suspendidos, pueden ser enfriados por técnicas de enfriamiento láser como el enfriamiento Doppler. En muchos casos el mismo láser que se utiliza para operar y medir los qubits es el mismo que se usa para enfriarlos.\nManipulación y puertas cuánticas\nNecesitamos procesos para la Inicialización qubits trampa de iones y lectura qubits trampa de iones. Por último para poder crear ordenadores cuánticos con estos qubits, necesitamos poder formar puertas cuánticas con trampas de iones.\nActualmente los ordenadores basados en trampas de iones utilizan Trampas de Paul planas"},"Qubits-de-átomos-neutros":{"slug":"Qubits-de-átomos-neutros","filePath":"Qubits de átomos neutros.md","title":"Qubits de átomos neutros","links":["tags/Tema","Trampas-de-átomos","Carga-e-inicialización-registro-átomos-neutros","Puertas-cuánticas-con-átomos-neutros","Medición-qubits-átomos-neutros"],"tags":["Tema"],"content":"Qubits de átomos neutros Tema\nA diferencia de los iones, no podemos confinar los átomos sin carga con trampas de Paul o Penning, para ellos utilizamos pinzas ópticas, que son capaces de ejercer una fuerza suficiente como para actuar con el momento dipolar instantáneo de los átomos neutros. Trampas de átomos.\nUna vez formada la trampa atómica por interferencia de lásers, es necesario cargarla con átomos neutros mediante Carga e inicialización registro átomos neutros.\nCon nuestros registros inicializados debemos ser capaces de aplicar Puertas cuánticas con átomos neutros, donde hemos visto que somos capaces de crear puertas de un qubits que contemplan todas las rotaciones en la esfera de Bloch y puertas cuánticas de dos qubits con estados entrelazados.\nPor último nos quedan las Medición qubits átomos neutros.\nLa posibilidad de medir el estado conjunto de qubits que disponen de un conjunto universal de puertas cuánticas, y con una potencial escalabilidad, convierte a los sistemas de átomos neutros en un buen candidatos para fabricar un ordenado cuántico práctico."},"Qubits-de-carga":{"slug":"Qubits-de-carga","filePath":"Qubits de carga.md","title":"Qubits de carga","links":["transmón"],"tags":[],"content":"Qubits de carga\nPor ultimo vamos a explicar el principio de funcionamiento de los qubits de carga. El planteamiento fundamental es un circuito en el que distinguimos entre isla, que se trata de un superconductor aislado del resto del circuito y la reserva, que también es un superconductor. La isla y la reserva están muy juntos, por lo que es posible que desde la reserva, por efecto túnel, aparezcan pares de Cooper en la isla (efecto Josephson).\nSi aparece un par de Cooper con carga q=2e en la isla, se produce un desequilibrio del sistema que podemos detectar. Entonces conseguimos nuestros sistema a dos niveles, siendo \\ket{0} cuando no hay pares de Coopper en la isla y \\ket{1} cuando hay un número determinado n de pares de Cooper en la isla, como por ejemplo 1. Para evitar que el sistema no pase al siguiente estado excitado se elige cuidadosamente el valor de la capacitancia Cg que vemos en la figura:\n\nBasándose en este diseño, se inventó el transmón , un tipo de qubit de carga menos sensible al ruido de carga. Actualmente el transmón es el tipo de qubit más utilizado en procesadores cuánticos."},"Qubits-de-fase":{"slug":"Qubits-de-fase","filePath":"Qubits de fase.md","title":"Qubits de fase","links":[],"tags":[],"content":"Qubits de fase\nUn qubit de fase (Martinis et al., 2002) consiste básicamente en una una unión Josephson por la que pasa una corriente polarizada. Las componentes inductiva y capacitiva de la uni ́on Josephson hace que este circuito se comporte como resonador LC no armónico, donde el estado en reposo y el primer estado excitado de energía conformarán los dos estados del qubit. Normalmente la corriente polarizada que pasa por la uni ́on es muy cercana a la corriente crítica Ic, por lo tanto el potencial no armónico se puede aproximar con un potencial cúbico y el espectro de energía tiene esta forma:\n\nPara pedir un el estado de un qubit de fase hacemos uso de pulsos de microondas y de un dispositivo que llamado SQUID(superconducting quantum interference device), que es un magnetómetro muy preciso basado en el efecto Josepshon de corriente continua. Como se ilustra en la figura, si aplicamos un pulso de microondas de frecuencia \\omega_{21} cuando el qubit está en \\ket{1}, pasará al siguiente estado excitado \\ket{2}, lo que provoca que aparezca una tensión (v) en el SQUID acoplado al circuito, y ahí tendremos nuestro ’1’. En cambio, si el estado del qubit es \\ket{0}, el pulso de microondas no hará que salte al siguiente estado excitado, y no aparecerá ninguna tensión en el SQUID, por lo tanto será nuestro ’0’."},"Qubits-de-flujo":{"slug":"Qubits-de-flujo","filePath":"Qubits de flujo.md","title":"Qubits de flujo","links":[],"tags":[],"content":"Qubits de flujo\nLos llamados qubits de flujo (Orlando et al., 1999), consisten en un bucle o anillo superconductor el cual ”cortamos” introduciendo uniones Josephson, siendo los diseños más comunes los bucles con 1 o 3 uniones Josepshon. El flujo de pares Cooper en un un bucle superconductor induce un campo magnético que tendrá una polarización u otra en función de la dirección\ndel flujo de la superiormente. El efecto túnel cuántico de las uniones Josepshon provoca que el flujo del campo magnético esté en un estado de superposición, el cual podemos expresar como: \\ket{\\Psi} =\\alpha \\ket{\\uparrow} + \\beta \\ket{\\downarrow}. Formamos así los estados base de nuestro qubit.\n\nPodemos controlar los qubits  de flujo mediante pulsos electromagnéticos de características muy concretas. Cómo en en los qubits de fase, para medir el estado utilizamos un dispositivo SQUID, ya que como hemos dicho se trata de un magneto ́metro, lo que es ideal para medir estos qubits."},"Qubits-de-puntos-cuánticos":{"slug":"Qubits-de-puntos-cuánticos","filePath":"Qubits de puntos cuánticos.md","title":"Qubits de puntos cuánticos","links":["tags/Tema","Confinamiento-cuántico","Puntos-cuánticos-semiconductores"],"tags":["Tema"],"content":"Qubits de puntos cuánticos Tema\nPara entender los puntos cuánticos, debemos introducir el concepto de Confinamiento cuántico, mediante el cual reduciremos dimensiones espaciales.\nExisten diversas técnicas para crear puntos cuánticos, cómo coloidales o epitaxiales, pero los más usados en computación cuántica son los Puntos cuánticos semiconductores\nTrabajo sobre los puntos cuánticos cuánticos semiconductores, hablando de los basados en carga y en espín:\n"},"Redes-neuronales-cuánticas":{"slug":"Redes-neuronales-cuánticas","filePath":"Redes neuronales cuánticas.md","title":"Redes neuronales cuánticas","links":["tags/Tema","Introducción-redes-neuronales-clásicas","Derivación-en-circuitos-cuánticos","Barren-Plateaus"],"tags":["Tema"],"content":"Redes neuronales cuánticas\nTema\n\n\nIntroducción redes neuronales clásicas\n\n\nTras definir la Derivación en circuitos cuánticos, podemos generalizar el concepto de redes neuronales en la computación cuántica. Nos vamos a centrar en el reemplazo de neuronas clásicas por neuronas cuánticas.\n\nA diferencia de la neurona clásica, aquí no existe definición estándar a la hora de crear una función que trabaje con las ponderaciones. En este caso, en vez de añadir una función de activación arcotangencial, usamos el valor esperado sobre uno de los qubits.\nPodemos construir una red neuronal híbrida, por ejemplo siendo la última neurona una cuántica. La idea es que las neuronas clásicas, interpolan a la función objetivo a través de funciones polinómicas, y las neuronas cuánticas, a través de funciones trigonométricas.\nInconvenientes\nExisten varios inconvenientes de las redes neuronales, el primero que pueden ser vistas como cajas negras, y no sabemos porque se han tomado ciertas decisiones.\nOtro problema es que las funciones tiene muchos mínimos locales, por lo tanto usando el descensor de gradiente, es fácil que caigamos en un mínimo local y no en el global.\nUno de los mayores inconvenientes actuales es el Barren Plateaus."},"Relaciones-de-indeterminación":{"slug":"Relaciones-de-indeterminación","filePath":"Relaciones de indeterminación.md","title":"Relaciones de indeterminación","links":["Principio-de-incertidumbre"],"tags":[],"content":"Relaciones de indeterminación\nSe trata de una generalización del Principio de incertidumbre de Heisenberg\nSuponemos dos operadores genericos A y B\n"},"Representación-matricial-momento-angular":{"slug":"Representación-matricial-momento-angular","filePath":"Representación matricial momento angular.md","title":"Representación matricial momento angular","links":[],"tags":[],"content":"Representación matricial momento angular\n\n"},"SVM-Clásico":{"slug":"SVM-Clásico","filePath":"SVM Clásico.md","title":"SVM Clásico","links":[],"tags":[],"content":"Support Vector Machine clásico\nSVM es un clasificador binario lineal, ya que separa dos clases a través de hiperplanos. Idea del funcionamiento:\n\nPara separar los puntos rojos y verdes, hay infinidad de planos, sin embargo para SVM no es suficiente con encontrar un plano, si no que tiene que encontrar aquel plano que maximice las distancias entre las dos clases. Contra mayor sea la diferencia entre conjuntos, mayor tolerancia tendremos a errores.\nLa distancia entre nuestro Hiperplano H y los puntos más cercanos de ambas clases recibe el nombre de margen d, y los puntos más cercanos a H se conocen como puntos soporte.\nDesarrollo matemático\nDefinimos H como:\nH = \\{\\vec{x} \\in \\mathbb{R}^n /\\vec{x}\\cdot \\vec{w} +b =0\\}\ncomo el hiperplano buscado definido por \\vec{w} \\in \\mathbb{R}^n y b\\in\\mathbb{R}. Por otro lado, llamaremos \\Omega al conjunto de nuestros datos o vectores de características y f(\\vec{x}) como el valor de la clase asociado a cada \\vec{x}\\in \\Omega. De esta forma, será suficiente encontrar unos parámetros \\vec{w} y b que cumplan:\nf(\\vec{x})(\\vec{w} \\cdot \\vec{x}+b) \\geq 0\nya que dada la ecuación de un plano de la forma \\vec{w} \\cdot \\vec{z} + b =0 tendremos que \\vec{w} \\cdot \\vec{x} + b &gt; 0 si \\vec{x} está en un lado del plano y \\vec{w} \\cdot \\vec{x} + b &lt; 0 si está en el otro lado.\nAhora bien, si queremos maximizar la longitud del margen, podemos definir estos hiperplanos de soporte como:\nH_{1} &amp;= \\{\\vec{z} \\in \\mathbb{R}^n /\\vec{z}\\cdot \\vec{w} +b =1\\} \\\\\nH_{2} &amp;= \\{\\vec{z} \\in \\mathbb{R}^n /\\vec{z}\\cdot \\vec{w} +b =-1\\} \n\\end{align}$$\nLa distancia entre estos hiperplanos las definimos como:\n\n$$d = \\frac{2}{\\mid\\mid \\vec{w}\\mid \\mid ^2}$$\nPor lo tanto, el problema a minimizar es el siguiente\n\n$$min(\\frac{\\mid\\mid \\vec{w}\\mid \\mid ^2}{2})$$\nsujeto a $f(\\vec{x_{i}})(\\vec{w} \\cdot \\vec{x_{1}}+b) \\geq 1 \\quad \\forall \\vec{x_{i}} \\in \\Omega$\n\nEste problema es equivalente a minimizar una función cuadrática convexa que podemos resolver con el uso de multiplicadores de Lagrange. \nUna de las grandes ventajas de este tipo de funciones es que existe un único mínimo local que coincide con el global, por lo tanto no tenemos el riesgo de caer en mínimos locales. En base a la función a objetivo y las restricciones definidas, el problema es equivalente a encontrar un mínimo en la siguiente función:\n\n$$L =\\frac{\\mid\\mid \\vec{w}\\mid \\mid ^2}{2} + \\sum_{i=1}^m \\alpha_{i}[f(\\vec{x_{i}})(\\vec{w} \\cdot \\vec{x_{i}}+b) - 1] $$\nsiendo $\\alpha_{i}$ los coeficientes de Lagrange. Si buscamos un mínimo en dicha función, a de cumplirse que la derivada con respecto a $\\vec{w}$ y $b$ sea nula. Por lo tanto si derivamos respecto a estos dos parámetros y sustituimos, tenemos:\n\n$$L&#039;= -\\sum_{i=1}^m\\alpha_{i}+\\frac{1}{2}\\sum_{i=1}^m\\sum_{j=1}^m \\alpha_{i}\\alpha_{j}f(\\vec{x_{i}})f(\\vec{x_{j}})\\vec{x_{i}} \\cdot \\vec{x_{j}}$$\nEn este punto, las únicas variables son los parámetros $\\vec{\\alpha}$, por lo que calcularemos su valor mínimo con un [[Descenso del gradiente]] y una vez calculado $\\vec{\\alpha}$, recuperamos los valores de $\\vec{w}$ y b."},"Seno-y-coseno":{"slug":"Seno-y-coseno","filePath":"Seno y coseno.md","title":"Seno y coseno","links":[],"tags":[],"content":"Seno y coseno\n"},"Shift-rule":{"slug":"Shift-rule","filePath":"Shift-rule.md","title":"Shift-rule","links":[],"tags":[],"content":"Shift-rule\n# Gradients of parameterized quantum gates using the parameter-shift rule and gate decomposition\nSe trata de un método para aproximar gradientes de circuitos cuánticos respecto a sus parámetros. Se define cómo:\n\\frac{{\\partial g(\\vec{\\theta})}}{\\partial \\theta_{i}} = \\frac{1}{2}g(\\vec{\\theta}+e_{i} \\frac{\\pi}{2})- \\frac{1}{2}g(\\vec{\\theta}-e_{i} \\frac{\\pi}{2})\nSiendo e_{i} el vector de ceros con un uno en la i-ésima posición. Ejemplo para f(x) = sin(x):\n\nf&#039;(x) = \\frac{1}{2}\\sin\\left( x + \\frac{\\pi}{2} \\right) - \\frac{1}{2}\\sin\\left( x - \\frac{\\pi}{2} \\right) = \\sin\\left( \\frac{\\pi}{2} \\right)\\cos(x) = \\cos(x)\nComo podemos ver el resultado es correcto. Aunque esta función no sirve para todos los circuitos, si que sirve con aquellos en los que los parámetros se encuentren dentro de puertas de rotación R_{X}, R_{Y} y R_{Z}.\nUtilicemos como ejemplo R_{Y}:\n \\cos \\frac{x}{2}  &amp; -\\sin \\frac{x}{2} \\\\\n\\sin \\frac{x}{2}  &amp; \\cos\\ \\frac{x}{2} \n\\end{pmatrix}$$\nA continuación, aplicamos a dicha puerta un estado arbitrario:\n\n$$\\begin{pmatrix}\n \\cos \\frac{x}{2}  &amp; -\\sin \\frac{x}{2} \\\\\n\\sin \\frac{x}{2}  &amp; \\cos\\ \\frac{x}{2} \n\\end{pmatrix} \\begin{pmatrix}\n\\alpha \\\\\n\\beta\n\\end{pmatrix} = \\begin{pmatrix}\n \\alpha\\cos \\frac{x}{2}  &amp; -\\beta\\sin \\frac{x}{2} \\\\\n\\alpha\\sin \\frac{x}{2}  &amp; \\beta\\cos\\ \\frac{x}{2} \n\\end{pmatrix}$$\n\nCalculando el valor esperado, obtenemos nuestra función $g(x)$:\n$$g(x) = \\alpha\\cos \\frac{x}{2}   -\\beta\\sin \\frac{x}{2} \n-\\alpha\\sin \\frac{x}{2}   +\\beta\\cos\\ \\frac{x}{2}$$"},"Simetria-espacial":{"slug":"Simetria-espacial","filePath":"Simetria espacial.md","title":"Simetria espacial","links":[],"tags":[],"content":"Simetria espacial\n"},"Simetria-rotacional":{"slug":"Simetria-rotacional","filePath":"Simetria rotacional.md","title":"Simetria rotacional","links":[],"tags":[],"content":"Simetria rotacional\n"},"Simetrias-y-grupos":{"slug":"Simetrias-y-grupos","filePath":"Simetrias y grupos.md","title":"Simetrias y grupos","links":["tags/Tema","Transformaciones-de-simetria-clásicas","Transformaciones-de-simetria-cuánticas","Teoremas-de-Wigner","Simetria-espacial","Simetria-rotacional","Paridad","Inversion-temporal"],"tags":["Tema"],"content":"Simetrias y grupos Tema\nIndice\nTransformaciones de simetria clásicas\nTransformaciones de simetria cuánticas\nTeoremas de Wigner\nSimetria espacial\nSimetria rotacional\nParidad\nInversion temporal"},"Sistemas-cuánticos-de-dos-niveles":{"slug":"Sistemas-cuánticos-de-dos-niveles","filePath":"Sistemas cuánticos de dos niveles.md","title":"Sistemas cuánticos de dos niveles","links":["Qubit","Espacio-de-Hilbert","superposición-cuántica","Puertas-cuánticas"],"tags":[],"content":"Sistemas cuánticos de dos niveles\nDesde un punto de vista matemático, el Qubit tiene estados claramente diferenciados, como los bits clásicos y también estados intermedios dentro de un espacio vectorial complejo (Espacio de Hilbert). Añadir qubits al sistema, implica añadir dimensiones extra al espacio computacional.\nEste sistema a dos niveles debe poder existir en dos estados independientes bien diferenciados o en cualquier superposición cuántica de estos. Por lo tanto el estado vendrá descrito en un vector complejo de dimensión 2.\nPara inicializar, rotar, entrelazar, etc… los qubits utilizamos unos operadores lineales que llamamos Puertas cuánticas. Son interacciones físicas con los qubits que pueden tomar diferentes formas en función del soporte físico elegido.\nFinalmente debemos ser capaces de medir, que nos eso otra cosa que proyectar este estado del sistema en una base computacional, colapsando la función de onda del sistema."},"Sistemas-de-spin-un-medio":{"slug":"Sistemas-de-spin-un-medio","filePath":"Sistemas de spin un medio.md","title":"Sistemas de spin un medio","links":["tags/Tema","Experimento-de-Stern-Gerlach","Estados-base-para-sistemas-de-espín-un-medio","Operadores-escalera","Transformaciones-unitarias-sistemas-spin-un-medio","Producto-exterior-operadores-spin","Matrices-de-Pauli","Evolución-temporal-sistemas-spin-un-medio","Operador-densidad-sistemas-spin-un-medio"],"tags":["Tema"],"content":"Sistemas de spin 1/2 Tema\nIndice\nExperimento de Stern-Gerlach\nEstados base para sistemas de espín un medio\nOperadores escalera\nTransformaciones unitarias sistemas spin un medio\nProducto exterior operadores spin\nMatrices de Pauli\nEvolución temporal sistemas spin un medio\nOperador densidad sistemas spin un medio"},"Teorema-canal-con-ruido":{"slug":"Teorema-canal-con-ruido","filePath":"Teorema canal con ruido.md","title":"Teorema canal con ruido","links":[],"tags":[],"content":"Teorema canal con ruido\nEn este sistema de comunicación, el mensaje W se transmite a través de un canal con ruido, usando funciones de codificación y descodificación.\n\n\nEl codificador mapea el mensaje W en una secuencia predefinida de símbolos de longitud n. Esta secuencia es X^{n}.\nEl canal distorsiona estos símbolos, y a la salida tenemos la secuencia Y^{n}. Esta señal es la entrada del decodificador.\nEl decodificador mapea la secuencia recibida Y^{n} en una estimación de mensaje W&#039;.\n\nEn este modelo, la probabilidad de error se define como P_{e}=Pr\\{W&#039; \\neq W\\}\nFormulación matemática canal discreto con ruido\nDefinimos:\n\np(X): probabilidades asociadas a la secuencia de entrada X. Es decir p(x_{1}), p(x_{2}), \\dots,p(x_{n}).\np(Y|X): matriz del canal (matriz de transición del canal). Cada uno de sus elementos relaciona la probabilidad condicional de un elemento de la salida y_{j}, por un elemento de la entrada x_{i}. Por tanto esta matriz modela el efecto del ruido en el canal.\np(Y): probabilidades asociadas a las secuencias de salida Y.\n\nEntonces:\np(Y)=p(X|Y)\\cdot p(X)\nTeorema fundamental canal discreto con ruido\nEstas son las variables que intervienen en el teorema:\n\nC: capacidad de un canal discreto y sin memoria.\nX: Entrada, variable discreta aleatoria.\nY: Salida, variable discreta aleatoria.\nP_{X}: Distribución de la entrada X.\n\nEnunciado de Shannon (1948)\nPara un canal discreto y sin memoria, la capacidad C del canal esta definido en términos de la información mutua I(X;Y) y es: C = max(I(X;Y))\nLa capacidad del canal tiene la siguiente propiedad: para cada \\epsilon &gt;0 y ratio R&lt;C para un N suficientemente grande, existe un código de longitud N y ratio \\geq R y un algoritmo de decodificación con probabilidad máxima de error &lt; \\epsilon.\nSi una probabilidad de error de bit p_{b} es aceptable, entonces ratos de transmisión de hasta R(p_{b}) son conseguibles donde:R(p_{b})=\\frac{C}{1-H_{2}(p_{b})}\nSiendo H_{2}(p_{b}) es la función de entropía binaria.\nRepresentación gráfica\nVamos a representar el ratio R en y la probabilidad de error de bit p_{b}:\n\nPodemos ver la zonas del plano R,p_{b} con ratios alcanzables en función de C y p_{b}."},"Teorema-canal-sin-ruido":{"slug":"Teorema-canal-sin-ruido","filePath":"Teorema canal sin ruido.md","title":"Teorema canal sin ruido","links":[],"tags":[],"content":"Teorema canal sin ruido\nSe trata de un problema de representación eficiente de los símbolos que genera una fuente.\nEnunciado\nConsideramos una fuente sin memoria y entropía finita. y sea H la entropía de la fuente y \\epsilon un número positivo. Entonces podemos codificar los símbolos que genera la fuente a un ratio R tal que:R = H + \\epsilon\nEsta expresión indica que la entropía representa un limite fundamental en el número de bits que se necesitan para representar los símbolos de la fuente.\nEnunciado matemático\nSi una fuente con entropía H(X) es codificada usando un alfabeto B de tamaño b, dado un número \\epsilon &gt; 0 para un número n lo suficientemente grande, existe una función codificada c(X) tal que:\\frac{1}{n}E\\mid c(X)\\mid \\leq \\frac{H(X)}{\\log b}+\\epsilon\nEsto implica que \\lim_{ n \\to \\infty } X = \\{X_{1},X_{2},\\dots,X_{n}\\}  = \\frac{H(X)}{\\log b}\nY por lo tanto, no se podrá codificar el mensaje que genera una fuente con una longitud inferior a \\frac{H(X)}{\\log b}\nIdea intuitiva\nDe una forma más intuitiva, si N si el número de variables aleatorias mutuamente independientes (independientes e idénticamente distribuidos). Estas N variables, puede comprimirse en más de N\\cdot H(X) bits sin pérdida de información. Si N \\rightarrow \\infty, la perdida de información disminuye, pero si estas N variables aleatorias se comprime en menos de N\\cdot H(X), se perderá información,\n==De este teorema se obtiene que la entropía H(X) proporciona un límite inferior y universal para la compresión de mensajes=="},"Teorema-de-Noether":{"slug":"Teorema-de-Noether","filePath":"Teorema de Noether.md","title":"Teorema de Noether","links":[],"tags":[],"content":"Teorema de Noether\nSi las ecuaciones de Euler-Lagrange del movimiento, son invariantes para un cambio de coordenadas, entonces, existe una integral de movimiento. Quiere decir que, para cada simetria que se cumpla, una magnitud física se conserva.\n\nRelación entre simetrias y conservaciones de magnitudes\n"},"Teorema-de-Schumacher":{"slug":"Teorema-de-Schumacher","filePath":"Teorema de Schumacher.md","title":"Teorema de Schumacher","links":["Entropía-de-Von-Nuemann","fidelidad","distancia-de-traza"],"tags":[],"content":"Teorema de Schumacher\nTeorema sobre codificación en en sistemas cuánticos.\n\n\nEl teorema de Schumacher, nos dice que podemos codificar una mensaje, siendo la tasa de compresión optima la Entropía de Von Nuemann.\nEs importante conocer las similitudes y deferencias entre dos sistemas cuánticos usados para codificar, para ellos usamos la fidelidad y distancia de traza"},"Teorema-de-Shannon-Hartley":{"slug":"Teorema-de-Shannon-Hartley","filePath":"Teorema de Shannon-Hartley.md","title":"Teorema de Shannon-Hartley","links":[],"tags":[],"content":"Teorema de Shannon-Hartley\nA veces también denominado tercer teorema de Shannon, proporciona la velocidad máxima a la que la información puede ser transmitida por un canal con un ancho de banda dado en presencia de ruido. (Canal analógico con ruido gaussiano).\n\nC: Capacidad del canal.\nW: Ancho de banda (Hz).\nN_{0}: Densidad espectral del ruido blanco aditivo gaussiano.\nP: Potencia media transmitida.\nC = W\\log_{2}\\left( 1+\\frac{P}{N_{0}W} \\right) \\text{bits/s}\nEl termino \\frac{P}{N_{0}W} es el ratio señal a ruido SNR.\nLa capacidad del canal se alcanza cuando la fuente parece ruido, se puede demostrar que:C \\rightarrow \\frac{P}{N_{0}}\\log_{2}e\nSi escribimos esta expresión en términos de la energía por bit (E_{b}=\\frac{P}{C}).\nEntonces obtenemos el limite de Shannon:\n\\frac{E_{b}}{N_{0}}\\rightarrow \\log_{2}e=0,693\n"},"Teorema-fundamental-del-álgebra":{"slug":"Teorema-fundamental-del-álgebra","filePath":"Teorema fundamental del álgebra.md","title":"Teorema fundamental del álgebra","links":[],"tags":[],"content":"Teorema fundamental del álgebra\n"},"Teoremas-de-Shannon":{"slug":"Teoremas-de-Shannon","filePath":"Teoremas de Shannon.md","title":"Teoremas de Shannon","links":["tags/Tema","Entropia-de-Shannon","Entropía-conjunta-multivariable","Entropía-condicional-de-dos-variables","Entropía-de-Von-Nuemann","Teorema-canal-sin-ruido","Teorema-canal-con-ruido","Teorema-de-Shannon-Hartley"],"tags":["Tema"],"content":"Teoremas de Shannon Tema\nIntroducción\nEn 1948 Shannon publicó el articulo Teoría de la matemática de la información. Este articulo se centra en como codificar la información que un emisor desea transmitir. Aparece el concepto de Entropia de Shannon, una medida de la información contenida en el mensaje. En función de como es la distribución de probabilidad de X, también se mencionan los conceptos de Entropía conjunta multivariable y Entropía condicional de dos variables.\nInformación mutua\nSe define información mutua I(X;Y) al número de unidades de información sobre X que podemos adquirir leyendo Y.\nEn el caso de un canal con ruido, la información mutua I(X;Y) es la cantidad de información que se puede transmitir a través del canal Y.\nI(X;Y)= H(X)-H(X|Y) = H(Y) - H(Y|X)\nRelación con la cuántica\nEl equivalente de la entropía de Shannon para un sistema cuántico es la Entropía de Von Nuemann\nTeoremas de canales de comunicación\nShannon clasificó sus teoremas según los canales de comunicación en dos:\n\nTeorema canal sin ruido\nTeorema canal con ruido\n\nRelación entre los teoremas de Shannon\nEl primer teorema esta enfocado a la compresión de datos, cuanto podemos comprimir un mensaje sin perder información. El segundo teorema contempla el efecto del ruido en el canal. Por lo tanto son complementarios y podemos implementar redundancia para mitigar los errores.\nPor último, tenemos el Teorema de Shannon-Hartley."},"Teoremas-de-Wigner":{"slug":"Teoremas-de-Wigner","filePath":"Teoremas de Wigner.md","title":"Teoremas de Wigner","links":[],"tags":[],"content":"Teoremas de Wigner\nTodas las transformaciones de simetria, pueden implementarse con un operador isométrico.\n"},"Teoría-de-la-información-cuántica":{"slug":"Teoría-de-la-información-cuántica","filePath":"Teoría de la información cuántica.md","title":"Teoría de la información cuántica","links":["tags/Tema","Ensemble","operador-densidad","Entropía-de-Von-Nuemann","Teorema-de-Schumacher","Canal-de-comunicación-cuántico"],"tags":["Tema"],"content":"Teoría de la información cuántica Tema\nIndice\nEnsemble\noperador densidad\nEntropía de Von Nuemann\nTeorema de Schumacher\nCanal de comunicación cuántico"},"Teoría-de-la-información":{"slug":"Teoría-de-la-información","filePath":"Teoría de la información.md","title":"Teoría de la información","links":["tags/Tema","Entropia-de-Shannon","Canales-de-comunicación","Capacidad-del-canal"],"tags":["Tema"],"content":"Teoría de la información Tema\nIndice\nEntropia de Shannon\nCanales de comunicación\nCapacidad del canal"},"Tiempo-de-decoherencia":{"slug":"Tiempo-de-decoherencia","filePath":"Tiempo de decoherencia.md","title":"Tiempo de decoherencia","links":[],"tags":[],"content":"Tiempo de decoherencia\nEl tiempo de decoherencia es el conjunto de tiempos característico sde las dinámicas de un sistema cuántico en contacnto con su enterno físico. Esto incluye el resto de qubits del procesador, el entorno material, campos externos, etc.\nDe manera genérica puede considerarse como el tiempo en que un estado cualquiera \\ket{\\psi} = a\\ket{0}+\\ket{1} se transforma en un estado mezcla con una matriz de probabilidad \\rho =  |a|^2 \\ket{0}\\braket{ 0}+ |b|^2 \\ket{1}\\bra{1}, comportándose de manera clásica.\n\\\nEl ruido en un qubit implica la decoherencia del estado cuántico y la reducción de su fiabilidad, ciertos sistemas a dos niveles son muy sensibles al ruido.\nPodemos clasificar el ruido en sistemático  o aleatorio:\n\nRuido sistemático: Depende de las características físicas del sistema, en general puede ser identificado y corregido.\nRuido aleatorio: Es muy difícil de indentificar y corregir, ya que proviene de variables incontrolables del enterno del sistema y depende de parametros ajenos al sistema de control.\n"},"Trampa-de-Paul":{"slug":"Trampa-de-Paul","filePath":"Trampa de Paul.md","title":"Trampa de Paul","links":["teorema-de-Earnshaw"],"tags":[],"content":"Trampa de Paul\nLa trampa de Paul o trampa de radiofrecuencia, permite llevar a un ion a un punto de equilibrio mecánico. Esto no es posible conseguir mediante campos eléctricos estáticos, debido al teorema de Earnshaw.\nEl invento de Paul, fue una combinación de campos eléctricos variables orientados de tal manera que la fuerza media ejercida sobre la carga es nula, a frecuencias tales que la partícula no tiene tiempo a escaparse de su región de confinamiento.  De esta manera la partícula se encuentra en un equilibrio dinámico que está continuamente devolviendo a la partícula a la región de interés.\nEsta trampa está formada por una serie de electrodos cuyos potenciales varían con el tiempo de forma sincronizada. La configuración más popular suele ser dos electrodos cilíndricos o hiperbólicos enfrentados y un electrodo anular rodeado el espacio entre ellos. La polaridad de los electrodos cilíndricos y el electrodo anular es opuesta, de manera que, durante medio ciclo, las partículas cargadas son expulsadas de la región de confinamiento en la dirección axial y atraídas en la radial, mientras que, en en el otro medio ciclo ocurre lo contrario.\n\nComo podemos en la figura, la oscilación del campo eléctrico genera un potencial periódico que deforma la nube de partículas cargadas de manera periódica, lo que provoca que alcancen un equilibrio dinámico en el que el movimiento medio de la partícula es nulo."},"Trampa-de-Penning":{"slug":"Trampa-de-Penning","filePath":"Trampa de Penning.md","title":"Trampa de Penning","links":["Trampa-de-Paul"],"tags":[],"content":"Trampa de Penning\nLa trampa de Penning utiliza una combinación de campos eléctricos y magnéticos para obtener el equilibrio de fuerzas necesario. Mediante un campo magnético en la dirección axial confina las partículas en la dirección radial, mientras que una configuración de electrodos similar a los de la Trampa de Paul confinan la partícula en la dirección axial.\nEsta combinación atrapa los iones en un campo describiendo trayectorias epicíclicas que se pueden caracterizar por tres frecuencias características que dependen de la intensidad del campo magnético, la masa y la carga del ion.\nLos movimientos que describe el ion son ciclotrón (GHz) y magnetrón (kHz) y axial:\n\nEsta trampa permite crear cristales bidimensionales de estos qubits, lo que permite una mayor complejidad en los cálculos, pero su implementación es mucho más compleja, sobre todo a la hora de interactuar con los qubits individualmente."},"Trampas-de-Paul-planas":{"slug":"Trampas-de-Paul-planas","filePath":"Trampas de Paul planas.md","title":"Trampas de Paul planas","links":[],"tags":[],"content":"Trampas de Paul planas\nLas trampas de Paul planas o superficiales, se fabrican con métodos litográficos. Consisten en una serie de electrodos y guías de onda que permiten modular el campo electromagnético en la superficie de un chip generando los campos magnéticos oscilantes necesarios para crear el potencial de confinamiento necesario para atrapar los iones.\nMediante estas estructuras es posible atrapar pequeños grupos de iones sobre los que se puede operar mediante láseres de manera independiente, efectuando operaciones a partir de las técnicas descritas anteriormente.\n\nCon estas trampas podemos desplazar iones de una región a otra como vemos en la imagen. Esto permite la interacción entre qubits que normalmente estarían desacoplados, así como interrelacionar diferentes registros a través de un ion mensajero que comparta la información cuántica entre ellos. Normalmente, las puertas cuánticas y las medidas se realizan en una región específica del sistema donde se realizan todas las interacciones con el láser, en la imagen sería el punto rojo.\nCuando se quiere hacer interactuar el estado del conjunto de iones de una trampa con otra, los electrodos dispuesto alrededor de la trampa permiten aplicar un campo eléctrico constante que puede desplazar y guiar a uno de los iones de una trampa a otra. De esta manera podemos tener pequeños registros cuánticos aislados y trasladar uno o varios iones desde los distintos registros a la zona de interacción con el láser para realizar las operaciones sobre los qubits que requiera el algoritmo implementar. Debemos tener en cuenta\n\nDesplazar un ion de una trampa a otra no suele tener efecto negativos respecto al estado del qubit, oeri el estado de movimiento del ion si puede afectar a su estado, por esto, es necesario que el movimiento de una trampa a otra no sea demasiado acelerado.\nPor otro lado, tiene que ser lo suficientemente rápida como para poder realizar el desplazamiento de ida y vuelta y aplicar las puertas cuánticas necesarias en tiempo cortos para que el qubit no pierda su coherencia.\n\nOperaciones mediante desplazamiento en la trampa de iones\nLas operaciones de desplazamiento se pueden realizar mediante la aplicación  de perfiles de tensión programados con un generador de forma de onda arbitraria o un procesador digital de señales. Estos instrumentos actúan como fuentes de tensión programables. Para estudiar el estado de movimiento de un ion se utilizan las técnicas de Raman, que permite conocer por medios ópticos el estado de movimiento de las partículas. Analizando la intensidad y frecuencia de la emisión Raman es posible determinar el número de iones en un cristal a partir de sus características vibracionales.\nEstos son los tipo de operaciones que pueden realizar mediante el desplazamiento:\nTransporte lineal\nDesplazamiento de un ion o conjunto de iones de un lugar a otro del dispositivo. Se realiza mediante la aplicación de rampas de voltaje en los electrodos de continua, lo que permite desplazar el potencial de confinamiento en una dirección u otra.\nSeparación u unión\nSe puede extraer un ion o un subconjunto de iones de una trampa para desplazarlos por el dispositivo o realizar la unión de dos o varios iones en un nuevo cristal ionico.\nEl proceso de separación o unión de trampas es más complicado de realizar, ya que implica cambiar la forma del potencial de confinamiento durante el periodo de tiempo necesario para realizar la división o la unión. Durante el proceso de creación o destrucción de una barrera entre trampas , la interacción electroestática entre los iones será la dominante, lo que puede provocar el escape de alguno de ello o de introducir oscilaciones en la trampa.\nIntercambio\nEs posible intercambiar las posiciones de los iones dentro de un cristal, lo que posibilita su reordenamiento. Esta operación es equivalente a una puerta SWAP. Para realizar esto se hacen oscilar electrones de la trampa en dirección paralela a esta mientras se manipulan los electrodos de continua para crear un campo eléctrico en la dirección perpendicular. Esto permite que un ion “salte” sobre todo fuera del eje de confinamiento , permitiendo que intercambien sus posiciones."},"Trampas-de-átomos":{"slug":"Trampas-de-átomos","filePath":"Trampas de átomos.md","title":"Trampas de átomos","links":["enfriamiento-Doppler"],"tags":[],"content":"Trampas de átomos\nComo para confinar átomos neutros no podemos usar campos eléctricos, por ello, es necesario utilizar una combinación de campos eléctricos y magnéticos oscilantes.\nLas pinzas ópticas consisten en haces de luz fuertemente focalizados en una región del espacio. En la región de más intensidad del haz se genera un gradiente de campo eléctrico muy pronunciado, que es capaz de ejercer una fuerza sobre las partículas dieléctricas de su entorno. Esta fuerza puede ser atractiva o repulsiva en función del indice de refracción, esta fuerza es del orden de piconewtons.\nPara poder tener un ordenador, es necesario disponer de más de un átomo por trampa, por lo que se utilizan técnicas interferométricas para ordenarlos. La combinación de varios haces de luz crean un patrón de interferencia que permitirá atrapar los átomos entre las regiones oscuras y brillantes. Para la computación cuántica, se utilizan trampas uni- y bidimensionales, ya que es necesario una linea de visión para acceder a lo átomos.\nA estos átomos se les hace perder temperatura por enfriamiento Doppler, así su energía cinética es baja, lo que favorece el confinamiento al disminuir sus oscilaciones.\n\nComparación con trampas de iones\nEl potencial de confinamiento de estas trampas es mucho más débil que en el caso de los iones, por lo tanto, es más fácil que el átomo escape de la trampa por la interacción con su entorno. Aunque esto también facilita el poder mover a un átomo de un punto a otro de la trampa.\nLas interacciones entre iones también son mucho más intensas, lo que facilita la interacción entre qubits, pero también limita el número total de qubits que se pueden confinar en un volumen, ya que la repulsión entre iones es muy fuerte y la trampa tiene que luchar contra esa fuerza.\nPor su parte, los átomos neutros interactuan muy levemente por interacciones dipolares instantaneas, lo que permite una mayor densidad de átomos en una región del espacio utilizando un potencial de confinamiento mucho menos intenso. Esto es un punto a favor de la escalabilidad de los sistemas de átomos neutros."},"Transformaciones-de-simetria-clásicas":{"slug":"Transformaciones-de-simetria-clásicas","filePath":"Transformaciones de simetria clásicas.md","title":"Transformaciones de simetria clásicas","links":["Teorema-de-Noether"],"tags":[],"content":"Transformaciones de simetria clásicas\nHomogeneidad del espacio\n\nHomogeneidad del tiempo\n\nIsotropia del espacio\n\nLa relación entre simetrias y conservación de magnitudes viene dado por el Teorema de Noether"},"Transformaciones-de-simetria-cuánticas":{"slug":"Transformaciones-de-simetria-cuánticas","filePath":"Transformaciones de simetria cuánticas.md","title":"Transformaciones de simetria cuánticas","links":[],"tags":[],"content":"Transformaciones de simetria cuánticas\n"},"Transformaciones-unitarias-sistemas-spin-un-medio":{"slug":"Transformaciones-unitarias-sistemas-spin-un-medio","filePath":"Transformaciones unitarias sistemas spin un medio.md","title":"Transformaciones unitarias sistemas spin un medio","links":[],"tags":[],"content":"Transformaciones unitarias sistemas spin un medio"},"Transformada-cuántica-de-Fourier-QFT":{"slug":"Transformada-cuántica-de-Fourier-QFT","filePath":"Transformada cuántica de Fourier QFT.md","title":"Transformada cuántica de Fourier QFT","links":["Base-computacional","Base-Fourier"],"tags":[],"content":"Transformada cuántica de Fourier QFT\nEs la versión cuántica de la transformada discreta de Fourier, una transformación lineal que transforma del dominio del tiempo a la frecuencia. La transformada cuántica de Fourier es una transformación unitaria que transforma de la Base computacional  a Base Fourier.\nLa transformada de Fourier se define como: QFT\\ket{x}\\rightarrow \\frac{{1}}{\\sqrt{ N }}\\sum_{y=0}^{N-1}e^{2\\pi i\\cdot \\frac{xy}{N}} \\ket{k} \nSiendo N =2^n, donde n es el número de qubits, vamos a estudiar en detalle la siguiente demostración para el caso general de n qubits.$$$$$$\\frac{{1}}{\\sqrt{ N }}\\sum_{y=0}^{N-1}e^{2\\pi i\\cdot \\frac{xy}{N}} \\ket{k} = \\frac{1}{\\sqrt{ N }}(\\ket{0}+e^{2\\pi i \\frac{x}{2}} \\ket{1} )\\otimes(\\ket{0}+e^{2\\pi i \\frac{x}{4}}\\ket{1}  )\\otimes \\cdots \\otimes(\\ket{0}+e^{2\\pi i \\frac{x}{2^n}} \\ket{1} )$$\nDemostración caso general n qubits.\n\nImplementación QFT en un circuito cuántico\nVamos a trasladar la expresión anterior a un circuito cuántico.Puesto que:\n\\frac{1}{\\sqrt{2}}(\\ket{0}  + e^{i\\pi x_k}\\ket{1} ) =\n\\begin{cases} \n\\frac{1}{\\sqrt{2}}(\\ket{0}  + e^0\\ket{1} ) = \\frac{1}{\\sqrt{2}}(\\ket{0}  + \\ket{1} ), &amp; x_k = 0 \\\\ \n\\frac{1}{\\sqrt{2}}(\\ket{0}  + e^{\\pi i}\\ket{1} ) = \\frac{1}{\\sqrt{2}}(\\ket{1}  - \\ket{1} ), &amp; x_k = 1\n\\end{cases}\nCorresponde con el comportamiento de la puerta Hadamard sobre x_{k}: \\frac{1}{\\sqrt{2}}(\\ket{0}  + e^{i\\pi x_k}\\ket{1} ) =\n\\begin{cases} \n\\frac{1}{\\sqrt{2}}(\\ket{0}  + \\ket{1} ) = \\ket{+} , &amp; x_k = 0 \\\\ \n\\frac{1}{\\sqrt{2}}(\\ket{1}  - \\ket{1} ) = \\ket{-} , &amp; x_k = 1\n\\end{cases}\nPor otro lado, podemos utilizar la puerta de fase P(\\theta): P(\\theta) = \\begin{bmatrix}\n1 &amp; 0  \\\\\n0 &amp; e^{i\\theta}\n\\end{bmatrix}\nQue lo que hace es:\n\n\\ket{0}\\rightarrow \\ket{0}\n\\ket{1}\\rightarrow e^{i\\theta}\\ket{1}\n\nEjemplo para 3 qubits\nSiendo entonces \\ket{x} = \\ket{x_{2},x_{1},x_{0}} la QFT sería:\nQFT_8\\ket{x} = \\frac{1}{\\sqrt{8}} \\big(\\ket{0} + e^{2\\pi i \\frac{x_0}{2}} \\ket{1}\\big) \n\\otimes \\big(\\ket{0} + e^{2\\pi i \\big(\\frac{x_0}{2^2} + \\frac{x_1}{2}\\big)} \\ket{1}\\big) \n\\otimes \\big(\\ket{0} + e^{2\\pi i \\big(\\frac{x_0}{2^3} + \\frac{x_1}{2^2} + \\frac{x_2}{2}\\big)} \\ket{1}\\big)\nNos fijamos en el último término y aplicamos e^{A+B} = e^Ae^B: (\\ket{0} + e^{2\\pi i \\large(\\frac{x_0}{2^3} + \\frac{x_1}{2^2} + \\frac{x_2}{2}\\large)} \\ket{1}) = \\ket{0}+e^{\\pi i\\frac{x_{0}}{2^2}}e^{\\pi i\\frac{x_{1}}{2}} e^{\\pi ix_{2}} \\ket{1}  \nDesgranado esta expresión tenemos sobre el qubit x_{2} tenemos:\n\nDebe rotar \\pi radianes si el vale \\ket{1}. Corresponde con el comportamiento de la puerta H (revisar esto)\nDebe rotar adicionalmente \\frac{\\pi}{2} si el qubit x_{1} es \\ket{1}. Corresponde con la puerta P\\left( \\frac{\\pi}{2} \\right) controlada por x_{1}\nPor último, deberá rotar adicionalmente \\frac{\\pi}{4} si el qubit x_{0} es \\ket{1}. Corresponde con la puerta P\\left( \\frac{\\pi}{4} \\right) controlada por x_{0}\n\nSi construimos este circuito para el qubit x_{2} tenemos:\n\nCompletando el circuito pera los otros 2 términos siguiendo la misma lógica tenemos el circuito completo que proporciona la transformada de Fourier para 3 qubits.\n"},"Trotterización":{"slug":"Trotterización","filePath":"Trotterización.md","title":"Trotterización","links":["Modelo-Ising"],"tags":[],"content":"Trotterización\nEsta técnica nos permite aproximar exponenciales de Hamiltonianos tipo H=\\sigma^x +\\sigma^z, que como los operadores de Pauli no conmutan entre sí, no podemos expresarlos como el producto de la exponencial de sus componentes. Para conseguirlo nos vamos a basar en el producto Lie-Trotter:\ne^{A+B} = \\lim_{ N \\to \\infty } (e^{A/N}\\cdot e^{B/N})^N \nDe esta manera cuanto más grande sea N, más conseguiremos acercar al valor de la exponencial A+B. La clave de esto es que los bloques e^{A/N} y e^{B/N} si que podemos construirlos, y por lo tanto conseguiremos la exponencial buscada concatenando estos circuitos N veces.\nEn caso de Hamiltonianos tipo Modelo Ising, que solo están formados con puertas \\sigma^z, con N=1, conseguiremos el valor exacto de la exponencial, pero para otros Hamiltonianos, tendremos que elegir un valor de N que sea lo suficientemente preciso pero que no haga el circuito muy largo."},"Unión-Josephson":{"slug":"Unión-Josephson","filePath":"Unión Josephson.md","title":"Unión Josephson","links":["circuito-LC","Oscilador-armónico-cuántico","Sistemas-cuánticos-de-dos-niveles"],"tags":[],"content":"Unión Josephson\nUtilizando este efecto, se desarrollaron los dispositivos conocidos como uniones Josephson, los cuales se tratan de dos superconductores separados por un aislante. Estos dispositivos tienen una inductancia no lineal, por lo tanto, si sustituimos por la inductancia en nuestro circuito LC que funcione como un Oscilador armónico cuántico, conseguimos de esta manera romper la degeneración del espectro de energía.\n\nGracias a la unión Josephson, podemos usar este resonador cuántico a dos niveles como un qubit, ya que somos capaces de distinguir entre estados del espectro de energía y tener así nuestro sistema cuántico a dos niveles.\nEspectro de energía unión Josephson\n\nComo hemos dicho hemos la unión Josepshon permite romper la degeneración la energía del Oscilador armónico cuántico, es decir, la energía para pasar de estado \\ket{0} a \\ket{1} es distinta que la que necesitamos para pasar de \\ket{1} a \\ket{2}. El Hamiltoniano del circuito se puede expresar como:\nH = 4E_{c}n^2 - E_{j}\\cos (\\phi)\nSiendo : \\begin{align}\n&amp;E_{c} = \\frac{e^2}{2(C_{s} + C_{j})} \\\\ \\\\\n&amp;E_{j} = \\frac{I_{c}\\Phi_{0}}{2\\pi}\n\\end{align}\nDonde C es la capacidad total e I_{c} es la corriente crítica de la unión Josephson. Con un diseño adecuado de puertas y control robusto, podemos despreciar el resto de estados de energía que no estén nuestra base computacional. De esta manera, tendríamos un Sistemas cuánticos de dos niveles, asumiendo esto, podemos reducir el Hamiltoniano a\nH = \\omega_{q}\\frac{\\sigma_{z}}{2}"},"VQE":{"slug":"VQE","filePath":"VQE.md","title":"VQE","links":["tags/Tema","Estado-fundamental","ansatz","Observables","Problemas-QUBO","Operadores","Modelo-Ising"],"tags":["Tema"],"content":"Variational Quantum Eigensolver Tema\nSe trata de un algoritmo mixto que utiliza computadores cuánticos y clásicos para encontrar el Estado fundamental de un sistema físico dado. El algoritmo funciona así: dado un ansatz, el procesador cuántico calcula el valor esperado de un Observables, generalmente el Hamiltoniano, y posteriormente un optimizador clásico mejora el ansatz para repetir el proceso hasta encontrar el valor mínimo.\nRelación con problemas QUBO\nLos Problemas QUBO cuyas variables son binarias \\vec{x}, tratan de minimizar una función objetivo f(\\vec{x}). Podemos decir que esta función objetivo es la energía del problema y que nuestra tarea es encontrar el vector \\vec{x} que minimice la energía. El hamiltoniano es el Operadores que representa la energía de un sistema. Los posibles valores de energía de un sistema vienen dados por los valores propios del Hamiltoniano:\nH \\ket{\\phi} = E_{{\\phi}}\\ket{\\phi}\nSiendo \\ket{\\phi} un estado propio del sistema y E_{\\phi} el autovalor que representa la energía asociada a dicho estado.\nDefinimos el valor esperado de un estado \\ket{\\phi} como \\bra{ \\phi}H\\ket{\\phi}. Lo que estamos haciendo es una ponderación de las energías de los estados propios que forman \\ket{\\phi} con la probabilidad que tenemos de observar cada uno de ellos:\n\\bra{ \\phi}H\\ket{\\phi} = \\left( \\sum_{i}^{n}\\bra{u_{i}}\\alpha_{i}^{*}  \\right) H \\left( \\sum_{i}^{n}\\alpha_{i}\\ket{u_{i}} \\right)= \\sum_{i}^{n}  |\\alpha_{i}|^{2}E_{ui}\nDefinir función objetivo con Hamiltoniano\nPara trabajar con este tipo de problemas vamos a trabajar con el Modelo Ising por ejemplo vamos a suponer un sistema de dos variables f(x_{i},x_{j}) entonces vamos a definir el siguiente Hamiltoniano.\n\\begin{pmatrix}\n  f(1,1) &amp; 0 &amp; 0 &amp; 0 \\\\\n  0 &amp; f(1,-1) &amp; 0 &amp; 0 \\\\\n  0 &amp; 0 &amp; f(-1,1) &amp; 0 \\\\ \n  0 &amp; 0 &amp; 0 &amp; f(-1,-1)\n\\end{pmatrix}\nNos gustaría encontrar lo siguiente:\n\\bra{z_{1},z_{2}}H \\ket{z_{1},z_{2}} = f(z_{1},z_{2})  \nEn nuestro ejemplo, si queremos obtener f(-1,1) lo que haremos será \\bra{10}H \\ket{10} = f(-1,1).\nDe esta manera, parametrizando los estados, debemos calcular para que estado arbitrario el resultado es mínimo. \\bra{\\psi(\\theta)}H\\ket{\\psi (\\theta)}. Entonces lo que hacemos es probar con los distintos valores de \\theta para encontrar que estado minimiza el Hamiltoniano del sistema. Por lo tanto, el siguiente paso es poder introducir este Hamiltoniano como una función objetivo en el computador cuántico.\nDescomponer Hamiltoniano en puertas unitarias\nVamos a a tomar un Hamiltoniano puede ser descrito como:\nH = \\sum_{i=1}^{n} \\alpha_{i} z_{i} + \\sum_{i=1}^{n} \\sum_{j=1}^{n}\\beta_{i,j}z_{i}z_{j}+ \\cdots\nNos vamos a quedar con la parte solo la parte lineal y cuadrática, por lo tanto necesitamos poder descomponer z_{i} y z_{i}z_{j} en puertas cuánticas:\nDescomponer z_{i}\nLo que vamos a hacer ahora es definir representar el Hamiltoniano como puertas cuánticas, para ilustrar esto vamos a usar el ejemplo más sencillo f(z_{1}) =z_{1} . Buscamos entonces H tal que: \\bra{0}H\\ket{0} = 1 y \\bra{1}H\\ket{1} = -1. En este caso particular vemos que la puerta Z cumple con esta condición, con lo que es suficiente para definir H. De esta manera, en este caso podemos escribir H como: H =I \\otimes I\\otimes \\cdots\\otimes Z\\otimes \\cdots\\otimes I\\otimes I\nTodo puertas I excepto una puerta Z en la posición i-esima. Se puede demostrar calculando el valor esperado:\n\\bra{z_{1},\\dots,z_{i},\\dots z_{n}}&amp;H \\ket{z_{1},\\dots,z_{i},\\dots z_{n}} = \\\\\n\\bra{z_{1},\\dots,z_{i},\\dots z_{n}} I \\otimes I\\otimes \\cdots\\otimes &amp;Z\\otimes \\cdots\\otimes I\\otimes I\\ket{z_{1},\\dots,z_{i},\\dots z_{n}} = \\\\\n\\bra{z_{1}}I\\ket{z_{1}}\\dots \\bra{z_{i}}&amp;Z\\ket{z_{i}}\\dots \\bra{z_{n}}I\\ket{z_{n}}= \\\\\n\\bra{z_{i}}&amp;Z\\ket{z_{i}}        \n\\end{align}$$\n#### Descomponer $z_{i}z_{j}$\n\nHacemos lo mismo para una función $f(\\vec{z})=z_{i}z_{j}$, y llegamos a la conclusión de que el Hamiltoniano que describe esta función objetivo es el producto tensorial de todo puertas $I$ excepto una puerta $Z$ en la i-ésima posición y otra en la j-ésima posición.\n\n#### Ejemplo\n\nQueremos calcular la energía de la función objetivo $f(z_{1},z_{2}) = 2z_{1}-3z_{1}z_{2}$ para el estado $z_{1}=1$ y $z_{2}=-1$. Si expresamos la función objetivo como un Hamiltoniano descompuesto en puertas. $Z$, tenemos:\n$$f(1,-1)=2\\bra{01}Z\\otimes I\\ket{01} - 3\\bra{01}Z\\otimes Z\\ket{01}    $$\n\nPor último, lo único que nos queda definir es como calcular $\\bra{\\psi}Z_{i}\\ket{\\psi}$ y $\\bra{\\psi}Z_{i}Z_{j}\\ket{\\psi}$ en un ordenador cuántico para cualquier estado $\\psi$, para así saber que estado minimiza la energía y por lo tanto será nuestra solución.\nEl hecho de poder encontrar un equivalente del Hamiltoniano radica en que podemos calcular de manera eficiente el valor esperado de un estado con un computador cuántico. Por lo tanto la manera de resolver estos problema será **==calculando nuestro Hamiltoniano y descomponerlo en puertas cuánticas unitarias==**.\n\n\n## Calcular $\\bra{\\psi}Z_{i}\\ket{\\psi}$ y $\\bra{\\psi}Z_{i}Z_{j}\\ket{\\psi}$\n\nCalcular estas expresión consiste en calcular el valor esperado. En el caso $\\bra{\\psi}Z_{i}\\ket{\\psi}$ lo que hacemos es medir en el i-ésimo qubit y restar la probabilidad de observar el qubit en 0 menos la probabilidad de observarlo en 1. Esto es así porque los autovectores de $Z$ coinciden con la base computacional $\\{\\ket{0},\\ket{1}\\}$.:\n$$\\bra{\\psi}Z_{i}\\ket{\\psi} = P(\\ket{0}_{i}) - P(\\ket{1}_{i} )$$\nPara el caso $\\bra{\\psi}Z_{i}Z_{j}\\ket{\\psi}$ tenemos:\n$$\\bra{\\psi}Z_{i}Z_{j}\\ket{\\psi}= P(\\ket{00}_{i,j})+P(\\ket{11}_{i,j})-P(\\ket{01}_{i,j})-P(\\ket{10}_{i,j})$$\n\nSiendo por ejemplo, $P(\\ket{01}_{i,j})$ la probabilidad de encontrar el qubit i-ésimo en el estado 0 y el j-ésimo en el estado 0.\n\nDe esta manera tenemos todos las herramientas necesarias para el VQE\n## Desarrollo del Algoritmo VQE\nEsta algoritmo se es variacional, es decir, definiremos un estado inicial que irá cambiando a lo largo del tiempo con la idea de ir reduciendo su energía. Para ello utilizaremos una serie de puertas ($R_{z}, R_{x}, R_{y}$) que dependen de ciertos parámetros que iremos modificando para generar el estado óptimo.\n\n![[Pasted image 20240506185705.png|300]]\n\n1. Definimos los valores $\\vec{\\alpha}$ del [[ansatz]] para crear nuestro estado inicial $\\ket{\\psi}$.\n2. Calculamos la energía que tiene dicho estado definido por el Hamiltoniano utilizado el proceso utilizado en [[#definir-función-objetivo-con-hamiltoniano|Definir función objetivo con Hamiltoniano]].\n3. Calculamos el resultado obtenido midiendo y  utilizamos un optimizador clásico para optimizar los valores $\\vec{\\alpha}$ y aplicar de nuevo el procedimiento para ir reduciendo la energía.\n\nSe trata de un proceso totalmente a ciegas, donde solo tendremos la información correspondiente a los estados que hemos evaluado.\n[[Ejemplo VQE con PennyLane]]"},"Valores-propios-momento-angular":{"slug":"Valores-propios-momento-angular","filePath":"Valores propios momento angular.md","title":"Valores propios momento angular","links":[],"tags":[],"content":"Valores propios momento angular\nComo el operador L^2 y L conmutan, esto quiere decir que comparten funciones propias\n\n\n\n\n\n"},"ansatz":{"slug":"ansatz","filePath":"ansatz.md","title":"ansatz","links":[],"tags":[],"content":"Ansatz\nSe trata de una asunción inicial hecha para ayudar a resolver un problema."},"átomos-de-Rydberg":{"slug":"átomos-de-Rydberg","filePath":"átomos de Rydberg.md","title":"átomos de Rydberg","links":[],"tags":[],"content":"Átomos de Rydberg\nSe trata de un átomo excitado con uno o varios electrones con un número cuántico principal muy alto. Sus principales propiedades son:\n\nRespuesta exagerada a campos eléctricos y magnéticos debido a su momento dipolar relativamente grande.\nTiempos de decaimiento muy largos\nFunciones de onda que se aproximan a las orbitas clásicas de los electrones alrededor del núcleo.\nLos electrones externos perciben un potencial similar al potencial eléctrico del átomo de hidrogeno. El electrón excitado está tan alejado de la nube de electrones que puede considerarse al núcleo y al resto de electrones como un núcleo de carga neta +1.\n"},"circuito-LC":{"slug":"circuito-LC","filePath":"circuito LC.md","title":"circuito LC","links":[],"tags":[],"content":"Circuito LC\nEl circuito LC es la base de la electrónica de radiofrecuencia, utiliza dos componentes: un condensador y una inductancia. No vamos a entrar en detalles del funcionamiento de este sistema, pero como idea general, los electrones se mueven de un extremo a otro del condensador con una frecuencia que depende de la capacidad del condensador C y la inductancia L. Este flujo de electrones a través de la inductancia genera radiación\nelectromagnética de una frecuencia determinada. Lo que nos interesa ahora es calcular el Hamiltoniano de este sistema, que básicamente depende de la energía eléctrica del condensador y la magnética del inductor:\nH = \\frac{1}{2}CV^2+\\frac{1}{2}LI^2"},"círculos-complejos":{"slug":"círculos-complejos","filePath":"círculos complejos.md","title":"círculos complejos","links":[],"tags":[],"content":"Círculos complejos\nDefinición\n\nEjemplo\n"},"coeficiente-de-Schmidt":{"slug":"coeficiente-de-Schmidt","filePath":"coeficiente de Schmidt.md","title":"coeficiente de Schmidt","links":[],"tags":[],"content":"coeficiente de Schmidt\n\n"},"combinación-lineal":{"slug":"combinación-lineal","filePath":"combinación lineal.md","title":"combinación lineal","links":[],"tags":[],"content":"Combinación lineal\nDefinición\n\nEjemplo\n"},"completo":{"slug":"completo","filePath":"completo.md","title":"completo","links":["completo","Distancia"],"tags":[],"content":"Definición\nUn espacio vectorial es completo, si todas sus  Sucesión de Cauchy convergen, es decir:\n\nSucesión de Cauchy\n una sucesión de Cauchy es una sucesión tal que para cualquier Distancia dada, por muy pequeña que sea (llamada habitualmente con la letra ε,un real positivo arbitrariamente pequeño), siempre se puede encontrar un término de la sucesión tal que la distancia entre dos términos cualesquiera posteriores es menor que la dada.\n"},"conmutador":{"slug":"conmutador","filePath":"conmutador.md","title":"conmutador","links":[],"tags":[],"content":"Conmutadores"},"curvas-complejas":{"slug":"curvas-complejas","filePath":"curvas complejas.md","title":"curvas complejas","links":[],"tags":[],"content":"Curvas complejas\nDefinición\n\nCurva cerrada\n\nEjemplo\n"},"destilación":{"slug":"destilación","filePath":"destilación.md","title":"destilación","links":[],"tags":[],"content":"destilación\nMétodo para obtener sistemas cuánticos\n"},"dilución":{"slug":"dilución","filePath":"dilución.md","title":"dilución","links":["destilación"],"tags":[],"content":"dilución\nA partir de un estado entrelazado, obtenemos uno puro. Opuesto a destilación\n"},"disco-complejo":{"slug":"disco-complejo","filePath":"disco complejo.md","title":"disco complejo","links":[],"tags":[],"content":"Disco complejo\nDefinición\n\nEjemplo\n"},"distancia-de-traza":{"slug":"distancia-de-traza","filePath":"distancia de traza.md","title":"distancia de traza","links":[],"tags":[],"content":"Distancia de traza\n"},"enfriamiento-Doppler":{"slug":"enfriamiento-Doppler","filePath":"enfriamiento Doppler.md","title":"enfriamiento Doppler","links":[],"tags":[],"content":"Enfriamiento Doppler\nMecanismo que puede utilizarse para confinar y frenar el movimiento de los átomos y así enfriar la sustancia.\nSe utiliza una luz de frecuencia ligeramente inferior a la de transición electrónica. Como la luz está desviada al rojo de la transición, los átomos absorberán más fotones si se mueven hacía la fuente de luz. Si aplicamos luz desde dos direcciones opuestas , los átomos absorberán más fotones del haz de láser que apunta en el sentido opuesto de su movimiento. En cada proceso de absorción, el átomo pierde momento lineal igual al momento del fotón, dando lugar a disminución del movimiento y por tanto enfriamiento.\n\n\nUn átomo estacionario no ve el láser ni desplazado al rojo ni al azul y no absorbe el fotón.\nUn átomo moviéndose respecto al láser lo ve desplazado al rojo y no absorbe el fotón.\nUn átomo moviéndose hacia el láser lo ve desplazado al azul y absorbe el fotón, frenando el átomo.\n"},"entrelazamiento":{"slug":"entrelazamiento","filePath":"entrelazamiento.md","title":"entrelazamiento","links":["tags/Tema","operador-densidad-reducido","destilación","dilución","teleportación-cuántica"],"tags":["Tema"],"content":"Entrelazamiento cuántico Tema\nEl entrelazamiento cuántico es un fenómeno que se da cuando el estado cuántico de un sistema no puede expresarse como la combinación de los estados de los subsistemas que lo forman. Es decir, en un sistema formado por dos partículas, estas pueden estar entrelazadas y por lo tanto no pueden ser descritas de forma separada.\n\nLa mejor manera de obtener información sobre estados entrelazados es mediante el operador densidad reducido\nObtención de sistemas entrelazados y desentrelazamiento\n\nPara crear sistemas entrelazados, podemos utilizar el método de destilación\nPara obtener un estado puro a partir de un estado entrelazado, utilizamos la dilución\n\nUna de las aplicaciones del entrelazamiento es la teleportación cuántica"},"estado-mixto":{"slug":"estado-mixto","filePath":"estado mixto.md","title":"estado mixto","links":["operador-densidad"],"tags":[],"content":"Estado mixto\nUn estado mixto es aquel del que no tenemos la máxima información. Se dice que un sistema se encuentra en un estado mezcla cuando no se dispone del máximo grado de información que puede obtener sobre sus propiedades u observables.\nLa traza del operador densidad de un estado mixto, siempre es menor que 1."},"estado-puro":{"slug":"estado-puro","filePath":"estado puro.md","title":"estado puro","links":["operador-densidad"],"tags":[],"content":"Estado puro\nUn estado puro es una combinación lineal de dos o más estados de los componentes. Por ejemplo, un qubit en un estado puro (también llamado de superposición coherente) es un estado en el que cualquier medida que se hiciera del qubit producirá el mismo resultado.\nEjemplo:\n\nLa traza del  operador densidad de un estado puro es 1."},"estados-de-Bell":{"slug":"estados-de-Bell","filePath":"estados de Bell.md","title":"estados de Bell","links":["entrelazamiento"],"tags":[],"content":"Estados de Bell\nLos estados de Bell o pares EPR, son un sistema de dos qubits en un estado de entrelazamiento.\n\nSon estados máximamente entrelazados, y el último de ellos es un estado anti-correlacionado."},"fidelidad":{"slug":"fidelidad","filePath":"fidelidad.md","title":"fidelidad","links":[],"tags":[],"content":"Fidelidad\n"},"forma-polar":{"slug":"forma-polar","filePath":"forma polar.md","title":"forma polar","links":[],"tags":[],"content":"Forma Polar\n"},"independencia-lineal":{"slug":"independencia-lineal","filePath":"independencia lineal.md","title":"independencia lineal","links":[],"tags":[],"content":"Independencia lineal\nDefinición\n\nEjemplo\n\n"},"lectura-qubits-trampa-de-iones":{"slug":"lectura-qubits-trampa-de-iones","filePath":"lectura qubits trampa de iones.md","title":"lectura qubits trampa de iones","links":["Estado-excitado","Inicialización-qubits-trampa-de-iones"],"tags":[],"content":"Lectura qubits trampa de iones\nEl estado de un se puede leer a través de energía de la fluorescencia de la transición del Estado excitado al estado fundamental. Utilizamos iones con un único electrón en la capa de valencia.\nPara la lectura del estado del qubit se utiliza un procedimiento similar a la Inicialización qubits trampa de iones, iluminado el ion con un láser a la frecuencia de transición  \\ket{\\uparrow}\\rightarrow\\ket{e}. Esto hace que si estaba en el estado \\ket{\\uparrow}, se excite al estado \\ket{e} y vuelva a decaer emitiendo una intensa fluorescencia y que si estaba en el estado \\ket{\\downarrow}, no interactuará con el láser y permanecerá oscuro.\nMediante dispositivos como foto diodos o cámaras CCD es posible identificar cuáles de los iones se encontraban en uno u otro estado en función de si emiten fluorescencia o no.\n"},"limite-de-Holevo":{"slug":"limite-de-Holevo","filePath":"limite de Holevo.md","title":"limite de Holevo","links":[],"tags":[],"content":"Límite de Holevo\nLa capacidad de enviar información clásica a través de canales cuánticos.\nEstablece que dado 𝑛 qubits, si bien se podrían transmitir un número superior de información clásica (gracias a la superposición de los qubits), solo podrían ser recuperados 𝑛 bits clásicos. Esta circunstancia limita la cantidad de información que puede ser recuperada después de almacenarla en un sistema cuántico.\nUna fuente genera letras, 𝑋, de un alfabeto con las probabilidades, 𝑝𝑖, Alice codifica la variable aleatoria, 𝑋, y la transmite a través de un canal cuántico. Bob realiza una medición del sistema cuántico y el resultado de esta medición es una variable aleatoria, 𝑌. La información mutua, 𝐼(𝑋: 𝑌), mide la cantidad de información sobre 𝑋 que Bob puede inferir a partir de la medición. Independientemente de la medición realizada por Bob, la información mutua está limitada por el límite de Holevo:\n"},"minimum--vertex-cover-con-QAOA":{"slug":"minimum--vertex-cover-con-QAOA","filePath":"minimum  vertex cover con QAOA.md","title":"minimum  vertex cover con QAOA","links":[],"tags":[],"content":"Minimum vertex cover con QAOA\n"},"operador-densidad-reducido":{"slug":"operador-densidad-reducido","filePath":"operador densidad reducido.md","title":"operador densidad reducido","links":["operador-densidad","entrelazamiento","coeficiente-de-Schmidt"],"tags":[],"content":"operador densidad reducido\nEs una de las herramientas del operador densidad que se usa para estados entrelazados.entrelazamiento\n\nPara caracterizar un sistema entrelazado podemos utilizar el coeficiente de Schmidt, que básicamente son el numero de valores propios distintos de cero en la matriz densidad reducida."},"operador-densidad":{"slug":"operador-densidad","filePath":"operador densidad.md","title":"operador densidad","links":["Observables","estado-puro","Proyectores","estado-mixto"],"tags":[],"content":"Operador densidad\nIntroducimos el operador densidad, que codifica todas las propiedades estadísticas de un sistema cuántico en la situación más general posible. Lo definimos como:\n\nPodemos utilizarlo para calcular el valor esperado de un Observables de la siguiente manera:\n\nPara  estado puro la traza del operador densidad al cuadrado es uno ⇒ tr(p^2) =1. Y este operador es un operador proyecto ya que p = p^2. Proyectores\nPara un  estado mixto la traza del operador densidad al cuadrado es siempre menor que 1 y no es un operador proyección"},"operadores-hermitico-unitarios":{"slug":"operadores-hermitico-unitarios","filePath":"operadores hermitico-unitarios.md","title":"operadores hermitico-unitarios","links":[],"tags":[],"content":"operadores hermitico-unitarios\n"},"operadores-hermíticos":{"slug":"operadores-hermíticos","filePath":"operadores hermíticos.md","title":"operadores hermíticos","links":[],"tags":[],"content":"Operador Hermítico\nUn operador hermítico (también llamado operador hermitiano, en honor a Charles Hermite) definido sobre un espacio de Hilbert es un operador lineal que, sobre un cierto dominio, coincide con su propio operador adjunto. Una propiedad importante de estos operadores es que sus autovalores son siempre números reales.\nA = adj(A)\n"},"producto-interno":{"slug":"producto-interno","filePath":"producto interno.md","title":"producto interno","links":[],"tags":[],"content":"Definición\n\nPropiedades\n"},"puertas-cuánticas-con-trampas-de-iones":{"slug":"puertas-cuánticas-con-trampas-de-iones","filePath":"puertas cuánticas con trampas de iones.md","title":"puertas cuánticas con trampas de iones","links":["Oscilador-armónico-cuántico","estados-de-Bell","Trampas-de-Paul-planas"],"tags":[],"content":"Puertas cuánticas con trampas de iones\nRotaciones en la esfera de Bloch\nPara poder realizar rotaciones arbitrarias en la esfera de Bloch, es necesario considerar no solo las transiciones electrónicas de los iones, sino también si estado de movimiento en el seno de la trampa.\nEl movimiento del ion atrapado se caracteriza por unas frecuencias de resonancia definidas por el potencial de confinamiento, que se puede aproximar al potencial de un Oscilador armónico cuántico. Los diferentes estados de movimiento del ion se pueden codificar como un estado cuántico al que denotaremos por \\ket{n} con  n = 0,1,\\dots en función del estado de movimiento.Teniendo en cuenta los estados electrónicos y los de movimiento, podemos definir el estado de un qubit en un momento dado como la combinación de ambos: \\ket{\\downarrow, n} o \\ket{\\uparrow,n}.\nLos estados de espín y de movimiento del láser se pueden acoplar modulando la frecuencia del láser \\omega_{\\uparrow \\rightarrow e}\\pm \\omega_{m} donde \\omega_{m} es la diferencia de frecuencia entre estados de movimiento. Esta excitación hará evolucionar al qubit desde el estado \\ket{\\uparrow, n} al estado \\ket{e, n+\\Delta n}, que puede ser descrito como una rotación R_{\\Delta n(\\theta,\\phi)} en la esfera de Bloch. Usando esta técnica, \\theta depende de la duración del pulso del láser y \\phi depende de su fase en la posición de ion.\nAsí representamos el acoplamiento entre los estados electrónicos del ion y el potencial armónico de la trampa\n\nPuertas de dos qubits\nEn la misma trampa\nPara generar puertas con dos qubits mediante entrelazamiento, tales como CNOT o CPHASE, también se utilizan los estados vibracionales  de movimiento de los iones. Para ello. se iluminan con la misma radiación láser simultáneamente dos iones que estén en una misma cadena. Los estados de espín de ambos iones pueden entrelazarse a través de la interacción de sus estados de movimiento.\nEn distintas trampas\nTambién se pueden entrelazar qubits que están en diferentes trampas mediante técnicas fotónicas con el uso de pulsos láser cortos que provoquen la generación de fotones individuales en los iones. Si los fotones emitidos por dos de estas trampas son enviados a un divisor de hay y detectados simultáneamente es un indicativo de la existencia de un estados de Bell entre los dos fotones y, por lo tanto, de que los iones que los han generado están entrelazados. Debido a la baja probabilidad de que dos fotones interfieran, esta técnica es muy lenta. Incluso excitando los iones de comunicación con pulsos de picosegundos a frecuencias de GHz. No obstante demuestra la posibilidad de conectar dos registros cuánticos de iones situados en diferentes trampas.\nOtra forma de operar con qubits agrupados en diferentes trampas consiste en desplazar alguno de ellos de una trampa a otra. Las distintas trampas tiene que estar a una distancia tal que se puedan considerar independientes, de manera que la única interacción entre ellas sean los iones que se han hecho viajar entre ellas. Para aplicar esta tecnica, los ordenadores basados en trampas de iones utilizan Trampas de Paul planas"},"puertas-de-rotación-QAOA":{"slug":"puertas-de-rotación-QAOA","filePath":"puertas de rotación QAOA.md","title":"puertas de rotación QAOA","links":["Modelo-Ising","Puertas-cuánticas"],"tags":[],"content":"Puertas de rotación QAOA\nExplicaremos dos puertas unitarias que utilizaremos en el algoritmo QAOA, que son U(C,\\gamma) y U(B,\\beta).\nU(C,\\gamma). Rotación en Z\nU(C,\\gamma) = e^{-iC\\gamma} = e^{-i\\gamma \\sum_{i=1}^{m}C_{{i}}} = \\prod_{i=1}^{m}e^{-i\\gamma C_{i}}\nExiste una relación entre C y  el Hamiltoniano tipo Ising, por lo tanto podemos descomponer C utilizado puertas de Pauli Z \\sigma_{z}. Por lo tanto, ==podemos aprovechar la descomposición de la exponencial Hamiltoniano tipo Ising para construir la puerta  U(C,\\gamma), ya que serán iguales.==\nTransclude of Modelo-Ising#descomponer-exponencial-de-hamiltoniano-tipo-ising-como-puertas-de-pauli\nU(B,\\beta). Rotación en X\nSiendo:\nB = \\sum_{i=1}^m \\sigma_{i}^x\nPodemos definir:\nU(B,\\beta) = e^{-i\\beta B} = \\prod_{i=1}^n e^{-i\\beta \\sigma_{i}^x}\nVamos a hacerlo lo mismo que para la otra puerta pero utilizando la propiedad H\\sigma^z H = \\sigma^x siendo H la puerta de Hadamard.Puerta Hadamard (H). Tenemos que:\ne^{it\\sigma^x} = \\cos(t)I + i\\sin(t)\\sigma^x = \\cos(t)I + i\\sin(t)H\\sigma^z H = HR_{z}H = R_{X}\nPor lo tanto la puerta U(B,\\beta) es equivalente a una puerta R_{x}(-2\\beta)"},"rectas-complejas":{"slug":"rectas-complejas","filePath":"rectas complejas.md","title":"rectas complejas","links":[],"tags":[],"content":"Rectas complejas\nDefinición\n\nEjemplo\n\n\n\n"},"superposición-cuántica":{"slug":"superposición-cuántica","filePath":"superposición cuántica.md","title":"superposición cuántica","links":["Principio-de-incertidumbre"],"tags":[],"content":"Superposición cuántica\nLa superposición cuántica es un principio fundamental de la mecánica cuántica que sostiene que un sistema físico tal como un electrón, existe en parte en todos sus teóricamente posibles estados (o la configuración de sus propiedades) de forma simultánea, pero, cuando se mide, da un resultado que corresponde a solo una de las posibles configuraciones.\nRelacionado con el Principio de incertidumbre."},"teleportación-cuántica":{"slug":"teleportación-cuántica","filePath":"teleportación cuántica.md","title":"teleportación cuántica","links":[],"tags":[],"content":"Teleportación cuántica"},"teorema-de-Earnshaw":{"slug":"teorema-de-Earnshaw","filePath":"teorema de Earnshaw.md","title":"teorema de Earnshaw","links":[],"tags":[],"content":"Teorema de Earnshaw\nEl teorema de Earnshaw establece que un conjunto de cargas puntuales no se puede mantener en un estado de equilibrio mecánico estacionario exclusivamente mediante la interacción electrostática de las cargas.\nLa fuerza eléctrica \\vec{F}(\\vec{r}) que se deriva de un potencial U(\\vec{r}) en el espacio libro tendrá siempre una divergencia nula: \\vec{\\nabla} \\cdot \\vec{F}= \\vec{\\nabla} \\cdot(\\vec{\\nabla}U) = -\\nabla^2 U = 0\nPor lo tanto no hay mínimo o máximo local, del potencial del campo en el espacio libre, solo puntos de silla. No puede existir un equilibrio estable de la partícula y debe existir una estabilidad en al menos una dirección.\n\nEn resumen, el equilibrio que genera un campo electroestático no es un mínimo de energías, si no que se corresponde con un punto de silla, en el que cualquier perturbación romperá el equilibrio. En caso de átomos, estas perturbaciones pueden ser la temperatura y el radiar o absorber energía."},"transmón":{"slug":"transmón","filePath":"transmón.md","title":"transmón","links":["Qubits-de-carga","Unión-Josephson"],"tags":[],"content":"Transmón\nEs un tipo de Qubits de carga, pero menos sensible al ruido de carga, el espectro de energía se corresponde con Espectro de energía unión Josephson. Su diseño es:\n\nLa principal diferencia con los qubits de carga basados en cajas de pares de Cooper es en el ratio E_{J}/E_{C}, donde E_{J} es la energía de la Unión Josephson y E_{C} es la energía de carga. En los qubits de carga basados en cajas de pares de Cooper es E_{J}/E_{C}&lt;1 mientras que en los transmones tenemos E_{J}/E_{C}\\gg 1\nUnión entre transmones.\nPara poder hablar de computador cuántico, no basta con un solo qubit, tenemos que ser capaces de disponer de un conjunto de estos que puedan comunicarse entre sí.\nPara acceder a un qubit para su inicialización y lectura, o para conectar varios de estos, necesitaremos antenas o guías de onda. La manera más directa de hacerlo es mediante guías de onda conecta inductiva o capacitivamente con el circuito resonante que forma nuestro qubit.\n\nLa interacción con los qubits se puede activar y desactivar diseñándolos de tal manera que cada uno de ellos tenga una frecuencia de resonancia distinta. De esta manera, podemos seleccionar mediante frecuencias de resonancia el qubit sobre el que queremos actuar."},"Index":{"slug":"Index","filePath":"Index.md","title":"Index","links":["Algebra","Computación-cuántica","Implementación-física-de-un-procesador-cuántico","Información-cuántica","Matemáticas-de-la-información","Mecánica-cuántica"],"tags":[],"content":"Índice\nHola, soy Miguel Aliende. Este es mi cerebro digital sobre computación cuántica.\nAlgebra\nComputación cuántica\nImplementación física de un procesador cuántico\nInformación cuántica\nMatemáticas de la información\nMecánica cuántica"}}